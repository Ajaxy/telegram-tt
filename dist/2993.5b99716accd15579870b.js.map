{"version":3,"file":"2993.5b99716accd15579870b.js","mappings":"UAAIA,ECAAC,E,+CCqDkC,oBAAXC,QAA0BA,OAAOC,YA2EzBC,KAAKC,MAAM,KACJ,IAAIC,IAAI,CAChD,aAAc,sBAAuB,iBAAkB,0BAA2B,kBAhI7E,MA0KMC,EAAgC,IAAID,IAAI,CACnD,YAAa,YAAa,eAGfE,EAAgC,IAAIF,IAAI,CACnD,cAG2C,IAAIA,IAAI,CACnD,YACA,YACA,YACA,aACA,aACA,YACA,YACA,YACA,gBAGwC,IAAIA,IAAI,IAC7CC,KACAC,IAcyC,IAAIF,IAAI,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,OC3H3JG,KAAKC,QAAWC,IAEdC,QAAQC,MAAMF,GACdG,EAAa,CAAEC,KAAM,iBAAkBF,MAAO,CAAEG,QAASL,EAAEE,MAAMG,SAAW,mCAG9EP,KAAKQ,iBAAiB,sBAAuBN,IAE3CC,QAAQC,MAAMF,GACdG,EAAa,CAAEC,KAAM,iBAAkBF,MAAO,CAAEG,QAASL,EAAEO,OAAOF,SAAW,qCAvFjF,MAAMG,EAAgB,IAAIC,IAyE1B,SAASC,EAAeC,GACtB,OAAOA,aAAeC,aAAeD,aAAeE,YAiBtD,SAASV,EAAaW,EAAyBC,GACzCA,EACFC,YAAYF,EAAMC,GAElBC,YAAYF,GC1FhB,IAAIG,E,SACJ,MAAMC,EAAoB,IAAIC,SAAeC,IAC3CC,OAAOC,qBAAuB,KAC5BL,EAAa,CACXM,KAAMF,OAAOG,MAAM,cAAe,GAAI,IACtCC,QAASJ,OAAOG,MAAM,iBAAkB,GAAI,CAAC,WAC7CE,OAAQL,OAAOG,MAAM,gBAAiB,GAAI,CAAC,SAAU,SAAU,WAC/DG,OAAQN,OAAOG,MAAM,gBAAiB,SAAU,CAAC,WACjDI,OAAQP,OAAOG,MAAM,gBAAiB,GAAI,CAAC,SAAU,WACrDK,aAAcR,OAAOG,MAAM,wBAAyB,SAAU,CAAC,SAAU,YAG3EJ,QAQEU,EAAY,IAAIrB,IAyDtBsB,eAAeC,EAAYC,GACzB,MAAMC,QAAiBC,MAAMF,GACvBG,EAAcF,EAASG,QAAQC,IAAI,gBAGzC,GAAIF,MAAAA,GAAAA,EAAaG,WAAW,SAC1B,OAAOL,EAASM,OAGlB,MAAMC,QAAoBP,EAASO,cACnC,OAAOC,EAAAA,EAAAA,SAAQD,EAAa,CAAEE,GAAI,WAGpC,SAASC,EAAWC,EAAcC,EAAwBC,GACxD,MACMC,EAASF,EA3EY,GADC,GA6EtBG,EAFgBC,KAAKC,MAAMN,GAEDO,IAAMJ,EAChCK,EAAeJ,EAAYD,GAAW,EAAIC,EAAYD,EAAS,EAErE,MAAO,CACLK,aAAAA,EACAC,WAAY,KAAQL,EAAYI,GAChCE,mBAAoB9D,KAAK+D,KAAKT,EAAcM,IDtGjC,IAAyBI,EAAAA,EC6JlB,CACpBlC,KA/HFQ,eACE2B,EACAzB,EACA0B,EACAb,EACAc,EACAC,GAEK5C,SACGC,EAGR,MAAM2B,QAAab,EAAYC,GACzB6B,EAAmBC,SAASC,mBAAmBnB,GAAO,KAAM,GAC5DoB,EAAShD,EAAWM,OACpBwB,EAAc9B,EAAWY,aAAaoC,EAAQH,GACpD7C,EAAWS,OAAOuC,EAAQN,EAASA,GAEnC,MAAMO,EAAY,IAAIC,UAAUR,EAASA,IAEnC,aAAEN,EAAF,WAAgBC,EAAhB,mBAA4BC,GAAuBX,EAAWC,EAAMC,EAAeC,GAEzFjB,EAAUsC,IAAIV,EAAK,CACjBC,QAAAA,EAASN,aAAAA,EAAcY,OAAAA,EAAQC,UAAAA,EAAWN,YAAAA,IAG5CC,EAAOR,EAAcC,EAAYC,IAsGjCc,WAnGFtC,eACE2B,EACAzB,EACAa,EACAe,GAEK5C,SACGC,EAGR,MAAM2B,QAAab,EAAYC,GACzB6B,EAAmBC,SAASC,mBAAmBnB,GAAO,KAAM,IAC5D,OAAEoB,GAAWnC,EAAUQ,IAAIoB,GAC3BX,EAAc9B,EAAWY,aAAaoC,EAAQH,IAE9C,aAAET,EAAF,WAAgBC,EAAhB,mBAA4BC,GAAuBX,EAAWC,EAAMC,EAAeC,GAEzFc,EAAOR,EAAcC,EAAYC,IAmFjCe,aAtDFvC,eACE2B,EAAaa,EAAoBC,GAE5BvD,SACGC,EAGR,MAAM,QACJyC,EADI,aACKN,EADL,OACmBY,EADnB,UAC2BC,EAD3B,YACsCN,GACxC9B,EAAUQ,IAAIoB,GAEZe,EAAYF,EAAalB,EAE/BpC,EAAWW,OAAOqC,EAAQQ,GAC1B,MAAMC,EAAgBzD,EAAWU,OAAOsC,GAClCnD,EAAOO,OAAOsD,OAAOC,SAASF,EAAeA,EAAiBf,EAAUA,EAAU,GAExF,GAAIC,EAAa,CACf,MAAMiB,EAAM,IAAIC,kBAAkBhE,IAYtC,SAAoB+D,EAAwBE,GAC1C,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAII,OAAQD,GAAK,EACnCH,EAAIG,GAAKD,EAAM,GACfF,EAAIG,EAAI,GAAKD,EAAM,GACnBF,EAAIG,EAAI,GAAKD,EAAM,GAfnBG,CAAWL,EAAKjB,GAChBM,EAAUpD,KAAKsD,IAAIS,QAEnBX,EAAUpD,KAAKsD,IAAItD,GAKrB0D,EAAWD,QAFeY,kBAAkBjB,KA8B5CzC,QAjBF,SAASA,EAAQiC,GAAiC,IAApB0B,EAAoB,wDAChD,IACE,MAAMC,EAAWvD,EAAUQ,IAAIoB,GAC/BzC,EAAWQ,QAAQ4D,EAASpB,QAC5BnC,EAAUwD,OAAO5B,GACjB,MAAO6B,GAEFH,GACHI,YAAW,IAAM/D,EAAQiC,GAAK,IAnIP,QDpB3B+B,UAAY1D,MAAAA,IACV,MAAM,KAAEjB,GAAST,EAEjB,OAAQS,EAAKV,MACX,IAAK,aAAc,CACjB,MAAM,UACJsF,EADI,KACOC,EADP,KACaC,EADb,aACmBC,GACrB/E,EACJ,IACE,GAAI4E,GAAaG,EAAc,CAC7B,MAAMC,EAAW,WAA4B,2BAAxBC,EAAwB,yBAAxBA,EAAwB,gBAC3C,MAAMC,EAAUD,EAAaA,EAAad,OAAS,GAEnD9E,EAAa,CACXC,KAAM,iBACNsF,UAAAA,EACAK,aAAAA,GACCrF,EAAesF,GAAW,CAACA,QAAWC,IAG3CzF,EAAc4D,IAAIsB,EAAWI,GAE7BF,EAAKM,KAAKJ,GAGZ,MAAO5D,EAAUiE,SAAuB1C,EAAIkC,MAASC,IAAU,GAE3DF,GACFvF,EACE,CACEC,KAAM,iBACNsF,UAAAA,EACAxD,SAAAA,GAEFiE,GAGJ,MAAOjG,GAMHwF,GACFvF,EAAa,CACXC,KAAM,iBACNsF,UAAAA,EACAxF,MAAO,CAAEG,QAASH,EAAMG,WAK1BqF,GACFlF,EAAc8E,OAAOI,GAGvB,MAEF,IAAK,iBAAkB,CACrB,MAAMI,EAAWtF,EAAc8B,IAAIxB,EAAK4E,WACpCI,IACFA,EAASM,YAAa,GAGxB,U,UE1ERC,EAAOC,QAAU,s0zH,UCIjBD,EAAOC,QAAU,SAASC,GACzB,SAASC,EAAItG,GACQ,oBAAZD,UACJA,QAAQC,OAASD,QAAQuG,KAAK,kBAAmBtG,GAQtD,IAC2B,oBAAfuG,YAJmB,oBAAhBC,aAA2D,oBAArBpG,iBAKnDmG,WAAWF,GACe,oBAATI,KACjBA,KAAKC,KAAK,KAAML,GAEhBC,EAAI,yCAEJ,MAAOtG,GACRsG,EAAItG,M,gBCxBN,EAAQ,MAAR,CAAsF,EAAQ,UCC1F2G,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBd,IAAjBe,EACH,OAAOA,EAAaV,QAGrB,IAAID,EAASQ,EAAyBE,GAAY,CAGjDT,QAAS,IAOV,OAHAW,EAAoBF,GAAUH,KAAKP,EAAOC,QAASD,EAAQA,EAAOC,QAASQ,GAGpET,EAAOC,QAIfQ,EAAoBI,EAAID,EAGxBH,EAAoBK,EAAI,KAGvB,IAAIC,EAAsBN,EAAoBO,OAAEpB,EAAW,CAAC,OAAO,IAAOa,EAAoB,SAE9F,OADsBA,EAAoBO,EAAED,IRhCzC/H,EAAW,GACfyH,EAAoBO,EAAI,CAACC,EAAQC,EAAUC,EAAIC,KAC9C,IAAGF,EAAH,CAMA,IAAIG,EAAeC,EAAAA,EACnB,IAAS3C,EAAI,EAAGA,EAAI3F,EAAS4F,OAAQD,IAAK,CAGzC,IAFA,IAAKuC,EAAUC,EAAIC,GAAYpI,EAAS2F,GACpC4C,GAAY,EACPC,EAAI,EAAGA,EAAIN,EAAStC,OAAQ4C,MACpB,EAAXJ,GAAsBC,GAAgBD,IAAaK,OAAOC,KAAKjB,EAAoBO,GAAGW,OAAOtE,GAASoD,EAAoBO,EAAE3D,GAAK6D,EAASM,MAC9IN,EAASU,OAAOJ,IAAK,IAErBD,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACbvI,EAAS4I,OAAOjD,IAAK,GACrB,IAAIkD,EAAIV,SACEvB,IAANiC,IAAiBZ,EAASY,IAGhC,OAAOZ,EAvBNG,EAAWA,GAAY,EACvB,IAAI,IAAIzC,EAAI3F,EAAS4F,OAAQD,EAAI,GAAK3F,EAAS2F,EAAI,GAAG,GAAKyC,EAAUzC,IAAK3F,EAAS2F,GAAK3F,EAAS2F,EAAI,GACrG3F,EAAS2F,GAAK,CAACuC,EAAUC,EAAIC,ISL/BX,EAAoBqB,EAAI,GAGxBrB,EAAoB9G,EAAKoI,GACjBjH,QAAQkH,IAAIP,OAAOC,KAAKjB,EAAoBqB,GAAGG,QAAO,CAACC,EAAU7E,KACvEoD,EAAoBqB,EAAEzE,GAAK0E,EAASG,GAC7BA,IACL,KCNJzB,EAAoB0B,EAAKJ,GAEZA,EAAL,2BCFRtB,EAAoB2B,SAAYL,MCDhCtB,EAAoB4B,EAAI,WACvB,GAA0B,iBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOC,MAAQ,IAAIC,SAAS,cAAb,GACd,MAAO7I,GACR,GAAsB,iBAAXT,OAAqB,OAAOA,QALjB,GCAxBuH,EAAoBgC,EAAI,CAACnI,EAAKoI,IAAUjB,OAAOkB,UAAUC,eAAerC,KAAKjG,EAAKoI,G,MCAlF,IAAIG,EACApC,EAAoB4B,EAAES,gBAAeD,EAAYpC,EAAoB4B,EAAEU,SAAW,IACtF,IAAIC,EAAWvC,EAAoB4B,EAAEW,SACrC,IAAKH,GAAaG,IACbA,EAASC,gBACZJ,EAAYG,EAASC,cAAc/C,MAC/B2C,GAAW,CACf,IAAIK,EAAUF,EAASG,qBAAqB,UACzCD,EAAQtE,SAAQiE,EAAYK,EAAQA,EAAQtE,OAAS,GAAGsB,KAK7D,IAAK2C,EAAW,MAAM,IAAIO,MAAM,yDAChCP,EAAYA,EAAUQ,QAAQ,OAAQ,IAAIA,QAAQ,QAAS,IAAIA,QAAQ,YAAa,KACpF5C,EAAoB6C,EAAIT,G,SCXxB,IAAIU,EAAkB,CACrB,KAAM,GAgBP9C,EAAoBqB,EAAEnD,EAAI,CAACoD,EAASG,KAE/BqB,EAAgBxB,IAElBe,cAAcrC,EAAoB6C,EAAI7C,EAAoB0B,EAAEJ,KAK/D,IAAIyB,EAAqB/J,KAA6B,uBAAIA,KAA6B,wBAAK,GACxFgK,EAA6BD,EAAmB3D,KAAK6D,KAAKF,GAC9DA,EAAmB3D,KAvBCpF,IACnB,IAAKyG,EAAUyC,EAAaC,GAAWnJ,EACvC,IAAI,IAAIiG,KAAYiD,EAChBlD,EAAoBgC,EAAEkB,EAAajD,KACrCD,EAAoBI,EAAEH,GAAYiD,EAAYjD,IAIhD,IADGkD,GAASA,EAAQnD,GACdS,EAAStC,QACd2E,EAAgBrC,EAAS2C,OAAS,EACnCJ,EAA2BhJ,K,GdnBxBxB,EAAOwH,EAAoBK,EAC/BL,EAAoBK,EAAI,IAChBL,EAAoB9G,EAAE,MAAMmK,KAAK7K,GeDfwH,EAAoBK,K","sources":["webpack://telegram-t/webpack/runtime/chunk loaded","webpack://telegram-t/webpack/runtime/startup chunk dependencies","webpack://telegram-t/./src/config.ts","webpack://telegram-t/./src/util/createWorkerInterface.ts","webpack://telegram-t/./src/lib/rlottie/rlottie.worker.ts","webpack://telegram-t/./src/lib/rlottie/rlottie-wasm.js","webpack://telegram-t/./node_modules/script-loader/addScript.js","webpack://telegram-t/./src/lib/rlottie/rlottie-wasm.js?3270","webpack://telegram-t/webpack/bootstrap","webpack://telegram-t/webpack/runtime/ensure chunk","webpack://telegram-t/webpack/runtime/get javascript chunk filename","webpack://telegram-t/webpack/runtime/get mini-css chunk filename","webpack://telegram-t/webpack/runtime/global","webpack://telegram-t/webpack/runtime/hasOwnProperty shorthand","webpack://telegram-t/webpack/runtime/publicPath","webpack://telegram-t/webpack/runtime/importScripts chunk loading","webpack://telegram-t/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(5802).then(next);\n};","import type { ApiLimitType } from './global/types';\n\nexport const APP_NAME = process.env.APP_NAME || 'Telegram WebZ';\nexport const APP_VERSION = process.env.APP_VERSION!;\nexport const RELEASE_DATETIME = process.env.RELEASE_DATETIME;\n\nexport const PRODUCTION_HOSTNAME = 'web.telegram.org';\n\nexport const DEBUG = process.env.APP_ENV !== 'production';\nexport const DEBUG_MORE = false;\n\nexport const IS_MOCKED_CLIENT = process.env.APP_MOCKED_CLIENT === '1';\nexport const IS_TEST = process.env.APP_ENV === 'test';\nexport const IS_PERF = process.env.APP_ENV === 'perf';\nexport const IS_BETA = process.env.APP_ENV === 'staging';\n\nexport const BETA_CHANGELOG_URL = 'https://telegra.ph/WebZ-Beta-04-01';\n\nexport const DEBUG_ALERT_MSG = 'Shoot!\\nSomething went wrong, please see the error details in Dev Tools Console.';\nexport const DEBUG_GRAMJS = false;\n\nexport const PAGE_TITLE = 'Telegram';\nexport const INACTIVE_MARKER = ' [Inactive]';\n\nexport const DEBUG_PAYMENT_SMART_GLOCAL = false;\n\nexport const SESSION_USER_KEY = 'user_auth';\nexport const LEGACY_SESSION_KEY = 'GramJs:sessionId';\nexport const PASSCODE_CACHE_NAME = 'tt-passcode';\n\nexport const GLOBAL_STATE_CACHE_DISABLED = false;\nexport const GLOBAL_STATE_CACHE_KEY = 'tt-global-state';\nexport const GLOBAL_STATE_CACHE_USER_LIST_LIMIT = 500;\nexport const GLOBAL_STATE_CACHE_CHAT_LIST_LIMIT = 200;\nexport const GLOBAL_STATE_CACHE_CHATS_WITH_MESSAGES_LIMIT = 30;\nexport const GLOBAL_STATE_CACHE_CUSTOM_EMOJI_LIMIT = 150;\n\nexport const MEDIA_CACHE_DISABLED = false;\nexport const MEDIA_CACHE_NAME = 'tt-media';\nexport const MEDIA_CACHE_NAME_AVATARS = 'tt-media-avatars';\nexport const MEDIA_PROGRESSIVE_CACHE_DISABLED = false;\nexport const MEDIA_PROGRESSIVE_CACHE_NAME = 'tt-media-progressive';\nexport const CUSTOM_EMOJI_PREVIEW_CACHE_DISABLED = false;\nexport const CUSTOM_EMOJI_PREVIEW_CACHE_NAME = 'tt-custom-emoji-preview';\nexport const MEDIA_CACHE_MAX_BYTES = 512 * 1024; // 512 KB\nexport const CUSTOM_BG_CACHE_NAME = 'tt-custom-bg';\nexport const LANG_CACHE_NAME = 'tt-lang-packs-v14';\nexport const ASSET_CACHE_NAME = 'tt-assets';\nexport const AUTODOWNLOAD_FILESIZE_MB_LIMITS = [1, 5, 10, 50, 100, 500];\n\nexport const DOWNLOAD_WORKERS = 16;\nexport const UPLOAD_WORKERS = 16;\n\nconst isBigScreen = typeof window !== 'undefined' && window.innerHeight >= 900;\n\nexport const MIN_PASSWORD_LENGTH = 1;\n\nexport const MESSAGE_LIST_SLICE = isBigScreen ? 60 : 40;\nexport const MESSAGE_LIST_VIEWPORT_LIMIT = MESSAGE_LIST_SLICE * 2;\n\nexport const CHAT_HEIGHT_PX = 72;\nexport const CHAT_LIST_SLICE = isBigScreen ? 30 : 25;\nexport const CHAT_LIST_LOAD_SLICE = 100;\nexport const SHARED_MEDIA_SLICE = 42;\nexport const MESSAGE_SEARCH_SLICE = 42;\nexport const GLOBAL_SEARCH_SLICE = 20;\nexport const MEMBERS_SLICE = 30;\nexport const MEMBERS_LOAD_SLICE = 200;\nexport const PINNED_MESSAGES_LIMIT = 50;\nexport const BLOCKED_LIST_LIMIT = 100;\nexport const PROFILE_PHOTOS_LIMIT = 40;\nexport const PROFILE_SENSITIVE_AREA = 500;\nexport const COMMON_CHATS_LIMIT = 100;\nexport const GROUP_CALL_PARTICIPANTS_LIMIT = 100;\nexport const REACTION_LIST_LIMIT = 100;\nexport const REACTION_UNREAD_SLICE = 100;\nexport const MENTION_UNREAD_SLICE = 100;\n\nexport const TOP_CHAT_MESSAGES_PRELOAD_LIMIT = 20;\n\nexport const SPONSORED_MESSAGE_CACHE_MS = 300000; // 5 min\n\nexport const DEFAULT_VOLUME = 1;\nexport const DEFAULT_PLAYBACK_RATE = 1;\nexport const PLAYBACK_RATE_FOR_AUDIO_MIN_DURATION = 20 * 60; // 20 min\n\nexport const ANIMATION_LEVEL_MIN = 0;\nexport const ANIMATION_LEVEL_MED = 1;\nexport const ANIMATION_LEVEL_MAX = 2;\nexport const ANIMATION_LEVEL_DEFAULT = ANIMATION_LEVEL_MAX;\n\nexport const DEFAULT_MESSAGE_TEXT_SIZE_PX = 16;\nexport const IOS_DEFAULT_MESSAGE_TEXT_SIZE_PX = 17;\nexport const MACOS_DEFAULT_MESSAGE_TEXT_SIZE_PX = 15;\n\nexport const DRAFT_DEBOUNCE = 10000; // 10s\nexport const SEND_MESSAGE_ACTION_INTERVAL = 3000; // 3s\n\nexport const EDITABLE_INPUT_ID = 'editable-message-text';\nexport const EDITABLE_INPUT_MODAL_ID = 'editable-message-text-modal';\n// eslint-disable-next-line max-len\nexport const EDITABLE_INPUT_CSS_SELECTOR = `.messages-layout .Transition__slide--active #${EDITABLE_INPUT_ID}, .messages-layout .Transition > .to #${EDITABLE_INPUT_ID}`;\n\nexport const CUSTOM_APPENDIX_ATTRIBUTE = 'data-has-custom-appendix';\n\n// Screen width where Pinned Message / Audio Player in the Middle Header can be safely displayed\nexport const SAFE_SCREEN_WIDTH_FOR_STATIC_RIGHT_COLUMN = 1440; // px\n// Screen width where Pinned Message / Audio Player in the Middle Header shouldn't collapse with ChatInfo\nexport const SAFE_SCREEN_WIDTH_FOR_CHAT_INFO = 1150; // px\n\nexport const MIN_SCREEN_WIDTH_FOR_STATIC_RIGHT_COLUMN = 1275; // px\nexport const MIN_SCREEN_WIDTH_FOR_STATIC_LEFT_COLUMN = 925; // px\nexport const MAX_SCREEN_WIDTH_FOR_EXPAND_PINNED_MESSAGES = 1340; // px\nexport const MOBILE_SCREEN_MAX_WIDTH = 600; // px\nexport const MOBILE_SCREEN_LANDSCAPE_MAX_WIDTH = 950; // px\nexport const MOBILE_SCREEN_LANDSCAPE_MAX_HEIGHT = 450; // px\n\nexport const LOCAL_MESSAGE_MIN_ID = 1e11; // `Date.now()` is always used as base\nexport const TMP_CHAT_ID = '0';\n\nexport const ANIMATION_END_DELAY = 100;\n\nexport const FAST_SMOOTH_MAX_DISTANCE = 1500;\nexport const FAST_SMOOTH_MIN_DURATION = 250;\nexport const FAST_SMOOTH_MAX_DURATION = 600;\nexport const FAST_SMOOTH_SHORT_TRANSITION_MAX_DISTANCE = 500; // px\n\n// Average duration of message sending animation\nexport const API_UPDATE_THROTTLE = Math.round((FAST_SMOOTH_MIN_DURATION + FAST_SMOOTH_MAX_DURATION) / 2);\nexport const API_THROTTLE_RESET_UPDATES = new Set([\n  'newMessage', 'newScheduledMessage', 'deleteMessages', 'deleteScheduledMessages', 'deleteHistory',\n]);\n\nexport const LOCK_SCREEN_ANIMATION_DURATION_MS = 200;\n\nexport const STICKER_SIZE_INLINE_DESKTOP_FACTOR = 13;\nexport const STICKER_SIZE_INLINE_MOBILE_FACTOR = 11;\nexport const STICKER_SIZE_AUTH = 160;\nexport const STICKER_SIZE_AUTH_MOBILE = 120;\nexport const STICKER_SIZE_PICKER = 64;\nexport const EMOJI_SIZE_PICKER = 40;\nexport const COMPOSER_EMOJI_SIZE_PICKER = 32;\nexport const STICKER_SIZE_GENERAL_SETTINGS = 48;\nexport const STICKER_SIZE_PICKER_HEADER = 32;\nexport const STICKER_PICKER_MAX_SHARED_COVERS = 20;\nexport const STICKER_SIZE_SEARCH = 64;\nexport const STICKER_SIZE_MODAL = 64;\nexport const EMOJI_SIZE_MODAL = 40;\nexport const STICKER_SIZE_TWO_FA = 160;\nexport const STICKER_SIZE_PASSCODE = 160;\nexport const STICKER_SIZE_DISCUSSION_GROUPS = 140;\nexport const STICKER_SIZE_FOLDER_SETTINGS = 100;\nexport const STICKER_SIZE_INLINE_BOT_RESULT = 100;\nexport const STICKER_SIZE_JOIN_REQUESTS = 140;\nexport const STICKER_SIZE_INVITES = 140;\nexport const RECENT_STICKERS_LIMIT = 20;\nexport const EMOJI_STATUS_LOOP_LIMIT = 2;\nexport const EMOJI_SIZES = 7;\nexport const RECENT_SYMBOL_SET_ID = 'recent';\nexport const FAVORITE_SYMBOL_SET_ID = 'favorite';\nexport const CHAT_STICKER_SET_ID = 'chatStickers';\nexport const PREMIUM_STICKER_SET_ID = 'premium';\nexport const EMOJI_IMG_REGEX = /<img[^>]+alt=\"([^\"]+)\"(?![^>]*data-document-id)[^>]*>/gm;\n\nexport const BASE_EMOJI_KEYWORD_LANG = 'en';\n\nexport const MENU_TRANSITION_DURATION = 200;\nexport const SLIDE_TRANSITION_DURATION = 450;\n\nexport const VIDEO_MOV_TYPE = 'video/quicktime';\nexport const VIDEO_WEBM_TYPE = 'video/webm';\n\nexport const SUPPORTED_IMAGE_CONTENT_TYPES = new Set([\n  'image/png', 'image/gif', 'image/jpeg',\n]);\n\nexport const SUPPORTED_VIDEO_CONTENT_TYPES = new Set([\n  'video/mp4', // video/quicktime added dynamically in environment.ts\n]);\n\nexport const SUPPORTED_AUDIO_CONTENT_TYPES = new Set([\n  'audio/mp3',\n  'audio/ogg',\n  'audio/wav',\n  'audio/mpeg',\n  'audio/flac',\n  'audio/aac',\n  'audio/m4a',\n  'audio/mp4',\n  'audio/x-m4a',\n]);\n\nexport const CONTENT_TYPES_WITH_PREVIEW = new Set([\n  ...SUPPORTED_IMAGE_CONTENT_TYPES,\n  ...SUPPORTED_VIDEO_CONTENT_TYPES,\n]);\n\nexport const CONTENT_NOT_SUPPORTED = 'The message is not supported on this version of Telegram.';\n\n// eslint-disable-next-line max-len\nexport const RE_LINK_TEMPLATE = '((ftp|https?):\\\\/\\\\/)?((www\\\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\\\.[a-zA-Z0-9()]{1,63})\\\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)';\nexport const RE_MENTION_TEMPLATE = '(@[\\\\w\\\\d_-]+)';\nexport const RE_TG_LINK = /^tg:(\\/\\/)?/;\nexport const RE_TME_LINK = /^(https?:\\/\\/)?([-a-zA-Z0-9@:%_+~#=]{1,32}\\.)?t\\.me/;\nexport const RE_TELEGRAM_LINK = /^(https?:\\/\\/)?telegram\\.org\\//;\nexport const TME_LINK_PREFIX = 'https://t.me/';\n\n// eslint-disable-next-line max-len\nexport const COUNTRIES_WITH_12H_TIME_FORMAT = new Set(['AU', 'BD', 'CA', 'CO', 'EG', 'HN', 'IE', 'IN', 'JO', 'MX', 'MY', 'NI', 'NZ', 'PH', 'PK', 'SA', 'SV', 'US']);\n\nexport const API_CHAT_TYPES = ['bots', 'channels', 'chats', 'users'] as const;\n\n// MTProto constants\nexport const SERVICE_NOTIFICATIONS_USER_ID = '777000';\nexport const REPLIES_USER_ID = '1271266957'; // TODO For Test connection ID must be equal to 708513\nexport const RESTRICTED_EMOJI_SET_ID = '7173162320003080';\nexport const ALL_FOLDER_ID = 0;\nexport const ARCHIVED_FOLDER_ID = 1;\nexport const DELETED_COMMENTS_CHANNEL_ID = '-777';\nexport const MAX_MEDIA_FILES_FOR_ALBUM = 10;\nexport const MAX_ACTIVE_PINNED_CHATS = 5;\nexport const SCHEDULED_WHEN_ONLINE = 0x7FFFFFFE;\nexport const DEFAULT_LANG_CODE = 'en';\nexport const DEFAULT_LANG_PACK = 'android';\nexport const LANG_PACKS = ['android', 'ios', 'tdesktop', 'macos'] as const;\nexport const FEEDBACK_URL = 'https://bugs.telegram.org/?tag_ids=41&sort=time';\n\nexport const LIGHT_THEME_BG_COLOR = '#99BA92';\nexport const DARK_THEME_BG_COLOR = '#0F0F0F';\nexport const DEFAULT_PATTERN_COLOR = '#4A8E3A8C';\nexport const DARK_THEME_PATTERN_COLOR = '#0A0A0A8C';\nexport const MAX_UPLOAD_FILEPART_SIZE = 524288;\n\n// Group calls\nexport const GROUP_CALL_VOLUME_MULTIPLIER = 100;\nexport const GROUP_CALL_DEFAULT_VOLUME = 100 * GROUP_CALL_VOLUME_MULTIPLIER;\nexport const GROUP_CALL_THUMB_VIDEO_DISABLED = true;\n\nexport const DEFAULT_LIMITS: Record<ApiLimitType, readonly [number, number]> = {\n  uploadMaxFileparts: [4000, 8000],\n  stickersFaved: [5, 10],\n  savedGifs: [200, 400],\n  dialogFiltersChats: [100, 200],\n  dialogFilters: [10, 20],\n  dialogFolderPinned: [5, 10],\n  captionLength: [1024, 2048],\n  channels: [500, 1000],\n  channelsPublic: [10, 20],\n  aboutLength: [70, 140],\n};\n","import type { CancellableCallback, OriginMessageEvent, WorkerMessageData } from './WorkerConnector';\nimport { DEBUG } from '../config';\n\ndeclare const self: WorkerGlobalScope;\n\nhandleErrors();\n\nconst callbackState = new Map<string, CancellableCallback>();\n\nexport default function createInterface(api: Record<string, Function>) {\n  onmessage = async (message: OriginMessageEvent) => {\n    const { data } = message;\n\n    switch (data.type) {\n      case 'callMethod': {\n        const {\n          messageId, name, args, withCallback,\n        } = data;\n        try {\n          if (messageId && withCallback) {\n            const callback = (...callbackArgs: any[]) => {\n              const lastArg = callbackArgs[callbackArgs.length - 1];\n\n              sendToOrigin({\n                type: 'methodCallback',\n                messageId,\n                callbackArgs,\n              }, isTransferable(lastArg) ? [lastArg] : undefined);\n            };\n\n            callbackState.set(messageId, callback);\n\n            args.push(callback as never);\n          }\n\n          const [response, arrayBuffers] = (await api[name](...args)) || [];\n\n          if (messageId) {\n            sendToOrigin(\n              {\n                type: 'methodResponse',\n                messageId,\n                response,\n              },\n              arrayBuffers,\n            );\n          }\n        } catch (error: any) {\n          if (DEBUG) {\n            // eslint-disable-next-line no-console\n            console.error(error);\n          }\n\n          if (messageId) {\n            sendToOrigin({\n              type: 'methodResponse',\n              messageId,\n              error: { message: error.message },\n            });\n          }\n        }\n\n        if (messageId) {\n          callbackState.delete(messageId);\n        }\n\n        break;\n      }\n      case 'cancelProgress': {\n        const callback = callbackState.get(data.messageId);\n        if (callback) {\n          callback.isCanceled = true;\n        }\n\n        break;\n      }\n    }\n  };\n}\n\nfunction isTransferable(obj: any) {\n  return obj instanceof ArrayBuffer || obj instanceof ImageBitmap;\n}\n\nfunction handleErrors() {\n  self.onerror = (e) => {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    sendToOrigin({ type: 'unhandledError', error: { message: e.error.message || 'Uncaught exception in worker' } });\n  };\n\n  self.addEventListener('unhandledrejection', (e) => {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    sendToOrigin({ type: 'unhandledError', error: { message: e.reason.message || 'Uncaught rejection in worker' } });\n  });\n}\n\nfunction sendToOrigin(data: WorkerMessageData, transferables?: Transferable[]) {\n  if (transferables) {\n    postMessage(data, transferables);\n  } else {\n    postMessage(data);\n  }\n}\n","import { inflate } from 'pako/dist/pako_inflate';\nimport createWorkerInterface from '../../util/createWorkerInterface';\nimport type { CancellableCallback } from '../../util/WorkerConnector';\n\nimport 'script-loader!./rlottie-wasm';\n\ndeclare const Module: any;\n\ndeclare function allocate(...args: any[]): string;\n\ndeclare function intArrayFromString(str: String): string;\n\nlet rLottieApi: Record<string, Function>;\nconst rLottieApiPromise = new Promise<void>((resolve) => {\n  Module.onRuntimeInitialized = () => {\n    rLottieApi = {\n      init: Module.cwrap('lottie_init', '', []),\n      destroy: Module.cwrap('lottie_destroy', '', ['number']),\n      resize: Module.cwrap('lottie_resize', '', ['number', 'number', 'number']),\n      buffer: Module.cwrap('lottie_buffer', 'number', ['number']),\n      render: Module.cwrap('lottie_render', '', ['number', 'number']),\n      loadFromData: Module.cwrap('lottie_load_from_data', 'number', ['number', 'number']),\n    };\n\n    resolve();\n  };\n});\n\nconst HIGH_PRIORITY_MAX_FPS = 60;\nconst LOW_PRIORITY_MAX_FPS = 30;\nconst DESTROY_REPEAT_DELAY = 1000;\n\nconst renderers = new Map<string, {\n  imgSize: number;\n  reduceFactor: number;\n  handle: any;\n  imageData: ImageData;\n  customColor?: [number, number, number];\n}>();\n\nasync function init(\n  key: string,\n  tgsUrl: string,\n  imgSize: number,\n  isLowPriority: boolean,\n  customColor: [number, number, number] | undefined,\n  onInit: CancellableCallback,\n) {\n  if (!rLottieApi) {\n    await rLottieApiPromise;\n  }\n\n  const json = await extractJson(tgsUrl);\n  const stringOnWasmHeap = allocate(intArrayFromString(json), 'i8', 0);\n  const handle = rLottieApi.init();\n  const framesCount = rLottieApi.loadFromData(handle, stringOnWasmHeap);\n  rLottieApi.resize(handle, imgSize, imgSize);\n\n  const imageData = new ImageData(imgSize, imgSize);\n\n  const { reduceFactor, msPerFrame, reducedFramesCount } = calcParams(json, isLowPriority, framesCount);\n\n  renderers.set(key, {\n    imgSize, reduceFactor, handle, imageData, customColor,\n  });\n\n  onInit(reduceFactor, msPerFrame, reducedFramesCount);\n}\n\nasync function changeData(\n  key: string,\n  tgsUrl: string,\n  isLowPriority: boolean,\n  onInit: CancellableCallback,\n) {\n  if (!rLottieApi) {\n    await rLottieApiPromise;\n  }\n\n  const json = await extractJson(tgsUrl);\n  const stringOnWasmHeap = allocate(intArrayFromString(json), 'i8', 0);\n  const { handle } = renderers.get(key)!;\n  const framesCount = rLottieApi.loadFromData(handle, stringOnWasmHeap);\n\n  const { reduceFactor, msPerFrame, reducedFramesCount } = calcParams(json, isLowPriority, framesCount);\n\n  onInit(reduceFactor, msPerFrame, reducedFramesCount);\n}\n\nasync function extractJson(tgsUrl: string) {\n  const response = await fetch(tgsUrl);\n  const contentType = response.headers.get('Content-Type');\n\n  // Support deprecated JSON format cached locally\n  if (contentType?.startsWith('text/')) {\n    return response.text();\n  }\n\n  const arrayBuffer = await response.arrayBuffer();\n  return inflate(arrayBuffer, { to: 'string' });\n}\n\nfunction calcParams(json: string, isLowPriority: boolean, framesCount: number) {\n  const animationData = JSON.parse(json);\n  const maxFps = isLowPriority ? LOW_PRIORITY_MAX_FPS : HIGH_PRIORITY_MAX_FPS;\n  const sourceFps = animationData.fr || maxFps;\n  const reduceFactor = sourceFps % maxFps === 0 ? sourceFps / maxFps : 1;\n\n  return {\n    reduceFactor,\n    msPerFrame: 1000 / (sourceFps / reduceFactor),\n    reducedFramesCount: Math.ceil(framesCount / reduceFactor),\n  };\n}\n\nasync function renderFrames(\n  key: string, frameIndex: number, onProgress: CancellableCallback,\n) {\n  if (!rLottieApi) {\n    await rLottieApiPromise;\n  }\n\n  const {\n    imgSize, reduceFactor, handle, imageData, customColor,\n  } = renderers.get(key)!;\n\n  const realIndex = frameIndex * reduceFactor;\n\n  rLottieApi.render(handle, realIndex);\n  const bufferPointer = rLottieApi.buffer(handle);\n  const data = Module.HEAPU8.subarray(bufferPointer, bufferPointer + (imgSize * imgSize * 4));\n\n  if (customColor) {\n    const arr = new Uint8ClampedArray(data);\n    applyColor(arr, customColor);\n    imageData.data.set(arr);\n  } else {\n    imageData.data.set(data);\n  }\n\n  const imageBitmap = await createImageBitmap(imageData);\n\n  onProgress(frameIndex, imageBitmap);\n}\n\nfunction applyColor(arr: Uint8ClampedArray, color: [number, number, number]) {\n  for (let i = 0; i < arr.length; i += 4) {\n    arr[i] = color[0];\n    arr[i + 1] = color[1];\n    arr[i + 2] = color[2];\n  }\n}\n\nfunction destroy(key: string, isRepeated = false) {\n  try {\n    const renderer = renderers.get(key)!;\n    rLottieApi.destroy(renderer.handle);\n    renderers.delete(key);\n  } catch (err) {\n    // `destroy` sometimes can be called before the initialization is finished\n    if (!isRepeated) {\n      setTimeout(() => destroy(key, true), DESTROY_REPEAT_DELAY);\n    }\n  }\n}\n\ncreateWorkerInterface({\n  init,\n  changeData,\n  renderFrames,\n  destroy,\n});\n","module.exports = \"var Module = typeof Module !== \\\"undefined\\\" ? Module : {};\\nvar moduleOverrides = {};\\nvar key;\\n\\nfor (key in Module) {\\n  if (Module.hasOwnProperty(key)) {\\n    moduleOverrides[key] = Module[key];\\n  }\\n}\\n\\nvar arguments_ = [];\\nvar thisProgram = \\\"./this.program\\\";\\n\\nvar quit_ = function (status, toThrow) {\\n  throw toThrow;\\n};\\n\\nvar ENVIRONMENT_IS_WEB = false;\\nvar ENVIRONMENT_IS_WORKER = false;\\nvar ENVIRONMENT_IS_NODE = false;\\nvar ENVIRONMENT_IS_SHELL = false;\\nENVIRONMENT_IS_WEB = typeof window === \\\"object\\\";\\nENVIRONMENT_IS_WORKER = typeof importScripts === \\\"function\\\";\\nENVIRONMENT_IS_NODE = typeof process === \\\"object\\\" && typeof process.versions === \\\"object\\\" && typeof process.versions.node === \\\"string\\\";\\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\\nvar scriptDirectory = \\\"\\\";\\n\\nfunction locateFile(path) {\\n  if (Module[\\\"locateFile\\\"]) {\\n    return Module[\\\"locateFile\\\"](path, scriptDirectory);\\n  }\\n\\n  return scriptDirectory + path;\\n}\\n\\nvar read_, readAsync, readBinary, setWindowTitle;\\nvar nodeFS;\\nvar nodePath;\\n\\nif (ENVIRONMENT_IS_NODE) {\\n  if (ENVIRONMENT_IS_WORKER) {\\n    scriptDirectory = require(\\\"path\\\").dirname(scriptDirectory) + \\\"/\\\";\\n  } else {\\n    scriptDirectory = __dirname + \\\"/\\\";\\n  }\\n\\n  read_ = function shell_read(filename, binary) {\\n    if (!nodeFS) nodeFS = require(\\\"fs\\\");\\n    if (!nodePath) nodePath = require(\\\"path\\\");\\n    filename = nodePath[\\\"normalize\\\"](filename);\\n    return nodeFS[\\\"readFileSync\\\"](filename, binary ? null : \\\"utf8\\\");\\n  };\\n\\n  readBinary = function readBinary(filename) {\\n    var ret = read_(filename, true);\\n\\n    if (!ret.buffer) {\\n      ret = new Uint8Array(ret);\\n    }\\n\\n    assert(ret.buffer);\\n    return ret;\\n  };\\n\\n  if (process[\\\"argv\\\"].length > 1) {\\n    thisProgram = process[\\\"argv\\\"][1].replace(/\\\\\\\\/g, \\\"/\\\");\\n  }\\n\\n  arguments_ = process[\\\"argv\\\"].slice(2);\\n\\n  if (typeof module !== \\\"undefined\\\") {\\n    module[\\\"exports\\\"] = Module;\\n  }\\n\\n  process[\\\"on\\\"](\\\"uncaughtException\\\", function (ex) {\\n    if (!(ex instanceof ExitStatus)) {\\n      throw ex;\\n    }\\n  });\\n  process[\\\"on\\\"](\\\"unhandledRejection\\\", abort);\\n\\n  quit_ = function (status) {\\n    process[\\\"exit\\\"](status);\\n  };\\n\\n  Module[\\\"inspect\\\"] = function () {\\n    return \\\"[Emscripten Module object]\\\";\\n  };\\n} else if (ENVIRONMENT_IS_SHELL) {\\n  if (typeof read != \\\"undefined\\\") {\\n    read_ = function shell_read(f) {\\n      return read(f);\\n    };\\n  }\\n\\n  readBinary = function readBinary(f) {\\n    var data;\\n\\n    if (typeof readbuffer === \\\"function\\\") {\\n      return new Uint8Array(readbuffer(f));\\n    }\\n\\n    data = read(f, \\\"binary\\\");\\n    assert(typeof data === \\\"object\\\");\\n    return data;\\n  };\\n\\n  if (typeof scriptArgs != \\\"undefined\\\") {\\n    arguments_ = scriptArgs;\\n  } else if (typeof arguments != \\\"undefined\\\") {\\n    arguments_ = arguments;\\n  }\\n\\n  if (typeof quit === \\\"function\\\") {\\n    quit_ = function (status) {\\n      quit(status);\\n    };\\n  }\\n\\n  if (typeof print !== \\\"undefined\\\") {\\n    if (typeof console === \\\"undefined\\\") console = {};\\n    console.log = print;\\n    console.warn = console.error = typeof printErr !== \\\"undefined\\\" ? printErr : print;\\n  }\\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\\n  if (ENVIRONMENT_IS_WORKER) {\\n    scriptDirectory = self.location.href;\\n  } else if (document.currentScript) {\\n    scriptDirectory = document.currentScript.src;\\n  }\\n\\n  if (scriptDirectory.indexOf(\\\"blob:\\\") !== 0) {\\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\\\"/\\\") + 1);\\n  } else {\\n    scriptDirectory = \\\"\\\";\\n  }\\n\\n  {\\n    read_ = function shell_read(url) {\\n      var xhr = new XMLHttpRequest();\\n      xhr.open(\\\"GET\\\", url, false);\\n      xhr.send(null);\\n      return xhr.responseText;\\n    };\\n\\n    if (ENVIRONMENT_IS_WORKER) {\\n      readBinary = function readBinary(url) {\\n        var xhr = new XMLHttpRequest();\\n        xhr.open(\\\"GET\\\", url, false);\\n        xhr.responseType = \\\"arraybuffer\\\";\\n        xhr.send(null);\\n        return new Uint8Array(xhr.response);\\n      };\\n    }\\n\\n    readAsync = function readAsync(url, onload, onerror) {\\n      var xhr = new XMLHttpRequest();\\n      xhr.open(\\\"GET\\\", url, true);\\n      xhr.responseType = \\\"arraybuffer\\\";\\n\\n      xhr.onload = function xhr_onload() {\\n        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\\n          onload(xhr.response);\\n          return;\\n        }\\n\\n        onerror();\\n      };\\n\\n      xhr.onerror = onerror;\\n      xhr.send(null);\\n    };\\n  }\\n\\n  setWindowTitle = function (title) {\\n    document.title = title;\\n  };\\n} else {}\\n\\nvar out = Module[\\\"print\\\"] || console.log.bind(console);\\nvar err = Module[\\\"printErr\\\"] || console.warn.bind(console);\\n\\nfor (key in moduleOverrides) {\\n  if (moduleOverrides.hasOwnProperty(key)) {\\n    Module[key] = moduleOverrides[key];\\n  }\\n}\\n\\nmoduleOverrides = null;\\nif (Module[\\\"arguments\\\"]) arguments_ = Module[\\\"arguments\\\"];\\nif (Module[\\\"thisProgram\\\"]) thisProgram = Module[\\\"thisProgram\\\"];\\nif (Module[\\\"quit\\\"]) quit_ = Module[\\\"quit\\\"];\\n\\nfunction dynamicAlloc(size) {\\n  var ret = HEAP32[DYNAMICTOP_PTR >> 2];\\n  var end = ret + size + 15 & -16;\\n  HEAP32[DYNAMICTOP_PTR >> 2] = end;\\n  return ret;\\n}\\n\\nfunction getNativeTypeSize(type) {\\n  switch (type) {\\n    case \\\"i1\\\":\\n    case \\\"i8\\\":\\n      return 1;\\n\\n    case \\\"i16\\\":\\n      return 2;\\n\\n    case \\\"i32\\\":\\n      return 4;\\n\\n    case \\\"i64\\\":\\n      return 8;\\n\\n    case \\\"float\\\":\\n      return 4;\\n\\n    case \\\"double\\\":\\n      return 8;\\n\\n    default:\\n      {\\n        if (type[type.length - 1] === \\\"*\\\") {\\n          return 4;\\n        } else if (type[0] === \\\"i\\\") {\\n          var bits = Number(type.substr(1));\\n          assert(bits % 8 === 0, \\\"getNativeTypeSize invalid bits \\\" + bits + \\\", type \\\" + type);\\n          return bits / 8;\\n        } else {\\n          return 0;\\n        }\\n      }\\n  }\\n}\\n\\nvar tempRet0 = 0;\\n\\nvar setTempRet0 = function (value) {\\n  tempRet0 = value;\\n};\\n\\nvar getTempRet0 = function () {\\n  return tempRet0;\\n};\\n\\nvar wasmBinary;\\nif (Module[\\\"wasmBinary\\\"]) wasmBinary = Module[\\\"wasmBinary\\\"];\\nvar noExitRuntime;\\nif (Module[\\\"noExitRuntime\\\"]) noExitRuntime = Module[\\\"noExitRuntime\\\"];\\n\\nif (typeof WebAssembly !== \\\"object\\\") {\\n  err(\\\"no native wasm support detected\\\");\\n}\\n\\nfunction setValue(ptr, value, type, noSafe) {\\n  type = type || \\\"i8\\\";\\n  if (type.charAt(type.length - 1) === \\\"*\\\") type = \\\"i32\\\";\\n\\n  switch (type) {\\n    case \\\"i1\\\":\\n      HEAP8[ptr >> 0] = value;\\n      break;\\n\\n    case \\\"i8\\\":\\n      HEAP8[ptr >> 0] = value;\\n      break;\\n\\n    case \\\"i16\\\":\\n      HEAP16[ptr >> 1] = value;\\n      break;\\n\\n    case \\\"i32\\\":\\n      HEAP32[ptr >> 2] = value;\\n      break;\\n\\n    case \\\"i64\\\":\\n      tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\\n      break;\\n\\n    case \\\"float\\\":\\n      HEAPF32[ptr >> 2] = value;\\n      break;\\n\\n    case \\\"double\\\":\\n      HEAPF64[ptr >> 3] = value;\\n      break;\\n\\n    default:\\n      abort(\\\"invalid type for setValue: \\\" + type);\\n  }\\n}\\n\\nvar wasmMemory;\\nvar wasmTable = new WebAssembly.Table({\\n  \\\"initial\\\": 522,\\n  \\\"maximum\\\": 522 + 0,\\n  \\\"element\\\": \\\"anyfunc\\\"\\n});\\nvar ABORT = false;\\nvar EXITSTATUS = 0;\\n\\nfunction assert(condition, text) {\\n  if (!condition) {\\n    abort(\\\"Assertion failed: \\\" + text);\\n  }\\n}\\n\\nfunction getCFunc(ident) {\\n  var func = Module[\\\"_\\\" + ident];\\n  assert(func, \\\"Cannot call unknown function \\\" + ident + \\\", make sure it is exported\\\");\\n  return func;\\n}\\n\\nfunction ccall(ident, returnType, argTypes, args, opts) {\\n  var toC = {\\n    \\\"string\\\": function (str) {\\n      var ret = 0;\\n\\n      if (str !== null && str !== undefined && str !== 0) {\\n        var len = (str.length << 2) + 1;\\n        ret = stackAlloc(len);\\n        stringToUTF8(str, ret, len);\\n      }\\n\\n      return ret;\\n    },\\n    \\\"array\\\": function (arr) {\\n      var ret = stackAlloc(arr.length);\\n      writeArrayToMemory(arr, ret);\\n      return ret;\\n    }\\n  };\\n\\n  function convertReturnValue(ret) {\\n    if (returnType === \\\"string\\\") return UTF8ToString(ret);\\n    if (returnType === \\\"boolean\\\") return Boolean(ret);\\n    return ret;\\n  }\\n\\n  var func = getCFunc(ident);\\n  var cArgs = [];\\n  var stack = 0;\\n\\n  if (args) {\\n    for (var i = 0; i < args.length; i++) {\\n      var converter = toC[argTypes[i]];\\n\\n      if (converter) {\\n        if (stack === 0) stack = stackSave();\\n        cArgs[i] = converter(args[i]);\\n      } else {\\n        cArgs[i] = args[i];\\n      }\\n    }\\n  }\\n\\n  var ret = func.apply(null, cArgs);\\n  ret = convertReturnValue(ret);\\n  if (stack !== 0) stackRestore(stack);\\n  return ret;\\n}\\n\\nfunction cwrap(ident, returnType, argTypes, opts) {\\n  argTypes = argTypes || [];\\n  var numericArgs = argTypes.every(function (type) {\\n    return type === \\\"number\\\";\\n  });\\n  var numericRet = returnType !== \\\"string\\\";\\n\\n  if (numericRet && numericArgs && !opts) {\\n    return getCFunc(ident);\\n  }\\n\\n  return function () {\\n    return ccall(ident, returnType, argTypes, arguments, opts);\\n  };\\n}\\n\\nvar ALLOC_NONE = 3;\\n\\nfunction allocate(slab, types, allocator, ptr) {\\n  var zeroinit, size;\\n\\n  if (typeof slab === \\\"number\\\") {\\n    zeroinit = true;\\n    size = slab;\\n  } else {\\n    zeroinit = false;\\n    size = slab.length;\\n  }\\n\\n  var singleType = typeof types === \\\"string\\\" ? types : null;\\n  var ret;\\n\\n  if (allocator == ALLOC_NONE) {\\n    ret = ptr;\\n  } else {\\n    ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\\n  }\\n\\n  if (zeroinit) {\\n    var stop;\\n    ptr = ret;\\n    assert((ret & 3) == 0);\\n    stop = ret + (size & ~3);\\n\\n    for (; ptr < stop; ptr += 4) {\\n      HEAP32[ptr >> 2] = 0;\\n    }\\n\\n    stop = ret + size;\\n\\n    while (ptr < stop) {\\n      HEAP8[ptr++ >> 0] = 0;\\n    }\\n\\n    return ret;\\n  }\\n\\n  if (singleType === \\\"i8\\\") {\\n    if (slab.subarray || slab.slice) {\\n      HEAPU8.set(slab, ret);\\n    } else {\\n      HEAPU8.set(new Uint8Array(slab), ret);\\n    }\\n\\n    return ret;\\n  }\\n\\n  var i = 0,\\n      type,\\n      typeSize,\\n      previousType;\\n\\n  while (i < size) {\\n    var curr = slab[i];\\n    type = singleType || types[i];\\n\\n    if (type === 0) {\\n      i++;\\n      continue;\\n    }\\n\\n    if (type == \\\"i64\\\") type = \\\"i32\\\";\\n    setValue(ret + i, curr, type);\\n\\n    if (previousType !== type) {\\n      typeSize = getNativeTypeSize(type);\\n      previousType = type;\\n    }\\n\\n    i += typeSize;\\n  }\\n\\n  return ret;\\n}\\n\\nvar UTF8Decoder = typeof TextDecoder !== \\\"undefined\\\" ? new TextDecoder(\\\"utf8\\\") : undefined;\\n\\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\\n  var endIdx = idx + maxBytesToRead;\\n  var endPtr = idx;\\n\\n  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\\n\\n  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\\n    return UTF8Decoder.decode(heap.subarray(idx, endPtr));\\n  } else {\\n    var str = \\\"\\\";\\n\\n    while (idx < endPtr) {\\n      var u0 = heap[idx++];\\n\\n      if (!(u0 & 128)) {\\n        str += String.fromCharCode(u0);\\n        continue;\\n      }\\n\\n      var u1 = heap[idx++] & 63;\\n\\n      if ((u0 & 224) == 192) {\\n        str += String.fromCharCode((u0 & 31) << 6 | u1);\\n        continue;\\n      }\\n\\n      var u2 = heap[idx++] & 63;\\n\\n      if ((u0 & 240) == 224) {\\n        u0 = (u0 & 15) << 12 | u1 << 6 | u2;\\n      } else {\\n        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\\n      }\\n\\n      if (u0 < 65536) {\\n        str += String.fromCharCode(u0);\\n      } else {\\n        var ch = u0 - 65536;\\n        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\\n      }\\n    }\\n  }\\n\\n  return str;\\n}\\n\\nfunction UTF8ToString(ptr, maxBytesToRead) {\\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \\\"\\\";\\n}\\n\\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\\n  if (!(maxBytesToWrite > 0)) return 0;\\n  var startIdx = outIdx;\\n  var endIdx = outIdx + maxBytesToWrite - 1;\\n\\n  for (var i = 0; i < str.length; ++i) {\\n    var u = str.charCodeAt(i);\\n\\n    if (u >= 55296 && u <= 57343) {\\n      var u1 = str.charCodeAt(++i);\\n      u = 65536 + ((u & 1023) << 10) | u1 & 1023;\\n    }\\n\\n    if (u <= 127) {\\n      if (outIdx >= endIdx) break;\\n      heap[outIdx++] = u;\\n    } else if (u <= 2047) {\\n      if (outIdx + 1 >= endIdx) break;\\n      heap[outIdx++] = 192 | u >> 6;\\n      heap[outIdx++] = 128 | u & 63;\\n    } else if (u <= 65535) {\\n      if (outIdx + 2 >= endIdx) break;\\n      heap[outIdx++] = 224 | u >> 12;\\n      heap[outIdx++] = 128 | u >> 6 & 63;\\n      heap[outIdx++] = 128 | u & 63;\\n    } else {\\n      if (outIdx + 3 >= endIdx) break;\\n      heap[outIdx++] = 240 | u >> 18;\\n      heap[outIdx++] = 128 | u >> 12 & 63;\\n      heap[outIdx++] = 128 | u >> 6 & 63;\\n      heap[outIdx++] = 128 | u & 63;\\n    }\\n  }\\n\\n  heap[outIdx] = 0;\\n  return outIdx - startIdx;\\n}\\n\\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\\n  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\\n}\\n\\nfunction lengthBytesUTF8(str) {\\n  var len = 0;\\n\\n  for (var i = 0; i < str.length; ++i) {\\n    var u = str.charCodeAt(i);\\n    if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\\n    if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;\\n  }\\n\\n  return len;\\n}\\n\\nfunction writeArrayToMemory(array, buffer) {\\n  HEAP8.set(array, buffer);\\n}\\n\\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\\n  for (var i = 0; i < str.length; ++i) {\\n    HEAP8[buffer++ >> 0] = str.charCodeAt(i);\\n  }\\n\\n  if (!dontAddNull) HEAP8[buffer >> 0] = 0;\\n}\\n\\nvar WASM_PAGE_SIZE = 65536;\\n\\nfunction alignUp(x, multiple) {\\n  if (x % multiple > 0) {\\n    x += multiple - x % multiple;\\n  }\\n\\n  return x;\\n}\\n\\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\\n\\nfunction updateGlobalBufferAndViews(buf) {\\n  buffer = buf;\\n  Module[\\\"HEAP8\\\"] = HEAP8 = new Int8Array(buf);\\n  Module[\\\"HEAP16\\\"] = HEAP16 = new Int16Array(buf);\\n  Module[\\\"HEAP32\\\"] = HEAP32 = new Int32Array(buf);\\n  Module[\\\"HEAPU8\\\"] = HEAPU8 = new Uint8Array(buf);\\n  Module[\\\"HEAPU16\\\"] = HEAPU16 = new Uint16Array(buf);\\n  Module[\\\"HEAPU32\\\"] = HEAPU32 = new Uint32Array(buf);\\n  Module[\\\"HEAPF32\\\"] = HEAPF32 = new Float32Array(buf);\\n  Module[\\\"HEAPF64\\\"] = HEAPF64 = new Float64Array(buf);\\n}\\n\\nvar DYNAMIC_BASE = 5275232,\\n    DYNAMICTOP_PTR = 32192;\\nvar INITIAL_INITIAL_MEMORY = Module[\\\"INITIAL_MEMORY\\\"] || 16777216;\\n\\nif (Module[\\\"wasmMemory\\\"]) {\\n  wasmMemory = Module[\\\"wasmMemory\\\"];\\n} else {\\n  wasmMemory = new WebAssembly.Memory({\\n    \\\"initial\\\": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,\\n    \\\"maximum\\\": 2147483648 / WASM_PAGE_SIZE\\n  });\\n}\\n\\nif (wasmMemory) {\\n  buffer = wasmMemory.buffer;\\n}\\n\\nINITIAL_INITIAL_MEMORY = buffer.byteLength;\\nupdateGlobalBufferAndViews(buffer);\\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\\n\\nfunction callRuntimeCallbacks(callbacks) {\\n  while (callbacks.length > 0) {\\n    var callback = callbacks.shift();\\n\\n    if (typeof callback == \\\"function\\\") {\\n      callback(Module);\\n      continue;\\n    }\\n\\n    var func = callback.func;\\n\\n    if (typeof func === \\\"number\\\") {\\n      if (callback.arg === undefined) {\\n        Module[\\\"dynCall_v\\\"](func);\\n      } else {\\n        Module[\\\"dynCall_vi\\\"](func, callback.arg);\\n      }\\n    } else {\\n      func(callback.arg === undefined ? null : callback.arg);\\n    }\\n  }\\n}\\n\\nvar __ATPRERUN__ = [];\\nvar __ATINIT__ = [];\\nvar __ATMAIN__ = [];\\nvar __ATPOSTRUN__ = [];\\nvar runtimeInitialized = false;\\n\\nfunction preRun() {\\n  if (Module[\\\"preRun\\\"]) {\\n    if (typeof Module[\\\"preRun\\\"] == \\\"function\\\") Module[\\\"preRun\\\"] = [Module[\\\"preRun\\\"]];\\n\\n    while (Module[\\\"preRun\\\"].length) {\\n      addOnPreRun(Module[\\\"preRun\\\"].shift());\\n    }\\n  }\\n\\n  callRuntimeCallbacks(__ATPRERUN__);\\n}\\n\\nfunction initRuntime() {\\n  runtimeInitialized = true;\\n  if (!Module[\\\"noFSInit\\\"] && !FS.init.initialized) FS.init();\\n  TTY.init();\\n  callRuntimeCallbacks(__ATINIT__);\\n}\\n\\nfunction preMain() {\\n  FS.ignorePermissions = false;\\n  callRuntimeCallbacks(__ATMAIN__);\\n}\\n\\nfunction postRun() {\\n  if (Module[\\\"postRun\\\"]) {\\n    if (typeof Module[\\\"postRun\\\"] == \\\"function\\\") Module[\\\"postRun\\\"] = [Module[\\\"postRun\\\"]];\\n\\n    while (Module[\\\"postRun\\\"].length) {\\n      addOnPostRun(Module[\\\"postRun\\\"].shift());\\n    }\\n  }\\n\\n  callRuntimeCallbacks(__ATPOSTRUN__);\\n}\\n\\nfunction addOnPreRun(cb) {\\n  __ATPRERUN__.unshift(cb);\\n}\\n\\nfunction addOnPostRun(cb) {\\n  __ATPOSTRUN__.unshift(cb);\\n}\\n\\nvar Math_abs = Math.abs;\\nvar Math_ceil = Math.ceil;\\nvar Math_floor = Math.floor;\\nvar Math_min = Math.min;\\nvar runDependencies = 0;\\nvar runDependencyWatcher = null;\\nvar dependenciesFulfilled = null;\\n\\nfunction getUniqueRunDependency(id) {\\n  return id;\\n}\\n\\nfunction addRunDependency(id) {\\n  runDependencies++;\\n\\n  if (Module[\\\"monitorRunDependencies\\\"]) {\\n    Module[\\\"monitorRunDependencies\\\"](runDependencies);\\n  }\\n}\\n\\nfunction removeRunDependency(id) {\\n  runDependencies--;\\n\\n  if (Module[\\\"monitorRunDependencies\\\"]) {\\n    Module[\\\"monitorRunDependencies\\\"](runDependencies);\\n  }\\n\\n  if (runDependencies == 0) {\\n    if (runDependencyWatcher !== null) {\\n      clearInterval(runDependencyWatcher);\\n      runDependencyWatcher = null;\\n    }\\n\\n    if (dependenciesFulfilled) {\\n      var callback = dependenciesFulfilled;\\n      dependenciesFulfilled = null;\\n      callback();\\n    }\\n  }\\n}\\n\\nModule[\\\"preloadedImages\\\"] = {};\\nModule[\\\"preloadedAudios\\\"] = {};\\n\\nfunction abort(what) {\\n  if (Module[\\\"onAbort\\\"]) {\\n    Module[\\\"onAbort\\\"](what);\\n  }\\n\\n  what += \\\"\\\";\\n  out(what);\\n  err(what);\\n  ABORT = true;\\n  EXITSTATUS = 1;\\n  what = \\\"abort(\\\" + what + \\\"). Build with -s ASSERTIONS=1 for more info.\\\";\\n  throw new WebAssembly.RuntimeError(what);\\n}\\n\\nfunction hasPrefix(str, prefix) {\\n  return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;\\n}\\n\\nvar dataURIPrefix = \\\"data:application/octet-stream;base64,\\\";\\n\\nfunction isDataURI(filename) {\\n  return hasPrefix(filename, dataURIPrefix);\\n}\\n\\nvar fileURIPrefix = \\\"file://\\\";\\n\\nfunction isFileURI(filename) {\\n  return hasPrefix(filename, fileURIPrefix);\\n}\\n\\nvar wasmBinaryFile = \\\"rlottie-wasm.wasm\\\";\\n\\nif (!isDataURI(wasmBinaryFile)) {\\n  wasmBinaryFile = locateFile(wasmBinaryFile);\\n}\\n\\nfunction getBinary() {\\n  try {\\n    if (wasmBinary) {\\n      return new Uint8Array(wasmBinary);\\n    }\\n\\n    if (readBinary) {\\n      return readBinary(wasmBinaryFile);\\n    } else {\\n      throw \\\"both async and sync fetching of the wasm failed\\\";\\n    }\\n  } catch (err) {\\n    abort(err);\\n  }\\n}\\n\\nfunction getBinaryPromise() {\\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === \\\"function\\\" && !isFileURI(wasmBinaryFile)) {\\n    return fetch(wasmBinaryFile, {\\n      credentials: \\\"same-origin\\\"\\n    }).then(function (response) {\\n      if (!response[\\\"ok\\\"]) {\\n        throw \\\"failed to load wasm binary file at '\\\" + wasmBinaryFile + \\\"'\\\";\\n      }\\n\\n      return response[\\\"arrayBuffer\\\"]();\\n    }).catch(function () {\\n      return getBinary();\\n    });\\n  }\\n\\n  return new Promise(function (resolve, reject) {\\n    resolve(getBinary());\\n  });\\n}\\n\\nfunction createWasm() {\\n  var info = {\\n    \\\"a\\\": asmLibraryArg\\n  };\\n\\n  function receiveInstance(instance, module) {\\n    var exports = instance.exports;\\n    Module[\\\"asm\\\"] = exports;\\n    removeRunDependency(\\\"wasm-instantiate\\\");\\n  }\\n\\n  addRunDependency(\\\"wasm-instantiate\\\");\\n\\n  function receiveInstantiatedSource(output) {\\n    receiveInstance(output[\\\"instance\\\"]);\\n  }\\n\\n  function instantiateArrayBuffer(receiver) {\\n    return getBinaryPromise().then(function (binary) {\\n      return WebAssembly.instantiate(binary, info);\\n    }).then(receiver, function (reason) {\\n      err(\\\"failed to asynchronously prepare wasm: \\\" + reason);\\n      abort(reason);\\n    });\\n  }\\n\\n  function instantiateAsync() {\\n    if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \\\"function\\\" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === \\\"function\\\") {\\n      fetch(wasmBinaryFile, {\\n        credentials: \\\"same-origin\\\"\\n      }).then(function (response) {\\n        var result = WebAssembly.instantiateStreaming(response, info);\\n        return result.then(receiveInstantiatedSource, function (reason) {\\n          err(\\\"wasm streaming compile failed: \\\" + reason);\\n          err(\\\"falling back to ArrayBuffer instantiation\\\");\\n          instantiateArrayBuffer(receiveInstantiatedSource);\\n        });\\n      });\\n    } else {\\n      return instantiateArrayBuffer(receiveInstantiatedSource);\\n    }\\n  }\\n\\n  if (Module[\\\"instantiateWasm\\\"]) {\\n    try {\\n      var exports = Module[\\\"instantiateWasm\\\"](info, receiveInstance);\\n      return exports;\\n    } catch (e) {\\n      err(\\\"Module.instantiateWasm callback failed with error: \\\" + e);\\n      return false;\\n    }\\n  }\\n\\n  instantiateAsync();\\n  return {};\\n}\\n\\nvar tempDouble;\\nvar tempI64;\\n\\n__ATINIT__.push({\\n  func: function () {\\n    ___wasm_call_ctors();\\n  }\\n});\\n\\nfunction demangle(func) {\\n  return func;\\n}\\n\\nfunction demangleAll(text) {\\n  var regex = /\\\\b_Z[\\\\w\\\\d_]+/g;\\n  return text.replace(regex, function (x) {\\n    var y = demangle(x);\\n    return x === y ? x : y + \\\" [\\\" + x + \\\"]\\\";\\n  });\\n}\\n\\nfunction jsStackTrace() {\\n  var err = new Error();\\n\\n  if (!err.stack) {\\n    try {\\n      throw new Error();\\n    } catch (e) {\\n      err = e;\\n    }\\n\\n    if (!err.stack) {\\n      return \\\"(no stack trace available)\\\";\\n    }\\n  }\\n\\n  return err.stack.toString();\\n}\\n\\nfunction stackTrace() {\\n  var js = jsStackTrace();\\n  if (Module[\\\"extraStackTrace\\\"]) js += \\\"\\\\n\\\" + Module[\\\"extraStackTrace\\\"]();\\n  return demangleAll(js);\\n}\\n\\nfunction __ZN7VRegionC1ERK5VRect() {\\n  err(\\\"missing function: _ZN7VRegionC1ERK5VRect\\\");\\n  abort(-1);\\n}\\n\\nfunction __ZN7VRegionD1Ev() {\\n  err(\\\"missing function: _ZN7VRegionD1Ev\\\");\\n  abort(-1);\\n}\\n\\nfunction __ZN7VRegionpLERK5VRect() {\\n  err(\\\"missing function: _ZN7VRegionpLERK5VRect\\\");\\n  abort(-1);\\n}\\n\\nfunction __ZNK7VRegion12boundingRectEv() {\\n  err(\\\"missing function: _ZNK7VRegion12boundingRectEv\\\");\\n  abort(-1);\\n}\\n\\nfunction ___assert_fail(condition, filename, line, func) {\\n  abort(\\\"Assertion failed: \\\" + UTF8ToString(condition) + \\\", at: \\\" + [filename ? UTF8ToString(filename) : \\\"unknown filename\\\", line, func ? UTF8ToString(func) : \\\"unknown function\\\"]);\\n}\\n\\nfunction setErrNo(value) {\\n  HEAP32[___errno_location() >> 2] = value;\\n  return value;\\n}\\n\\nfunction ___map_file(pathname, size) {\\n  setErrNo(63);\\n  return -1;\\n}\\n\\nvar PATH = {\\n  splitPath: function (filename) {\\n    var splitPathRe = /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;\\n    return splitPathRe.exec(filename).slice(1);\\n  },\\n  normalizeArray: function (parts, allowAboveRoot) {\\n    var up = 0;\\n\\n    for (var i = parts.length - 1; i >= 0; i--) {\\n      var last = parts[i];\\n\\n      if (last === \\\".\\\") {\\n        parts.splice(i, 1);\\n      } else if (last === \\\"..\\\") {\\n        parts.splice(i, 1);\\n        up++;\\n      } else if (up) {\\n        parts.splice(i, 1);\\n        up--;\\n      }\\n    }\\n\\n    if (allowAboveRoot) {\\n      for (; up; up--) {\\n        parts.unshift(\\\"..\\\");\\n      }\\n    }\\n\\n    return parts;\\n  },\\n  normalize: function (path) {\\n    var isAbsolute = path.charAt(0) === \\\"/\\\",\\n        trailingSlash = path.substr(-1) === \\\"/\\\";\\n    path = PATH.normalizeArray(path.split(\\\"/\\\").filter(function (p) {\\n      return !!p;\\n    }), !isAbsolute).join(\\\"/\\\");\\n\\n    if (!path && !isAbsolute) {\\n      path = \\\".\\\";\\n    }\\n\\n    if (path && trailingSlash) {\\n      path += \\\"/\\\";\\n    }\\n\\n    return (isAbsolute ? \\\"/\\\" : \\\"\\\") + path;\\n  },\\n  dirname: function (path) {\\n    var result = PATH.splitPath(path),\\n        root = result[0],\\n        dir = result[1];\\n\\n    if (!root && !dir) {\\n      return \\\".\\\";\\n    }\\n\\n    if (dir) {\\n      dir = dir.substr(0, dir.length - 1);\\n    }\\n\\n    return root + dir;\\n  },\\n  basename: function (path) {\\n    if (path === \\\"/\\\") return \\\"/\\\";\\n    var lastSlash = path.lastIndexOf(\\\"/\\\");\\n    if (lastSlash === -1) return path;\\n    return path.substr(lastSlash + 1);\\n  },\\n  extname: function (path) {\\n    return PATH.splitPath(path)[3];\\n  },\\n  join: function () {\\n    var paths = Array.prototype.slice.call(arguments, 0);\\n    return PATH.normalize(paths.join(\\\"/\\\"));\\n  },\\n  join2: function (l, r) {\\n    return PATH.normalize(l + \\\"/\\\" + r);\\n  }\\n};\\nvar PATH_FS = {\\n  resolve: function () {\\n    var resolvedPath = \\\"\\\",\\n        resolvedAbsolute = false;\\n\\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n      var path = i >= 0 ? arguments[i] : FS.cwd();\\n\\n      if (typeof path !== \\\"string\\\") {\\n        throw new TypeError(\\\"Arguments to path.resolve must be strings\\\");\\n      } else if (!path) {\\n        return \\\"\\\";\\n      }\\n\\n      resolvedPath = path + \\\"/\\\" + resolvedPath;\\n      resolvedAbsolute = path.charAt(0) === \\\"/\\\";\\n    }\\n\\n    resolvedPath = PATH.normalizeArray(resolvedPath.split(\\\"/\\\").filter(function (p) {\\n      return !!p;\\n    }), !resolvedAbsolute).join(\\\"/\\\");\\n    return (resolvedAbsolute ? \\\"/\\\" : \\\"\\\") + resolvedPath || \\\".\\\";\\n  },\\n  relative: function (from, to) {\\n    from = PATH_FS.resolve(from).substr(1);\\n    to = PATH_FS.resolve(to).substr(1);\\n\\n    function trim(arr) {\\n      var start = 0;\\n\\n      for (; start < arr.length; start++) {\\n        if (arr[start] !== \\\"\\\") break;\\n      }\\n\\n      var end = arr.length - 1;\\n\\n      for (; end >= 0; end--) {\\n        if (arr[end] !== \\\"\\\") break;\\n      }\\n\\n      if (start > end) return [];\\n      return arr.slice(start, end - start + 1);\\n    }\\n\\n    var fromParts = trim(from.split(\\\"/\\\"));\\n    var toParts = trim(to.split(\\\"/\\\"));\\n    var length = Math.min(fromParts.length, toParts.length);\\n    var samePartsLength = length;\\n\\n    for (var i = 0; i < length; i++) {\\n      if (fromParts[i] !== toParts[i]) {\\n        samePartsLength = i;\\n        break;\\n      }\\n    }\\n\\n    var outputParts = [];\\n\\n    for (var i = samePartsLength; i < fromParts.length; i++) {\\n      outputParts.push(\\\"..\\\");\\n    }\\n\\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n    return outputParts.join(\\\"/\\\");\\n  }\\n};\\nvar TTY = {\\n  ttys: [],\\n  init: function () {},\\n  shutdown: function () {},\\n  register: function (dev, ops) {\\n    TTY.ttys[dev] = {\\n      input: [],\\n      output: [],\\n      ops: ops\\n    };\\n    FS.registerDevice(dev, TTY.stream_ops);\\n  },\\n  stream_ops: {\\n    open: function (stream) {\\n      var tty = TTY.ttys[stream.node.rdev];\\n\\n      if (!tty) {\\n        throw new FS.ErrnoError(43);\\n      }\\n\\n      stream.tty = tty;\\n      stream.seekable = false;\\n    },\\n    close: function (stream) {\\n      stream.tty.ops.flush(stream.tty);\\n    },\\n    flush: function (stream) {\\n      stream.tty.ops.flush(stream.tty);\\n    },\\n    read: function (stream, buffer, offset, length, pos) {\\n      if (!stream.tty || !stream.tty.ops.get_char) {\\n        throw new FS.ErrnoError(60);\\n      }\\n\\n      var bytesRead = 0;\\n\\n      for (var i = 0; i < length; i++) {\\n        var result;\\n\\n        try {\\n          result = stream.tty.ops.get_char(stream.tty);\\n        } catch (e) {\\n          throw new FS.ErrnoError(29);\\n        }\\n\\n        if (result === undefined && bytesRead === 0) {\\n          throw new FS.ErrnoError(6);\\n        }\\n\\n        if (result === null || result === undefined) break;\\n        bytesRead++;\\n        buffer[offset + i] = result;\\n      }\\n\\n      if (bytesRead) {\\n        stream.node.timestamp = Date.now();\\n      }\\n\\n      return bytesRead;\\n    },\\n    write: function (stream, buffer, offset, length, pos) {\\n      if (!stream.tty || !stream.tty.ops.put_char) {\\n        throw new FS.ErrnoError(60);\\n      }\\n\\n      try {\\n        for (var i = 0; i < length; i++) {\\n          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\\n        }\\n      } catch (e) {\\n        throw new FS.ErrnoError(29);\\n      }\\n\\n      if (length) {\\n        stream.node.timestamp = Date.now();\\n      }\\n\\n      return i;\\n    }\\n  },\\n  default_tty_ops: {\\n    get_char: function (tty) {\\n      if (!tty.input.length) {\\n        var result = null;\\n\\n        if (ENVIRONMENT_IS_NODE) {\\n          var BUFSIZE = 256;\\n          var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);\\n          var bytesRead = 0;\\n\\n          try {\\n            bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);\\n          } catch (e) {\\n            if (e.toString().indexOf(\\\"EOF\\\") != -1) bytesRead = 0;else throw e;\\n          }\\n\\n          if (bytesRead > 0) {\\n            result = buf.slice(0, bytesRead).toString(\\\"utf-8\\\");\\n          } else {\\n            result = null;\\n          }\\n        } else if (typeof window != \\\"undefined\\\" && typeof window.prompt == \\\"function\\\") {\\n          result = window.prompt(\\\"Input: \\\");\\n\\n          if (result !== null) {\\n            result += \\\"\\\\n\\\";\\n          }\\n        } else if (typeof readline == \\\"function\\\") {\\n          result = readline();\\n\\n          if (result !== null) {\\n            result += \\\"\\\\n\\\";\\n          }\\n        }\\n\\n        if (!result) {\\n          return null;\\n        }\\n\\n        tty.input = intArrayFromString(result, true);\\n      }\\n\\n      return tty.input.shift();\\n    },\\n    put_char: function (tty, val) {\\n      if (val === null || val === 10) {\\n        out(UTF8ArrayToString(tty.output, 0));\\n        tty.output = [];\\n      } else {\\n        if (val != 0) tty.output.push(val);\\n      }\\n    },\\n    flush: function (tty) {\\n      if (tty.output && tty.output.length > 0) {\\n        out(UTF8ArrayToString(tty.output, 0));\\n        tty.output = [];\\n      }\\n    }\\n  },\\n  default_tty1_ops: {\\n    put_char: function (tty, val) {\\n      if (val === null || val === 10) {\\n        err(UTF8ArrayToString(tty.output, 0));\\n        tty.output = [];\\n      } else {\\n        if (val != 0) tty.output.push(val);\\n      }\\n    },\\n    flush: function (tty) {\\n      if (tty.output && tty.output.length > 0) {\\n        err(UTF8ArrayToString(tty.output, 0));\\n        tty.output = [];\\n      }\\n    }\\n  }\\n};\\nvar MEMFS = {\\n  ops_table: null,\\n  mount: function (mount) {\\n    return MEMFS.createNode(null, \\\"/\\\", 16384 | 511, 0);\\n  },\\n  createNode: function (parent, name, mode, dev) {\\n    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    if (!MEMFS.ops_table) {\\n      MEMFS.ops_table = {\\n        dir: {\\n          node: {\\n            getattr: MEMFS.node_ops.getattr,\\n            setattr: MEMFS.node_ops.setattr,\\n            lookup: MEMFS.node_ops.lookup,\\n            mknod: MEMFS.node_ops.mknod,\\n            rename: MEMFS.node_ops.rename,\\n            unlink: MEMFS.node_ops.unlink,\\n            rmdir: MEMFS.node_ops.rmdir,\\n            readdir: MEMFS.node_ops.readdir,\\n            symlink: MEMFS.node_ops.symlink\\n          },\\n          stream: {\\n            llseek: MEMFS.stream_ops.llseek\\n          }\\n        },\\n        file: {\\n          node: {\\n            getattr: MEMFS.node_ops.getattr,\\n            setattr: MEMFS.node_ops.setattr\\n          },\\n          stream: {\\n            llseek: MEMFS.stream_ops.llseek,\\n            read: MEMFS.stream_ops.read,\\n            write: MEMFS.stream_ops.write,\\n            allocate: MEMFS.stream_ops.allocate,\\n            mmap: MEMFS.stream_ops.mmap,\\n            msync: MEMFS.stream_ops.msync\\n          }\\n        },\\n        link: {\\n          node: {\\n            getattr: MEMFS.node_ops.getattr,\\n            setattr: MEMFS.node_ops.setattr,\\n            readlink: MEMFS.node_ops.readlink\\n          },\\n          stream: {}\\n        },\\n        chrdev: {\\n          node: {\\n            getattr: MEMFS.node_ops.getattr,\\n            setattr: MEMFS.node_ops.setattr\\n          },\\n          stream: FS.chrdev_stream_ops\\n        }\\n      };\\n    }\\n\\n    var node = FS.createNode(parent, name, mode, dev);\\n\\n    if (FS.isDir(node.mode)) {\\n      node.node_ops = MEMFS.ops_table.dir.node;\\n      node.stream_ops = MEMFS.ops_table.dir.stream;\\n      node.contents = {};\\n    } else if (FS.isFile(node.mode)) {\\n      node.node_ops = MEMFS.ops_table.file.node;\\n      node.stream_ops = MEMFS.ops_table.file.stream;\\n      node.usedBytes = 0;\\n      node.contents = null;\\n    } else if (FS.isLink(node.mode)) {\\n      node.node_ops = MEMFS.ops_table.link.node;\\n      node.stream_ops = MEMFS.ops_table.link.stream;\\n    } else if (FS.isChrdev(node.mode)) {\\n      node.node_ops = MEMFS.ops_table.chrdev.node;\\n      node.stream_ops = MEMFS.ops_table.chrdev.stream;\\n    }\\n\\n    node.timestamp = Date.now();\\n\\n    if (parent) {\\n      parent.contents[name] = node;\\n    }\\n\\n    return node;\\n  },\\n  getFileDataAsRegularArray: function (node) {\\n    if (node.contents && node.contents.subarray) {\\n      var arr = [];\\n\\n      for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\\n\\n      return arr;\\n    }\\n\\n    return node.contents;\\n  },\\n  getFileDataAsTypedArray: function (node) {\\n    if (!node.contents) return new Uint8Array(0);\\n    if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\\n    return new Uint8Array(node.contents);\\n  },\\n  expandFileStorage: function (node, newCapacity) {\\n    var prevCapacity = node.contents ? node.contents.length : 0;\\n    if (prevCapacity >= newCapacity) return;\\n    var CAPACITY_DOUBLING_MAX = 1024 * 1024;\\n    newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\\n    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\\n    var oldContents = node.contents;\\n    node.contents = new Uint8Array(newCapacity);\\n    if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\\n    return;\\n  },\\n  resizeFileStorage: function (node, newSize) {\\n    if (node.usedBytes == newSize) return;\\n\\n    if (newSize == 0) {\\n      node.contents = null;\\n      node.usedBytes = 0;\\n      return;\\n    }\\n\\n    if (!node.contents || node.contents.subarray) {\\n      var oldContents = node.contents;\\n      node.contents = new Uint8Array(newSize);\\n\\n      if (oldContents) {\\n        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\\n      }\\n\\n      node.usedBytes = newSize;\\n      return;\\n    }\\n\\n    if (!node.contents) node.contents = [];\\n    if (node.contents.length > newSize) node.contents.length = newSize;else while (node.contents.length < newSize) node.contents.push(0);\\n    node.usedBytes = newSize;\\n  },\\n  node_ops: {\\n    getattr: function (node) {\\n      var attr = {};\\n      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\\n      attr.ino = node.id;\\n      attr.mode = node.mode;\\n      attr.nlink = 1;\\n      attr.uid = 0;\\n      attr.gid = 0;\\n      attr.rdev = node.rdev;\\n\\n      if (FS.isDir(node.mode)) {\\n        attr.size = 4096;\\n      } else if (FS.isFile(node.mode)) {\\n        attr.size = node.usedBytes;\\n      } else if (FS.isLink(node.mode)) {\\n        attr.size = node.link.length;\\n      } else {\\n        attr.size = 0;\\n      }\\n\\n      attr.atime = new Date(node.timestamp);\\n      attr.mtime = new Date(node.timestamp);\\n      attr.ctime = new Date(node.timestamp);\\n      attr.blksize = 4096;\\n      attr.blocks = Math.ceil(attr.size / attr.blksize);\\n      return attr;\\n    },\\n    setattr: function (node, attr) {\\n      if (attr.mode !== undefined) {\\n        node.mode = attr.mode;\\n      }\\n\\n      if (attr.timestamp !== undefined) {\\n        node.timestamp = attr.timestamp;\\n      }\\n\\n      if (attr.size !== undefined) {\\n        MEMFS.resizeFileStorage(node, attr.size);\\n      }\\n    },\\n    lookup: function (parent, name) {\\n      throw FS.genericErrors[44];\\n    },\\n    mknod: function (parent, name, mode, dev) {\\n      return MEMFS.createNode(parent, name, mode, dev);\\n    },\\n    rename: function (old_node, new_dir, new_name) {\\n      if (FS.isDir(old_node.mode)) {\\n        var new_node;\\n\\n        try {\\n          new_node = FS.lookupNode(new_dir, new_name);\\n        } catch (e) {}\\n\\n        if (new_node) {\\n          for (var i in new_node.contents) {\\n            throw new FS.ErrnoError(55);\\n          }\\n        }\\n      }\\n\\n      delete old_node.parent.contents[old_node.name];\\n      old_node.name = new_name;\\n      new_dir.contents[new_name] = old_node;\\n      old_node.parent = new_dir;\\n    },\\n    unlink: function (parent, name) {\\n      delete parent.contents[name];\\n    },\\n    rmdir: function (parent, name) {\\n      var node = FS.lookupNode(parent, name);\\n\\n      for (var i in node.contents) {\\n        throw new FS.ErrnoError(55);\\n      }\\n\\n      delete parent.contents[name];\\n    },\\n    readdir: function (node) {\\n      var entries = [\\\".\\\", \\\"..\\\"];\\n\\n      for (var key in node.contents) {\\n        if (!node.contents.hasOwnProperty(key)) {\\n          continue;\\n        }\\n\\n        entries.push(key);\\n      }\\n\\n      return entries;\\n    },\\n    symlink: function (parent, newname, oldpath) {\\n      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\\n      node.link = oldpath;\\n      return node;\\n    },\\n    readlink: function (node) {\\n      if (!FS.isLink(node.mode)) {\\n        throw new FS.ErrnoError(28);\\n      }\\n\\n      return node.link;\\n    }\\n  },\\n  stream_ops: {\\n    read: function (stream, buffer, offset, length, position) {\\n      var contents = stream.node.contents;\\n      if (position >= stream.node.usedBytes) return 0;\\n      var size = Math.min(stream.node.usedBytes - position, length);\\n\\n      if (size > 8 && contents.subarray) {\\n        buffer.set(contents.subarray(position, position + size), offset);\\n      } else {\\n        for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\\n      }\\n\\n      return size;\\n    },\\n    write: function (stream, buffer, offset, length, position, canOwn) {\\n      if (buffer.buffer === HEAP8.buffer) {\\n        canOwn = false;\\n      }\\n\\n      if (!length) return 0;\\n      var node = stream.node;\\n      node.timestamp = Date.now();\\n\\n      if (buffer.subarray && (!node.contents || node.contents.subarray)) {\\n        if (canOwn) {\\n          node.contents = buffer.subarray(offset, offset + length);\\n          node.usedBytes = length;\\n          return length;\\n        } else if (node.usedBytes === 0 && position === 0) {\\n          node.contents = buffer.slice(offset, offset + length);\\n          node.usedBytes = length;\\n          return length;\\n        } else if (position + length <= node.usedBytes) {\\n          node.contents.set(buffer.subarray(offset, offset + length), position);\\n          return length;\\n        }\\n      }\\n\\n      MEMFS.expandFileStorage(node, position + length);\\n      if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);else {\\n        for (var i = 0; i < length; i++) {\\n          node.contents[position + i] = buffer[offset + i];\\n        }\\n      }\\n      node.usedBytes = Math.max(node.usedBytes, position + length);\\n      return length;\\n    },\\n    llseek: function (stream, offset, whence) {\\n      var position = offset;\\n\\n      if (whence === 1) {\\n        position += stream.position;\\n      } else if (whence === 2) {\\n        if (FS.isFile(stream.node.mode)) {\\n          position += stream.node.usedBytes;\\n        }\\n      }\\n\\n      if (position < 0) {\\n        throw new FS.ErrnoError(28);\\n      }\\n\\n      return position;\\n    },\\n    allocate: function (stream, offset, length) {\\n      MEMFS.expandFileStorage(stream.node, offset + length);\\n      stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\\n    },\\n    mmap: function (stream, buffer, offset, length, position, prot, flags) {\\n      if (!FS.isFile(stream.node.mode)) {\\n        throw new FS.ErrnoError(43);\\n      }\\n\\n      var ptr;\\n      var allocated;\\n      var contents = stream.node.contents;\\n\\n      if (!(flags & 2) && contents.buffer === buffer.buffer) {\\n        allocated = false;\\n        ptr = contents.byteOffset;\\n      } else {\\n        if (position > 0 || position + length < contents.length) {\\n          if (contents.subarray) {\\n            contents = contents.subarray(position, position + length);\\n          } else {\\n            contents = Array.prototype.slice.call(contents, position, position + length);\\n          }\\n        }\\n\\n        allocated = true;\\n        var fromHeap = buffer.buffer == HEAP8.buffer;\\n        ptr = _malloc(length);\\n\\n        if (!ptr) {\\n          throw new FS.ErrnoError(48);\\n        }\\n\\n        (fromHeap ? HEAP8 : buffer).set(contents, ptr);\\n      }\\n\\n      return {\\n        ptr: ptr,\\n        allocated: allocated\\n      };\\n    },\\n    msync: function (stream, buffer, offset, length, mmapFlags) {\\n      if (!FS.isFile(stream.node.mode)) {\\n        throw new FS.ErrnoError(43);\\n      }\\n\\n      if (mmapFlags & 2) {\\n        return 0;\\n      }\\n\\n      var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\\n      return 0;\\n    }\\n  }\\n};\\nvar FS = {\\n  root: null,\\n  mounts: [],\\n  devices: {},\\n  streams: [],\\n  nextInode: 1,\\n  nameTable: null,\\n  currentPath: \\\"/\\\",\\n  initialized: false,\\n  ignorePermissions: true,\\n  trackingDelegate: {},\\n  tracking: {\\n    openFlags: {\\n      READ: 1,\\n      WRITE: 2\\n    }\\n  },\\n  ErrnoError: null,\\n  genericErrors: {},\\n  filesystems: null,\\n  syncFSRequests: 0,\\n  handleFSError: function (e) {\\n    if (!(e instanceof FS.ErrnoError)) throw e + \\\" : \\\" + stackTrace();\\n    return setErrNo(e.errno);\\n  },\\n  lookupPath: function (path, opts) {\\n    path = PATH_FS.resolve(FS.cwd(), path);\\n    opts = opts || {};\\n    if (!path) return {\\n      path: \\\"\\\",\\n      node: null\\n    };\\n    var defaults = {\\n      follow_mount: true,\\n      recurse_count: 0\\n    };\\n\\n    for (var key in defaults) {\\n      if (opts[key] === undefined) {\\n        opts[key] = defaults[key];\\n      }\\n    }\\n\\n    if (opts.recurse_count > 8) {\\n      throw new FS.ErrnoError(32);\\n    }\\n\\n    var parts = PATH.normalizeArray(path.split(\\\"/\\\").filter(function (p) {\\n      return !!p;\\n    }), false);\\n    var current = FS.root;\\n    var current_path = \\\"/\\\";\\n\\n    for (var i = 0; i < parts.length; i++) {\\n      var islast = i === parts.length - 1;\\n\\n      if (islast && opts.parent) {\\n        break;\\n      }\\n\\n      current = FS.lookupNode(current, parts[i]);\\n      current_path = PATH.join2(current_path, parts[i]);\\n\\n      if (FS.isMountpoint(current)) {\\n        if (!islast || islast && opts.follow_mount) {\\n          current = current.mounted.root;\\n        }\\n      }\\n\\n      if (!islast || opts.follow) {\\n        var count = 0;\\n\\n        while (FS.isLink(current.mode)) {\\n          var link = FS.readlink(current_path);\\n          current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\\n          var lookup = FS.lookupPath(current_path, {\\n            recurse_count: opts.recurse_count\\n          });\\n          current = lookup.node;\\n\\n          if (count++ > 40) {\\n            throw new FS.ErrnoError(32);\\n          }\\n        }\\n      }\\n    }\\n\\n    return {\\n      path: current_path,\\n      node: current\\n    };\\n  },\\n  getPath: function (node) {\\n    var path;\\n\\n    while (true) {\\n      if (FS.isRoot(node)) {\\n        var mount = node.mount.mountpoint;\\n        if (!path) return mount;\\n        return mount[mount.length - 1] !== \\\"/\\\" ? mount + \\\"/\\\" + path : mount + path;\\n      }\\n\\n      path = path ? node.name + \\\"/\\\" + path : node.name;\\n      node = node.parent;\\n    }\\n  },\\n  hashName: function (parentid, name) {\\n    var hash = 0;\\n\\n    for (var i = 0; i < name.length; i++) {\\n      hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\\n    }\\n\\n    return (parentid + hash >>> 0) % FS.nameTable.length;\\n  },\\n  hashAddNode: function (node) {\\n    var hash = FS.hashName(node.parent.id, node.name);\\n    node.name_next = FS.nameTable[hash];\\n    FS.nameTable[hash] = node;\\n  },\\n  hashRemoveNode: function (node) {\\n    var hash = FS.hashName(node.parent.id, node.name);\\n\\n    if (FS.nameTable[hash] === node) {\\n      FS.nameTable[hash] = node.name_next;\\n    } else {\\n      var current = FS.nameTable[hash];\\n\\n      while (current) {\\n        if (current.name_next === node) {\\n          current.name_next = node.name_next;\\n          break;\\n        }\\n\\n        current = current.name_next;\\n      }\\n    }\\n  },\\n  lookupNode: function (parent, name) {\\n    var errCode = FS.mayLookup(parent);\\n\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode, parent);\\n    }\\n\\n    var hash = FS.hashName(parent.id, name);\\n\\n    for (var node = FS.nameTable[hash]; node; node = node.name_next) {\\n      var nodeName = node.name;\\n\\n      if (node.parent.id === parent.id && nodeName === name) {\\n        return node;\\n      }\\n    }\\n\\n    return FS.lookup(parent, name);\\n  },\\n  createNode: function (parent, name, mode, rdev) {\\n    var node = new FS.FSNode(parent, name, mode, rdev);\\n    FS.hashAddNode(node);\\n    return node;\\n  },\\n  destroyNode: function (node) {\\n    FS.hashRemoveNode(node);\\n  },\\n  isRoot: function (node) {\\n    return node === node.parent;\\n  },\\n  isMountpoint: function (node) {\\n    return !!node.mounted;\\n  },\\n  isFile: function (mode) {\\n    return (mode & 61440) === 32768;\\n  },\\n  isDir: function (mode) {\\n    return (mode & 61440) === 16384;\\n  },\\n  isLink: function (mode) {\\n    return (mode & 61440) === 40960;\\n  },\\n  isChrdev: function (mode) {\\n    return (mode & 61440) === 8192;\\n  },\\n  isBlkdev: function (mode) {\\n    return (mode & 61440) === 24576;\\n  },\\n  isFIFO: function (mode) {\\n    return (mode & 61440) === 4096;\\n  },\\n  isSocket: function (mode) {\\n    return (mode & 49152) === 49152;\\n  },\\n  flagModes: {\\n    \\\"r\\\": 0,\\n    \\\"rs\\\": 1052672,\\n    \\\"r+\\\": 2,\\n    \\\"w\\\": 577,\\n    \\\"wx\\\": 705,\\n    \\\"xw\\\": 705,\\n    \\\"w+\\\": 578,\\n    \\\"wx+\\\": 706,\\n    \\\"xw+\\\": 706,\\n    \\\"a\\\": 1089,\\n    \\\"ax\\\": 1217,\\n    \\\"xa\\\": 1217,\\n    \\\"a+\\\": 1090,\\n    \\\"ax+\\\": 1218,\\n    \\\"xa+\\\": 1218\\n  },\\n  modeStringToFlags: function (str) {\\n    var flags = FS.flagModes[str];\\n\\n    if (typeof flags === \\\"undefined\\\") {\\n      throw new Error(\\\"Unknown file open mode: \\\" + str);\\n    }\\n\\n    return flags;\\n  },\\n  flagsToPermissionString: function (flag) {\\n    var perms = [\\\"r\\\", \\\"w\\\", \\\"rw\\\"][flag & 3];\\n\\n    if (flag & 512) {\\n      perms += \\\"w\\\";\\n    }\\n\\n    return perms;\\n  },\\n  nodePermissions: function (node, perms) {\\n    if (FS.ignorePermissions) {\\n      return 0;\\n    }\\n\\n    if (perms.indexOf(\\\"r\\\") !== -1 && !(node.mode & 292)) {\\n      return 2;\\n    } else if (perms.indexOf(\\\"w\\\") !== -1 && !(node.mode & 146)) {\\n      return 2;\\n    } else if (perms.indexOf(\\\"x\\\") !== -1 && !(node.mode & 73)) {\\n      return 2;\\n    }\\n\\n    return 0;\\n  },\\n  mayLookup: function (dir) {\\n    var errCode = FS.nodePermissions(dir, \\\"x\\\");\\n    if (errCode) return errCode;\\n    if (!dir.node_ops.lookup) return 2;\\n    return 0;\\n  },\\n  mayCreate: function (dir, name) {\\n    try {\\n      var node = FS.lookupNode(dir, name);\\n      return 20;\\n    } catch (e) {}\\n\\n    return FS.nodePermissions(dir, \\\"wx\\\");\\n  },\\n  mayDelete: function (dir, name, isdir) {\\n    var node;\\n\\n    try {\\n      node = FS.lookupNode(dir, name);\\n    } catch (e) {\\n      return e.errno;\\n    }\\n\\n    var errCode = FS.nodePermissions(dir, \\\"wx\\\");\\n\\n    if (errCode) {\\n      return errCode;\\n    }\\n\\n    if (isdir) {\\n      if (!FS.isDir(node.mode)) {\\n        return 54;\\n      }\\n\\n      if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\\n        return 10;\\n      }\\n    } else {\\n      if (FS.isDir(node.mode)) {\\n        return 31;\\n      }\\n    }\\n\\n    return 0;\\n  },\\n  mayOpen: function (node, flags) {\\n    if (!node) {\\n      return 44;\\n    }\\n\\n    if (FS.isLink(node.mode)) {\\n      return 32;\\n    } else if (FS.isDir(node.mode)) {\\n      if (FS.flagsToPermissionString(flags) !== \\\"r\\\" || flags & 512) {\\n        return 31;\\n      }\\n    }\\n\\n    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\\n  },\\n  MAX_OPEN_FDS: 4096,\\n  nextfd: function (fd_start, fd_end) {\\n    fd_start = fd_start || 0;\\n    fd_end = fd_end || FS.MAX_OPEN_FDS;\\n\\n    for (var fd = fd_start; fd <= fd_end; fd++) {\\n      if (!FS.streams[fd]) {\\n        return fd;\\n      }\\n    }\\n\\n    throw new FS.ErrnoError(33);\\n  },\\n  getStream: function (fd) {\\n    return FS.streams[fd];\\n  },\\n  createStream: function (stream, fd_start, fd_end) {\\n    if (!FS.FSStream) {\\n      FS.FSStream = function () {};\\n\\n      FS.FSStream.prototype = {\\n        object: {\\n          get: function () {\\n            return this.node;\\n          },\\n          set: function (val) {\\n            this.node = val;\\n          }\\n        },\\n        isRead: {\\n          get: function () {\\n            return (this.flags & 2097155) !== 1;\\n          }\\n        },\\n        isWrite: {\\n          get: function () {\\n            return (this.flags & 2097155) !== 0;\\n          }\\n        },\\n        isAppend: {\\n          get: function () {\\n            return this.flags & 1024;\\n          }\\n        }\\n      };\\n    }\\n\\n    var newStream = new FS.FSStream();\\n\\n    for (var p in stream) {\\n      newStream[p] = stream[p];\\n    }\\n\\n    stream = newStream;\\n    var fd = FS.nextfd(fd_start, fd_end);\\n    stream.fd = fd;\\n    FS.streams[fd] = stream;\\n    return stream;\\n  },\\n  closeStream: function (fd) {\\n    FS.streams[fd] = null;\\n  },\\n  chrdev_stream_ops: {\\n    open: function (stream) {\\n      var device = FS.getDevice(stream.node.rdev);\\n      stream.stream_ops = device.stream_ops;\\n\\n      if (stream.stream_ops.open) {\\n        stream.stream_ops.open(stream);\\n      }\\n    },\\n    llseek: function () {\\n      throw new FS.ErrnoError(70);\\n    }\\n  },\\n  major: function (dev) {\\n    return dev >> 8;\\n  },\\n  minor: function (dev) {\\n    return dev & 255;\\n  },\\n  makedev: function (ma, mi) {\\n    return ma << 8 | mi;\\n  },\\n  registerDevice: function (dev, ops) {\\n    FS.devices[dev] = {\\n      stream_ops: ops\\n    };\\n  },\\n  getDevice: function (dev) {\\n    return FS.devices[dev];\\n  },\\n  getMounts: function (mount) {\\n    var mounts = [];\\n    var check = [mount];\\n\\n    while (check.length) {\\n      var m = check.pop();\\n      mounts.push(m);\\n      check.push.apply(check, m.mounts);\\n    }\\n\\n    return mounts;\\n  },\\n  syncfs: function (populate, callback) {\\n    if (typeof populate === \\\"function\\\") {\\n      callback = populate;\\n      populate = false;\\n    }\\n\\n    FS.syncFSRequests++;\\n\\n    if (FS.syncFSRequests > 1) {\\n      err(\\\"warning: \\\" + FS.syncFSRequests + \\\" FS.syncfs operations in flight at once, probably just doing extra work\\\");\\n    }\\n\\n    var mounts = FS.getMounts(FS.root.mount);\\n    var completed = 0;\\n\\n    function doCallback(errCode) {\\n      FS.syncFSRequests--;\\n      return callback(errCode);\\n    }\\n\\n    function done(errCode) {\\n      if (errCode) {\\n        if (!done.errored) {\\n          done.errored = true;\\n          return doCallback(errCode);\\n        }\\n\\n        return;\\n      }\\n\\n      if (++completed >= mounts.length) {\\n        doCallback(null);\\n      }\\n    }\\n\\n    mounts.forEach(function (mount) {\\n      if (!mount.type.syncfs) {\\n        return done(null);\\n      }\\n\\n      mount.type.syncfs(mount, populate, done);\\n    });\\n  },\\n  mount: function (type, opts, mountpoint) {\\n    var root = mountpoint === \\\"/\\\";\\n    var pseudo = !mountpoint;\\n    var node;\\n\\n    if (root && FS.root) {\\n      throw new FS.ErrnoError(10);\\n    } else if (!root && !pseudo) {\\n      var lookup = FS.lookupPath(mountpoint, {\\n        follow_mount: false\\n      });\\n      mountpoint = lookup.path;\\n      node = lookup.node;\\n\\n      if (FS.isMountpoint(node)) {\\n        throw new FS.ErrnoError(10);\\n      }\\n\\n      if (!FS.isDir(node.mode)) {\\n        throw new FS.ErrnoError(54);\\n      }\\n    }\\n\\n    var mount = {\\n      type: type,\\n      opts: opts,\\n      mountpoint: mountpoint,\\n      mounts: []\\n    };\\n    var mountRoot = type.mount(mount);\\n    mountRoot.mount = mount;\\n    mount.root = mountRoot;\\n\\n    if (root) {\\n      FS.root = mountRoot;\\n    } else if (node) {\\n      node.mounted = mount;\\n\\n      if (node.mount) {\\n        node.mount.mounts.push(mount);\\n      }\\n    }\\n\\n    return mountRoot;\\n  },\\n  unmount: function (mountpoint) {\\n    var lookup = FS.lookupPath(mountpoint, {\\n      follow_mount: false\\n    });\\n\\n    if (!FS.isMountpoint(lookup.node)) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    var node = lookup.node;\\n    var mount = node.mounted;\\n    var mounts = FS.getMounts(mount);\\n    Object.keys(FS.nameTable).forEach(function (hash) {\\n      var current = FS.nameTable[hash];\\n\\n      while (current) {\\n        var next = current.name_next;\\n\\n        if (mounts.indexOf(current.mount) !== -1) {\\n          FS.destroyNode(current);\\n        }\\n\\n        current = next;\\n      }\\n    });\\n    node.mounted = null;\\n    var idx = node.mount.mounts.indexOf(mount);\\n    node.mount.mounts.splice(idx, 1);\\n  },\\n  lookup: function (parent, name) {\\n    return parent.node_ops.lookup(parent, name);\\n  },\\n  mknod: function (path, mode, dev) {\\n    var lookup = FS.lookupPath(path, {\\n      parent: true\\n    });\\n    var parent = lookup.node;\\n    var name = PATH.basename(path);\\n\\n    if (!name || name === \\\".\\\" || name === \\\"..\\\") {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    var errCode = FS.mayCreate(parent, name);\\n\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n\\n    if (!parent.node_ops.mknod) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    return parent.node_ops.mknod(parent, name, mode, dev);\\n  },\\n  create: function (path, mode) {\\n    mode = mode !== undefined ? mode : 438;\\n    mode &= 4095;\\n    mode |= 32768;\\n    return FS.mknod(path, mode, 0);\\n  },\\n  mkdir: function (path, mode) {\\n    mode = mode !== undefined ? mode : 511;\\n    mode &= 511 | 512;\\n    mode |= 16384;\\n    return FS.mknod(path, mode, 0);\\n  },\\n  mkdirTree: function (path, mode) {\\n    var dirs = path.split(\\\"/\\\");\\n    var d = \\\"\\\";\\n\\n    for (var i = 0; i < dirs.length; ++i) {\\n      if (!dirs[i]) continue;\\n      d += \\\"/\\\" + dirs[i];\\n\\n      try {\\n        FS.mkdir(d, mode);\\n      } catch (e) {\\n        if (e.errno != 20) throw e;\\n      }\\n    }\\n  },\\n  mkdev: function (path, mode, dev) {\\n    if (typeof dev === \\\"undefined\\\") {\\n      dev = mode;\\n      mode = 438;\\n    }\\n\\n    mode |= 8192;\\n    return FS.mknod(path, mode, dev);\\n  },\\n  symlink: function (oldpath, newpath) {\\n    if (!PATH_FS.resolve(oldpath)) {\\n      throw new FS.ErrnoError(44);\\n    }\\n\\n    var lookup = FS.lookupPath(newpath, {\\n      parent: true\\n    });\\n    var parent = lookup.node;\\n\\n    if (!parent) {\\n      throw new FS.ErrnoError(44);\\n    }\\n\\n    var newname = PATH.basename(newpath);\\n    var errCode = FS.mayCreate(parent, newname);\\n\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n\\n    if (!parent.node_ops.symlink) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    return parent.node_ops.symlink(parent, newname, oldpath);\\n  },\\n  rename: function (old_path, new_path) {\\n    var old_dirname = PATH.dirname(old_path);\\n    var new_dirname = PATH.dirname(new_path);\\n    var old_name = PATH.basename(old_path);\\n    var new_name = PATH.basename(new_path);\\n    var lookup, old_dir, new_dir;\\n\\n    try {\\n      lookup = FS.lookupPath(old_path, {\\n        parent: true\\n      });\\n      old_dir = lookup.node;\\n      lookup = FS.lookupPath(new_path, {\\n        parent: true\\n      });\\n      new_dir = lookup.node;\\n    } catch (e) {\\n      throw new FS.ErrnoError(10);\\n    }\\n\\n    if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\\n\\n    if (old_dir.mount !== new_dir.mount) {\\n      throw new FS.ErrnoError(75);\\n    }\\n\\n    var old_node = FS.lookupNode(old_dir, old_name);\\n    var relative = PATH_FS.relative(old_path, new_dirname);\\n\\n    if (relative.charAt(0) !== \\\".\\\") {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    relative = PATH_FS.relative(new_path, old_dirname);\\n\\n    if (relative.charAt(0) !== \\\".\\\") {\\n      throw new FS.ErrnoError(55);\\n    }\\n\\n    var new_node;\\n\\n    try {\\n      new_node = FS.lookupNode(new_dir, new_name);\\n    } catch (e) {}\\n\\n    if (old_node === new_node) {\\n      return;\\n    }\\n\\n    var isdir = FS.isDir(old_node.mode);\\n    var errCode = FS.mayDelete(old_dir, old_name, isdir);\\n\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n\\n    errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\\n\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n\\n    if (!old_dir.node_ops.rename) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\\n      throw new FS.ErrnoError(10);\\n    }\\n\\n    if (new_dir !== old_dir) {\\n      errCode = FS.nodePermissions(old_dir, \\\"w\\\");\\n\\n      if (errCode) {\\n        throw new FS.ErrnoError(errCode);\\n      }\\n    }\\n\\n    try {\\n      if (FS.trackingDelegate[\\\"willMovePath\\\"]) {\\n        FS.trackingDelegate[\\\"willMovePath\\\"](old_path, new_path);\\n      }\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['willMovePath']('\\\" + old_path + \\\"', '\\\" + new_path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n\\n    FS.hashRemoveNode(old_node);\\n\\n    try {\\n      old_dir.node_ops.rename(old_node, new_dir, new_name);\\n    } catch (e) {\\n      throw e;\\n    } finally {\\n      FS.hashAddNode(old_node);\\n    }\\n\\n    try {\\n      if (FS.trackingDelegate[\\\"onMovePath\\\"]) FS.trackingDelegate[\\\"onMovePath\\\"](old_path, new_path);\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onMovePath']('\\\" + old_path + \\\"', '\\\" + new_path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n  },\\n  rmdir: function (path) {\\n    var lookup = FS.lookupPath(path, {\\n      parent: true\\n    });\\n    var parent = lookup.node;\\n    var name = PATH.basename(path);\\n    var node = FS.lookupNode(parent, name);\\n    var errCode = FS.mayDelete(parent, name, true);\\n\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n\\n    if (!parent.node_ops.rmdir) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    if (FS.isMountpoint(node)) {\\n      throw new FS.ErrnoError(10);\\n    }\\n\\n    try {\\n      if (FS.trackingDelegate[\\\"willDeletePath\\\"]) {\\n        FS.trackingDelegate[\\\"willDeletePath\\\"](path);\\n      }\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['willDeletePath']('\\\" + path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n\\n    parent.node_ops.rmdir(parent, name);\\n    FS.destroyNode(node);\\n\\n    try {\\n      if (FS.trackingDelegate[\\\"onDeletePath\\\"]) FS.trackingDelegate[\\\"onDeletePath\\\"](path);\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onDeletePath']('\\\" + path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n  },\\n  readdir: function (path) {\\n    var lookup = FS.lookupPath(path, {\\n      follow: true\\n    });\\n    var node = lookup.node;\\n\\n    if (!node.node_ops.readdir) {\\n      throw new FS.ErrnoError(54);\\n    }\\n\\n    return node.node_ops.readdir(node);\\n  },\\n  unlink: function (path) {\\n    var lookup = FS.lookupPath(path, {\\n      parent: true\\n    });\\n    var parent = lookup.node;\\n    var name = PATH.basename(path);\\n    var node = FS.lookupNode(parent, name);\\n    var errCode = FS.mayDelete(parent, name, false);\\n\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n\\n    if (!parent.node_ops.unlink) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    if (FS.isMountpoint(node)) {\\n      throw new FS.ErrnoError(10);\\n    }\\n\\n    try {\\n      if (FS.trackingDelegate[\\\"willDeletePath\\\"]) {\\n        FS.trackingDelegate[\\\"willDeletePath\\\"](path);\\n      }\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['willDeletePath']('\\\" + path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n\\n    parent.node_ops.unlink(parent, name);\\n    FS.destroyNode(node);\\n\\n    try {\\n      if (FS.trackingDelegate[\\\"onDeletePath\\\"]) FS.trackingDelegate[\\\"onDeletePath\\\"](path);\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onDeletePath']('\\\" + path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n  },\\n  readlink: function (path) {\\n    var lookup = FS.lookupPath(path);\\n    var link = lookup.node;\\n\\n    if (!link) {\\n      throw new FS.ErrnoError(44);\\n    }\\n\\n    if (!link.node_ops.readlink) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\\n  },\\n  stat: function (path, dontFollow) {\\n    var lookup = FS.lookupPath(path, {\\n      follow: !dontFollow\\n    });\\n    var node = lookup.node;\\n\\n    if (!node) {\\n      throw new FS.ErrnoError(44);\\n    }\\n\\n    if (!node.node_ops.getattr) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    return node.node_ops.getattr(node);\\n  },\\n  lstat: function (path) {\\n    return FS.stat(path, true);\\n  },\\n  chmod: function (path, mode, dontFollow) {\\n    var node;\\n\\n    if (typeof path === \\\"string\\\") {\\n      var lookup = FS.lookupPath(path, {\\n        follow: !dontFollow\\n      });\\n      node = lookup.node;\\n    } else {\\n      node = path;\\n    }\\n\\n    if (!node.node_ops.setattr) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    node.node_ops.setattr(node, {\\n      mode: mode & 4095 | node.mode & ~4095,\\n      timestamp: Date.now()\\n    });\\n  },\\n  lchmod: function (path, mode) {\\n    FS.chmod(path, mode, true);\\n  },\\n  fchmod: function (fd, mode) {\\n    var stream = FS.getStream(fd);\\n\\n    if (!stream) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    FS.chmod(stream.node, mode);\\n  },\\n  chown: function (path, uid, gid, dontFollow) {\\n    var node;\\n\\n    if (typeof path === \\\"string\\\") {\\n      var lookup = FS.lookupPath(path, {\\n        follow: !dontFollow\\n      });\\n      node = lookup.node;\\n    } else {\\n      node = path;\\n    }\\n\\n    if (!node.node_ops.setattr) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    node.node_ops.setattr(node, {\\n      timestamp: Date.now()\\n    });\\n  },\\n  lchown: function (path, uid, gid) {\\n    FS.chown(path, uid, gid, true);\\n  },\\n  fchown: function (fd, uid, gid) {\\n    var stream = FS.getStream(fd);\\n\\n    if (!stream) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    FS.chown(stream.node, uid, gid);\\n  },\\n  truncate: function (path, len) {\\n    if (len < 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    var node;\\n\\n    if (typeof path === \\\"string\\\") {\\n      var lookup = FS.lookupPath(path, {\\n        follow: true\\n      });\\n      node = lookup.node;\\n    } else {\\n      node = path;\\n    }\\n\\n    if (!node.node_ops.setattr) {\\n      throw new FS.ErrnoError(63);\\n    }\\n\\n    if (FS.isDir(node.mode)) {\\n      throw new FS.ErrnoError(31);\\n    }\\n\\n    if (!FS.isFile(node.mode)) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    var errCode = FS.nodePermissions(node, \\\"w\\\");\\n\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n\\n    node.node_ops.setattr(node, {\\n      size: len,\\n      timestamp: Date.now()\\n    });\\n  },\\n  ftruncate: function (fd, len) {\\n    var stream = FS.getStream(fd);\\n\\n    if (!stream) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    if ((stream.flags & 2097155) === 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    FS.truncate(stream.node, len);\\n  },\\n  utime: function (path, atime, mtime) {\\n    var lookup = FS.lookupPath(path, {\\n      follow: true\\n    });\\n    var node = lookup.node;\\n    node.node_ops.setattr(node, {\\n      timestamp: Math.max(atime, mtime)\\n    });\\n  },\\n  open: function (path, flags, mode, fd_start, fd_end) {\\n    if (path === \\\"\\\") {\\n      throw new FS.ErrnoError(44);\\n    }\\n\\n    flags = typeof flags === \\\"string\\\" ? FS.modeStringToFlags(flags) : flags;\\n    mode = typeof mode === \\\"undefined\\\" ? 438 : mode;\\n\\n    if (flags & 64) {\\n      mode = mode & 4095 | 32768;\\n    } else {\\n      mode = 0;\\n    }\\n\\n    var node;\\n\\n    if (typeof path === \\\"object\\\") {\\n      node = path;\\n    } else {\\n      path = PATH.normalize(path);\\n\\n      try {\\n        var lookup = FS.lookupPath(path, {\\n          follow: !(flags & 131072)\\n        });\\n        node = lookup.node;\\n      } catch (e) {}\\n    }\\n\\n    var created = false;\\n\\n    if (flags & 64) {\\n      if (node) {\\n        if (flags & 128) {\\n          throw new FS.ErrnoError(20);\\n        }\\n      } else {\\n        node = FS.mknod(path, mode, 0);\\n        created = true;\\n      }\\n    }\\n\\n    if (!node) {\\n      throw new FS.ErrnoError(44);\\n    }\\n\\n    if (FS.isChrdev(node.mode)) {\\n      flags &= ~512;\\n    }\\n\\n    if (flags & 65536 && !FS.isDir(node.mode)) {\\n      throw new FS.ErrnoError(54);\\n    }\\n\\n    if (!created) {\\n      var errCode = FS.mayOpen(node, flags);\\n\\n      if (errCode) {\\n        throw new FS.ErrnoError(errCode);\\n      }\\n    }\\n\\n    if (flags & 512) {\\n      FS.truncate(node, 0);\\n    }\\n\\n    flags &= ~(128 | 512 | 131072);\\n    var stream = FS.createStream({\\n      node: node,\\n      path: FS.getPath(node),\\n      flags: flags,\\n      seekable: true,\\n      position: 0,\\n      stream_ops: node.stream_ops,\\n      ungotten: [],\\n      error: false\\n    }, fd_start, fd_end);\\n\\n    if (stream.stream_ops.open) {\\n      stream.stream_ops.open(stream);\\n    }\\n\\n    if (Module[\\\"logReadFiles\\\"] && !(flags & 1)) {\\n      if (!FS.readFiles) FS.readFiles = {};\\n\\n      if (!(path in FS.readFiles)) {\\n        FS.readFiles[path] = 1;\\n        err(\\\"FS.trackingDelegate error on read file: \\\" + path);\\n      }\\n    }\\n\\n    try {\\n      if (FS.trackingDelegate[\\\"onOpenFile\\\"]) {\\n        var trackingFlags = 0;\\n\\n        if ((flags & 2097155) !== 1) {\\n          trackingFlags |= FS.tracking.openFlags.READ;\\n        }\\n\\n        if ((flags & 2097155) !== 0) {\\n          trackingFlags |= FS.tracking.openFlags.WRITE;\\n        }\\n\\n        FS.trackingDelegate[\\\"onOpenFile\\\"](path, trackingFlags);\\n      }\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onOpenFile']('\\\" + path + \\\"', flags) threw an exception: \\\" + e.message);\\n    }\\n\\n    return stream;\\n  },\\n  close: function (stream) {\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    if (stream.getdents) stream.getdents = null;\\n\\n    try {\\n      if (stream.stream_ops.close) {\\n        stream.stream_ops.close(stream);\\n      }\\n    } catch (e) {\\n      throw e;\\n    } finally {\\n      FS.closeStream(stream.fd);\\n    }\\n\\n    stream.fd = null;\\n  },\\n  isClosed: function (stream) {\\n    return stream.fd === null;\\n  },\\n  llseek: function (stream, offset, whence) {\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    if (!stream.seekable || !stream.stream_ops.llseek) {\\n      throw new FS.ErrnoError(70);\\n    }\\n\\n    if (whence != 0 && whence != 1 && whence != 2) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    stream.position = stream.stream_ops.llseek(stream, offset, whence);\\n    stream.ungotten = [];\\n    return stream.position;\\n  },\\n  read: function (stream, buffer, offset, length, position) {\\n    if (length < 0 || position < 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    if ((stream.flags & 2097155) === 1) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    if (FS.isDir(stream.node.mode)) {\\n      throw new FS.ErrnoError(31);\\n    }\\n\\n    if (!stream.stream_ops.read) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    var seeking = typeof position !== \\\"undefined\\\";\\n\\n    if (!seeking) {\\n      position = stream.position;\\n    } else if (!stream.seekable) {\\n      throw new FS.ErrnoError(70);\\n    }\\n\\n    var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\\n    if (!seeking) stream.position += bytesRead;\\n    return bytesRead;\\n  },\\n  write: function (stream, buffer, offset, length, position, canOwn) {\\n    if (length < 0 || position < 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    if ((stream.flags & 2097155) === 0) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    if (FS.isDir(stream.node.mode)) {\\n      throw new FS.ErrnoError(31);\\n    }\\n\\n    if (!stream.stream_ops.write) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    if (stream.seekable && stream.flags & 1024) {\\n      FS.llseek(stream, 0, 2);\\n    }\\n\\n    var seeking = typeof position !== \\\"undefined\\\";\\n\\n    if (!seeking) {\\n      position = stream.position;\\n    } else if (!stream.seekable) {\\n      throw new FS.ErrnoError(70);\\n    }\\n\\n    var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\\n    if (!seeking) stream.position += bytesWritten;\\n\\n    try {\\n      if (stream.path && FS.trackingDelegate[\\\"onWriteToFile\\\"]) FS.trackingDelegate[\\\"onWriteToFile\\\"](stream.path);\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onWriteToFile']('\\\" + stream.path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n\\n    return bytesWritten;\\n  },\\n  allocate: function (stream, offset, length) {\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    if (offset < 0 || length <= 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n\\n    if ((stream.flags & 2097155) === 0) {\\n      throw new FS.ErrnoError(8);\\n    }\\n\\n    if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\\n      throw new FS.ErrnoError(43);\\n    }\\n\\n    if (!stream.stream_ops.allocate) {\\n      throw new FS.ErrnoError(138);\\n    }\\n\\n    stream.stream_ops.allocate(stream, offset, length);\\n  },\\n  mmap: function (stream, buffer, offset, length, position, prot, flags) {\\n    if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\\n      throw new FS.ErrnoError(2);\\n    }\\n\\n    if ((stream.flags & 2097155) === 1) {\\n      throw new FS.ErrnoError(2);\\n    }\\n\\n    if (!stream.stream_ops.mmap) {\\n      throw new FS.ErrnoError(43);\\n    }\\n\\n    return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);\\n  },\\n  msync: function (stream, buffer, offset, length, mmapFlags) {\\n    if (!stream || !stream.stream_ops.msync) {\\n      return 0;\\n    }\\n\\n    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\\n  },\\n  munmap: function (stream) {\\n    return 0;\\n  },\\n  ioctl: function (stream, cmd, arg) {\\n    if (!stream.stream_ops.ioctl) {\\n      throw new FS.ErrnoError(59);\\n    }\\n\\n    return stream.stream_ops.ioctl(stream, cmd, arg);\\n  },\\n  readFile: function (path, opts) {\\n    opts = opts || {};\\n    opts.flags = opts.flags || \\\"r\\\";\\n    opts.encoding = opts.encoding || \\\"binary\\\";\\n\\n    if (opts.encoding !== \\\"utf8\\\" && opts.encoding !== \\\"binary\\\") {\\n      throw new Error('Invalid encoding type \\\"' + opts.encoding + '\\\"');\\n    }\\n\\n    var ret;\\n    var stream = FS.open(path, opts.flags);\\n    var stat = FS.stat(path);\\n    var length = stat.size;\\n    var buf = new Uint8Array(length);\\n    FS.read(stream, buf, 0, length, 0);\\n\\n    if (opts.encoding === \\\"utf8\\\") {\\n      ret = UTF8ArrayToString(buf, 0);\\n    } else if (opts.encoding === \\\"binary\\\") {\\n      ret = buf;\\n    }\\n\\n    FS.close(stream);\\n    return ret;\\n  },\\n  writeFile: function (path, data, opts) {\\n    opts = opts || {};\\n    opts.flags = opts.flags || \\\"w\\\";\\n    var stream = FS.open(path, opts.flags, opts.mode);\\n\\n    if (typeof data === \\\"string\\\") {\\n      var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\\n      var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\\n      FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\\n    } else if (ArrayBuffer.isView(data)) {\\n      FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\\n    } else {\\n      throw new Error(\\\"Unsupported data type\\\");\\n    }\\n\\n    FS.close(stream);\\n  },\\n  cwd: function () {\\n    return FS.currentPath;\\n  },\\n  chdir: function (path) {\\n    var lookup = FS.lookupPath(path, {\\n      follow: true\\n    });\\n\\n    if (lookup.node === null) {\\n      throw new FS.ErrnoError(44);\\n    }\\n\\n    if (!FS.isDir(lookup.node.mode)) {\\n      throw new FS.ErrnoError(54);\\n    }\\n\\n    var errCode = FS.nodePermissions(lookup.node, \\\"x\\\");\\n\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n\\n    FS.currentPath = lookup.path;\\n  },\\n  createDefaultDirectories: function () {\\n    FS.mkdir(\\\"/tmp\\\");\\n    FS.mkdir(\\\"/home\\\");\\n    FS.mkdir(\\\"/home/web_user\\\");\\n  },\\n  createDefaultDevices: function () {\\n    FS.mkdir(\\\"/dev\\\");\\n    FS.registerDevice(FS.makedev(1, 3), {\\n      read: function () {\\n        return 0;\\n      },\\n      write: function (stream, buffer, offset, length, pos) {\\n        return length;\\n      }\\n    });\\n    FS.mkdev(\\\"/dev/null\\\", FS.makedev(1, 3));\\n    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\\n    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\\n    FS.mkdev(\\\"/dev/tty\\\", FS.makedev(5, 0));\\n    FS.mkdev(\\\"/dev/tty1\\\", FS.makedev(6, 0));\\n    var random_device;\\n\\n    if (typeof crypto === \\\"object\\\" && typeof crypto[\\\"getRandomValues\\\"] === \\\"function\\\") {\\n      var randomBuffer = new Uint8Array(1);\\n\\n      random_device = function () {\\n        crypto.getRandomValues(randomBuffer);\\n        return randomBuffer[0];\\n      };\\n    } else if (ENVIRONMENT_IS_NODE) {\\n      try {\\n        var crypto_module = require(\\\"crypto\\\");\\n\\n        random_device = function () {\\n          return crypto_module[\\\"randomBytes\\\"](1)[0];\\n        };\\n      } catch (e) {}\\n    } else {}\\n\\n    if (!random_device) {\\n      random_device = function () {\\n        abort(\\\"random_device\\\");\\n      };\\n    }\\n\\n    FS.createDevice(\\\"/dev\\\", \\\"random\\\", random_device);\\n    FS.createDevice(\\\"/dev\\\", \\\"urandom\\\", random_device);\\n    FS.mkdir(\\\"/dev/shm\\\");\\n    FS.mkdir(\\\"/dev/shm/tmp\\\");\\n  },\\n  createSpecialDirectories: function () {\\n    FS.mkdir(\\\"/proc\\\");\\n    FS.mkdir(\\\"/proc/self\\\");\\n    FS.mkdir(\\\"/proc/self/fd\\\");\\n    FS.mount({\\n      mount: function () {\\n        var node = FS.createNode(\\\"/proc/self\\\", \\\"fd\\\", 16384 | 511, 73);\\n        node.node_ops = {\\n          lookup: function (parent, name) {\\n            var fd = +name;\\n            var stream = FS.getStream(fd);\\n            if (!stream) throw new FS.ErrnoError(8);\\n            var ret = {\\n              parent: null,\\n              mount: {\\n                mountpoint: \\\"fake\\\"\\n              },\\n              node_ops: {\\n                readlink: function () {\\n                  return stream.path;\\n                }\\n              }\\n            };\\n            ret.parent = ret;\\n            return ret;\\n          }\\n        };\\n        return node;\\n      }\\n    }, {}, \\\"/proc/self/fd\\\");\\n  },\\n  createStandardStreams: function () {\\n    if (Module[\\\"stdin\\\"]) {\\n      FS.createDevice(\\\"/dev\\\", \\\"stdin\\\", Module[\\\"stdin\\\"]);\\n    } else {\\n      FS.symlink(\\\"/dev/tty\\\", \\\"/dev/stdin\\\");\\n    }\\n\\n    if (Module[\\\"stdout\\\"]) {\\n      FS.createDevice(\\\"/dev\\\", \\\"stdout\\\", null, Module[\\\"stdout\\\"]);\\n    } else {\\n      FS.symlink(\\\"/dev/tty\\\", \\\"/dev/stdout\\\");\\n    }\\n\\n    if (Module[\\\"stderr\\\"]) {\\n      FS.createDevice(\\\"/dev\\\", \\\"stderr\\\", null, Module[\\\"stderr\\\"]);\\n    } else {\\n      FS.symlink(\\\"/dev/tty1\\\", \\\"/dev/stderr\\\");\\n    }\\n\\n    var stdin = FS.open(\\\"/dev/stdin\\\", \\\"r\\\");\\n    var stdout = FS.open(\\\"/dev/stdout\\\", \\\"w\\\");\\n    var stderr = FS.open(\\\"/dev/stderr\\\", \\\"w\\\");\\n  },\\n  ensureErrnoError: function () {\\n    if (FS.ErrnoError) return;\\n\\n    FS.ErrnoError = function ErrnoError(errno, node) {\\n      this.node = node;\\n\\n      this.setErrno = function (errno) {\\n        this.errno = errno;\\n      };\\n\\n      this.setErrno(errno);\\n      this.message = \\\"FS error\\\";\\n    };\\n\\n    FS.ErrnoError.prototype = new Error();\\n    FS.ErrnoError.prototype.constructor = FS.ErrnoError;\\n    [44].forEach(function (code) {\\n      FS.genericErrors[code] = new FS.ErrnoError(code);\\n      FS.genericErrors[code].stack = \\\"<generic error, no stack>\\\";\\n    });\\n  },\\n  staticInit: function () {\\n    FS.ensureErrnoError();\\n    FS.nameTable = new Array(4096);\\n    FS.mount(MEMFS, {}, \\\"/\\\");\\n    FS.createDefaultDirectories();\\n    FS.createDefaultDevices();\\n    FS.createSpecialDirectories();\\n    FS.filesystems = {\\n      \\\"MEMFS\\\": MEMFS\\n    };\\n  },\\n  init: function (input, output, error) {\\n    FS.init.initialized = true;\\n    FS.ensureErrnoError();\\n    Module[\\\"stdin\\\"] = input || Module[\\\"stdin\\\"];\\n    Module[\\\"stdout\\\"] = output || Module[\\\"stdout\\\"];\\n    Module[\\\"stderr\\\"] = error || Module[\\\"stderr\\\"];\\n    FS.createStandardStreams();\\n  },\\n  quit: function () {\\n    FS.init.initialized = false;\\n    var fflush = Module[\\\"_fflush\\\"];\\n    if (fflush) fflush(0);\\n\\n    for (var i = 0; i < FS.streams.length; i++) {\\n      var stream = FS.streams[i];\\n\\n      if (!stream) {\\n        continue;\\n      }\\n\\n      FS.close(stream);\\n    }\\n  },\\n  getMode: function (canRead, canWrite) {\\n    var mode = 0;\\n    if (canRead) mode |= 292 | 73;\\n    if (canWrite) mode |= 146;\\n    return mode;\\n  },\\n  joinPath: function (parts, forceRelative) {\\n    var path = PATH.join.apply(null, parts);\\n    if (forceRelative && path[0] == \\\"/\\\") path = path.substr(1);\\n    return path;\\n  },\\n  absolutePath: function (relative, base) {\\n    return PATH_FS.resolve(base, relative);\\n  },\\n  standardizePath: function (path) {\\n    return PATH.normalize(path);\\n  },\\n  findObject: function (path, dontResolveLastLink) {\\n    var ret = FS.analyzePath(path, dontResolveLastLink);\\n\\n    if (ret.exists) {\\n      return ret.object;\\n    } else {\\n      setErrNo(ret.error);\\n      return null;\\n    }\\n  },\\n  analyzePath: function (path, dontResolveLastLink) {\\n    try {\\n      var lookup = FS.lookupPath(path, {\\n        follow: !dontResolveLastLink\\n      });\\n      path = lookup.path;\\n    } catch (e) {}\\n\\n    var ret = {\\n      isRoot: false,\\n      exists: false,\\n      error: 0,\\n      name: null,\\n      path: null,\\n      object: null,\\n      parentExists: false,\\n      parentPath: null,\\n      parentObject: null\\n    };\\n\\n    try {\\n      var lookup = FS.lookupPath(path, {\\n        parent: true\\n      });\\n      ret.parentExists = true;\\n      ret.parentPath = lookup.path;\\n      ret.parentObject = lookup.node;\\n      ret.name = PATH.basename(path);\\n      lookup = FS.lookupPath(path, {\\n        follow: !dontResolveLastLink\\n      });\\n      ret.exists = true;\\n      ret.path = lookup.path;\\n      ret.object = lookup.node;\\n      ret.name = lookup.node.name;\\n      ret.isRoot = lookup.path === \\\"/\\\";\\n    } catch (e) {\\n      ret.error = e.errno;\\n    }\\n\\n    return ret;\\n  },\\n  createFolder: function (parent, name, canRead, canWrite) {\\n    var path = PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name);\\n    var mode = FS.getMode(canRead, canWrite);\\n    return FS.mkdir(path, mode);\\n  },\\n  createPath: function (parent, path, canRead, canWrite) {\\n    parent = typeof parent === \\\"string\\\" ? parent : FS.getPath(parent);\\n    var parts = path.split(\\\"/\\\").reverse();\\n\\n    while (parts.length) {\\n      var part = parts.pop();\\n      if (!part) continue;\\n      var current = PATH.join2(parent, part);\\n\\n      try {\\n        FS.mkdir(current);\\n      } catch (e) {}\\n\\n      parent = current;\\n    }\\n\\n    return current;\\n  },\\n  createFile: function (parent, name, properties, canRead, canWrite) {\\n    var path = PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name);\\n    var mode = FS.getMode(canRead, canWrite);\\n    return FS.create(path, mode);\\n  },\\n  createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {\\n    var path = name ? PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name) : parent;\\n    var mode = FS.getMode(canRead, canWrite);\\n    var node = FS.create(path, mode);\\n\\n    if (data) {\\n      if (typeof data === \\\"string\\\") {\\n        var arr = new Array(data.length);\\n\\n        for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\\n\\n        data = arr;\\n      }\\n\\n      FS.chmod(node, mode | 146);\\n      var stream = FS.open(node, \\\"w\\\");\\n      FS.write(stream, data, 0, data.length, 0, canOwn);\\n      FS.close(stream);\\n      FS.chmod(node, mode);\\n    }\\n\\n    return node;\\n  },\\n  createDevice: function (parent, name, input, output) {\\n    var path = PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name);\\n    var mode = FS.getMode(!!input, !!output);\\n    if (!FS.createDevice.major) FS.createDevice.major = 64;\\n    var dev = FS.makedev(FS.createDevice.major++, 0);\\n    FS.registerDevice(dev, {\\n      open: function (stream) {\\n        stream.seekable = false;\\n      },\\n      close: function (stream) {\\n        if (output && output.buffer && output.buffer.length) {\\n          output(10);\\n        }\\n      },\\n      read: function (stream, buffer, offset, length, pos) {\\n        var bytesRead = 0;\\n\\n        for (var i = 0; i < length; i++) {\\n          var result;\\n\\n          try {\\n            result = input();\\n          } catch (e) {\\n            throw new FS.ErrnoError(29);\\n          }\\n\\n          if (result === undefined && bytesRead === 0) {\\n            throw new FS.ErrnoError(6);\\n          }\\n\\n          if (result === null || result === undefined) break;\\n          bytesRead++;\\n          buffer[offset + i] = result;\\n        }\\n\\n        if (bytesRead) {\\n          stream.node.timestamp = Date.now();\\n        }\\n\\n        return bytesRead;\\n      },\\n      write: function (stream, buffer, offset, length, pos) {\\n        for (var i = 0; i < length; i++) {\\n          try {\\n            output(buffer[offset + i]);\\n          } catch (e) {\\n            throw new FS.ErrnoError(29);\\n          }\\n        }\\n\\n        if (length) {\\n          stream.node.timestamp = Date.now();\\n        }\\n\\n        return i;\\n      }\\n    });\\n    return FS.mkdev(path, mode, dev);\\n  },\\n  createLink: function (parent, name, target, canRead, canWrite) {\\n    var path = PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name);\\n    return FS.symlink(target, path);\\n  },\\n  forceLoadFile: function (obj) {\\n    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\\n    var success = true;\\n\\n    if (typeof XMLHttpRequest !== \\\"undefined\\\") {\\n      throw new Error(\\\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\\\");\\n    } else if (read_) {\\n      try {\\n        obj.contents = intArrayFromString(read_(obj.url), true);\\n        obj.usedBytes = obj.contents.length;\\n      } catch (e) {\\n        success = false;\\n      }\\n    } else {\\n      throw new Error(\\\"Cannot load without read() or XMLHttpRequest.\\\");\\n    }\\n\\n    if (!success) setErrNo(29);\\n    return success;\\n  },\\n  createLazyFile: function (parent, name, url, canRead, canWrite) {\\n    function LazyUint8Array() {\\n      this.lengthKnown = false;\\n      this.chunks = [];\\n    }\\n\\n    LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\\n      if (idx > this.length - 1 || idx < 0) {\\n        return undefined;\\n      }\\n\\n      var chunkOffset = idx % this.chunkSize;\\n      var chunkNum = idx / this.chunkSize | 0;\\n      return this.getter(chunkNum)[chunkOffset];\\n    };\\n\\n    LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\\n      this.getter = getter;\\n    };\\n\\n    LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\\n      var xhr = new XMLHttpRequest();\\n      xhr.open(\\\"HEAD\\\", url, false);\\n      xhr.send(null);\\n      if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\\\"Couldn't load \\\" + url + \\\". Status: \\\" + xhr.status);\\n      var datalength = Number(xhr.getResponseHeader(\\\"Content-length\\\"));\\n      var header;\\n      var hasByteServing = (header = xhr.getResponseHeader(\\\"Accept-Ranges\\\")) && header === \\\"bytes\\\";\\n      var usesGzip = (header = xhr.getResponseHeader(\\\"Content-Encoding\\\")) && header === \\\"gzip\\\";\\n      var chunkSize = 1024 * 1024;\\n      if (!hasByteServing) chunkSize = datalength;\\n\\n      var doXHR = function (from, to) {\\n        if (from > to) throw new Error(\\\"invalid range (\\\" + from + \\\", \\\" + to + \\\") or no bytes requested!\\\");\\n        if (to > datalength - 1) throw new Error(\\\"only \\\" + datalength + \\\" bytes available! programmer error!\\\");\\n        var xhr = new XMLHttpRequest();\\n        xhr.open(\\\"GET\\\", url, false);\\n        if (datalength !== chunkSize) xhr.setRequestHeader(\\\"Range\\\", \\\"bytes=\\\" + from + \\\"-\\\" + to);\\n        if (typeof Uint8Array != \\\"undefined\\\") xhr.responseType = \\\"arraybuffer\\\";\\n\\n        if (xhr.overrideMimeType) {\\n          xhr.overrideMimeType(\\\"text/plain; charset=x-user-defined\\\");\\n        }\\n\\n        xhr.send(null);\\n        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\\\"Couldn't load \\\" + url + \\\". Status: \\\" + xhr.status);\\n\\n        if (xhr.response !== undefined) {\\n          return new Uint8Array(xhr.response || []);\\n        } else {\\n          return intArrayFromString(xhr.responseText || \\\"\\\", true);\\n        }\\n      };\\n\\n      var lazyArray = this;\\n      lazyArray.setDataGetter(function (chunkNum) {\\n        var start = chunkNum * chunkSize;\\n        var end = (chunkNum + 1) * chunkSize - 1;\\n        end = Math.min(end, datalength - 1);\\n\\n        if (typeof lazyArray.chunks[chunkNum] === \\\"undefined\\\") {\\n          lazyArray.chunks[chunkNum] = doXHR(start, end);\\n        }\\n\\n        if (typeof lazyArray.chunks[chunkNum] === \\\"undefined\\\") throw new Error(\\\"doXHR failed!\\\");\\n        return lazyArray.chunks[chunkNum];\\n      });\\n\\n      if (usesGzip || !datalength) {\\n        chunkSize = datalength = 1;\\n        datalength = this.getter(0).length;\\n        chunkSize = datalength;\\n        out(\\\"LazyFiles on gzip forces download of the whole file when length is accessed\\\");\\n      }\\n\\n      this._length = datalength;\\n      this._chunkSize = chunkSize;\\n      this.lengthKnown = true;\\n    };\\n\\n    if (typeof XMLHttpRequest !== \\\"undefined\\\") {\\n      if (!ENVIRONMENT_IS_WORKER) throw \\\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\\\";\\n      var lazyArray = new LazyUint8Array();\\n      Object.defineProperties(lazyArray, {\\n        length: {\\n          get: function () {\\n            if (!this.lengthKnown) {\\n              this.cacheLength();\\n            }\\n\\n            return this._length;\\n          }\\n        },\\n        chunkSize: {\\n          get: function () {\\n            if (!this.lengthKnown) {\\n              this.cacheLength();\\n            }\\n\\n            return this._chunkSize;\\n          }\\n        }\\n      });\\n      var properties = {\\n        isDevice: false,\\n        contents: lazyArray\\n      };\\n    } else {\\n      var properties = {\\n        isDevice: false,\\n        url: url\\n      };\\n    }\\n\\n    var node = FS.createFile(parent, name, properties, canRead, canWrite);\\n\\n    if (properties.contents) {\\n      node.contents = properties.contents;\\n    } else if (properties.url) {\\n      node.contents = null;\\n      node.url = properties.url;\\n    }\\n\\n    Object.defineProperties(node, {\\n      usedBytes: {\\n        get: function () {\\n          return this.contents.length;\\n        }\\n      }\\n    });\\n    var stream_ops = {};\\n    var keys = Object.keys(node.stream_ops);\\n    keys.forEach(function (key) {\\n      var fn = node.stream_ops[key];\\n\\n      stream_ops[key] = function forceLoadLazyFile() {\\n        if (!FS.forceLoadFile(node)) {\\n          throw new FS.ErrnoError(29);\\n        }\\n\\n        return fn.apply(null, arguments);\\n      };\\n    });\\n\\n    stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\\n      if (!FS.forceLoadFile(node)) {\\n        throw new FS.ErrnoError(29);\\n      }\\n\\n      var contents = stream.node.contents;\\n      if (position >= contents.length) return 0;\\n      var size = Math.min(contents.length - position, length);\\n\\n      if (contents.slice) {\\n        for (var i = 0; i < size; i++) {\\n          buffer[offset + i] = contents[position + i];\\n        }\\n      } else {\\n        for (var i = 0; i < size; i++) {\\n          buffer[offset + i] = contents.get(position + i);\\n        }\\n      }\\n\\n      return size;\\n    };\\n\\n    node.stream_ops = stream_ops;\\n    return node;\\n  },\\n  createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\\n    Browser.init();\\n    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\\n    var dep = getUniqueRunDependency(\\\"cp \\\" + fullname);\\n\\n    function processData(byteArray) {\\n      function finish(byteArray) {\\n        if (preFinish) preFinish();\\n\\n        if (!dontCreateFile) {\\n          FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\\n        }\\n\\n        if (onload) onload();\\n        removeRunDependency(dep);\\n      }\\n\\n      var handled = false;\\n      Module[\\\"preloadPlugins\\\"].forEach(function (plugin) {\\n        if (handled) return;\\n\\n        if (plugin[\\\"canHandle\\\"](fullname)) {\\n          plugin[\\\"handle\\\"](byteArray, fullname, finish, function () {\\n            if (onerror) onerror();\\n            removeRunDependency(dep);\\n          });\\n          handled = true;\\n        }\\n      });\\n      if (!handled) finish(byteArray);\\n    }\\n\\n    addRunDependency(dep);\\n\\n    if (typeof url == \\\"string\\\") {\\n      Browser.asyncLoad(url, function (byteArray) {\\n        processData(byteArray);\\n      }, onerror);\\n    } else {\\n      processData(url);\\n    }\\n  },\\n  indexedDB: function () {\\n    return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\\n  },\\n  DB_NAME: function () {\\n    return \\\"EM_FS_\\\" + window.location.pathname;\\n  },\\n  DB_VERSION: 20,\\n  DB_STORE_NAME: \\\"FILE_DATA\\\",\\n  saveFilesToDB: function (paths, onload, onerror) {\\n    onload = onload || function () {};\\n\\n    onerror = onerror || function () {};\\n\\n    var indexedDB = FS.indexedDB();\\n\\n    try {\\n      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\\n    } catch (e) {\\n      return onerror(e);\\n    }\\n\\n    openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\\n      out(\\\"creating db\\\");\\n      var db = openRequest.result;\\n      db.createObjectStore(FS.DB_STORE_NAME);\\n    };\\n\\n    openRequest.onsuccess = function openRequest_onsuccess() {\\n      var db = openRequest.result;\\n      var transaction = db.transaction([FS.DB_STORE_NAME], \\\"readwrite\\\");\\n      var files = transaction.objectStore(FS.DB_STORE_NAME);\\n      var ok = 0,\\n          fail = 0,\\n          total = paths.length;\\n\\n      function finish() {\\n        if (fail == 0) onload();else onerror();\\n      }\\n\\n      paths.forEach(function (path) {\\n        var putRequest = files.put(FS.analyzePath(path).object.contents, path);\\n\\n        putRequest.onsuccess = function putRequest_onsuccess() {\\n          ok++;\\n          if (ok + fail == total) finish();\\n        };\\n\\n        putRequest.onerror = function putRequest_onerror() {\\n          fail++;\\n          if (ok + fail == total) finish();\\n        };\\n      });\\n      transaction.onerror = onerror;\\n    };\\n\\n    openRequest.onerror = onerror;\\n  },\\n  loadFilesFromDB: function (paths, onload, onerror) {\\n    onload = onload || function () {};\\n\\n    onerror = onerror || function () {};\\n\\n    var indexedDB = FS.indexedDB();\\n\\n    try {\\n      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\\n    } catch (e) {\\n      return onerror(e);\\n    }\\n\\n    openRequest.onupgradeneeded = onerror;\\n\\n    openRequest.onsuccess = function openRequest_onsuccess() {\\n      var db = openRequest.result;\\n\\n      try {\\n        var transaction = db.transaction([FS.DB_STORE_NAME], \\\"readonly\\\");\\n      } catch (e) {\\n        onerror(e);\\n        return;\\n      }\\n\\n      var files = transaction.objectStore(FS.DB_STORE_NAME);\\n      var ok = 0,\\n          fail = 0,\\n          total = paths.length;\\n\\n      function finish() {\\n        if (fail == 0) onload();else onerror();\\n      }\\n\\n      paths.forEach(function (path) {\\n        var getRequest = files.get(path);\\n\\n        getRequest.onsuccess = function getRequest_onsuccess() {\\n          if (FS.analyzePath(path).exists) {\\n            FS.unlink(path);\\n          }\\n\\n          FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\\n          ok++;\\n          if (ok + fail == total) finish();\\n        };\\n\\n        getRequest.onerror = function getRequest_onerror() {\\n          fail++;\\n          if (ok + fail == total) finish();\\n        };\\n      });\\n      transaction.onerror = onerror;\\n    };\\n\\n    openRequest.onerror = onerror;\\n  }\\n};\\nvar SYSCALLS = {\\n  mappings: {},\\n  DEFAULT_POLLMASK: 5,\\n  umask: 511,\\n  calculateAt: function (dirfd, path) {\\n    if (path[0] !== \\\"/\\\") {\\n      var dir;\\n\\n      if (dirfd === -100) {\\n        dir = FS.cwd();\\n      } else {\\n        var dirstream = FS.getStream(dirfd);\\n        if (!dirstream) throw new FS.ErrnoError(8);\\n        dir = dirstream.path;\\n      }\\n\\n      path = PATH.join2(dir, path);\\n    }\\n\\n    return path;\\n  },\\n  doStat: function (func, path, buf) {\\n    try {\\n      var stat = func(path);\\n    } catch (e) {\\n      if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\\n        return -54;\\n      }\\n\\n      throw e;\\n    }\\n\\n    HEAP32[buf >> 2] = stat.dev;\\n    HEAP32[buf + 4 >> 2] = 0;\\n    HEAP32[buf + 8 >> 2] = stat.ino;\\n    HEAP32[buf + 12 >> 2] = stat.mode;\\n    HEAP32[buf + 16 >> 2] = stat.nlink;\\n    HEAP32[buf + 20 >> 2] = stat.uid;\\n    HEAP32[buf + 24 >> 2] = stat.gid;\\n    HEAP32[buf + 28 >> 2] = stat.rdev;\\n    HEAP32[buf + 32 >> 2] = 0;\\n    tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\\n    HEAP32[buf + 48 >> 2] = 4096;\\n    HEAP32[buf + 52 >> 2] = stat.blocks;\\n    HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;\\n    HEAP32[buf + 60 >> 2] = 0;\\n    HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;\\n    HEAP32[buf + 68 >> 2] = 0;\\n    HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;\\n    HEAP32[buf + 76 >> 2] = 0;\\n    tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];\\n    return 0;\\n  },\\n  doMsync: function (addr, stream, len, flags, offset) {\\n    var buffer = HEAPU8.slice(addr, addr + len);\\n    FS.msync(stream, buffer, offset, len, flags);\\n  },\\n  doMkdir: function (path, mode) {\\n    path = PATH.normalize(path);\\n    if (path[path.length - 1] === \\\"/\\\") path = path.substr(0, path.length - 1);\\n    FS.mkdir(path, mode, 0);\\n    return 0;\\n  },\\n  doMknod: function (path, mode, dev) {\\n    switch (mode & 61440) {\\n      case 32768:\\n      case 8192:\\n      case 24576:\\n      case 4096:\\n      case 49152:\\n        break;\\n\\n      default:\\n        return -28;\\n    }\\n\\n    FS.mknod(path, mode, dev);\\n    return 0;\\n  },\\n  doReadlink: function (path, buf, bufsize) {\\n    if (bufsize <= 0) return -28;\\n    var ret = FS.readlink(path);\\n    var len = Math.min(bufsize, lengthBytesUTF8(ret));\\n    var endChar = HEAP8[buf + len];\\n    stringToUTF8(ret, buf, bufsize + 1);\\n    HEAP8[buf + len] = endChar;\\n    return len;\\n  },\\n  doAccess: function (path, amode) {\\n    if (amode & ~7) {\\n      return -28;\\n    }\\n\\n    var node;\\n    var lookup = FS.lookupPath(path, {\\n      follow: true\\n    });\\n    node = lookup.node;\\n\\n    if (!node) {\\n      return -44;\\n    }\\n\\n    var perms = \\\"\\\";\\n    if (amode & 4) perms += \\\"r\\\";\\n    if (amode & 2) perms += \\\"w\\\";\\n    if (amode & 1) perms += \\\"x\\\";\\n\\n    if (perms && FS.nodePermissions(node, perms)) {\\n      return -2;\\n    }\\n\\n    return 0;\\n  },\\n  doDup: function (path, flags, suggestFD) {\\n    var suggest = FS.getStream(suggestFD);\\n    if (suggest) FS.close(suggest);\\n    return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\\n  },\\n  doReadv: function (stream, iov, iovcnt, offset) {\\n    var ret = 0;\\n\\n    for (var i = 0; i < iovcnt; i++) {\\n      var ptr = HEAP32[iov + i * 8 >> 2];\\n      var len = HEAP32[iov + (i * 8 + 4) >> 2];\\n      var curr = FS.read(stream, HEAP8, ptr, len, offset);\\n      if (curr < 0) return -1;\\n      ret += curr;\\n      if (curr < len) break;\\n    }\\n\\n    return ret;\\n  },\\n  doWritev: function (stream, iov, iovcnt, offset) {\\n    var ret = 0;\\n\\n    for (var i = 0; i < iovcnt; i++) {\\n      var ptr = HEAP32[iov + i * 8 >> 2];\\n      var len = HEAP32[iov + (i * 8 + 4) >> 2];\\n      var curr = FS.write(stream, HEAP8, ptr, len, offset);\\n      if (curr < 0) return -1;\\n      ret += curr;\\n    }\\n\\n    return ret;\\n  },\\n  varargs: undefined,\\n  get: function () {\\n    SYSCALLS.varargs += 4;\\n    var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\\n    return ret;\\n  },\\n  getStr: function (ptr) {\\n    var ret = UTF8ToString(ptr);\\n    return ret;\\n  },\\n  getStreamFromFD: function (fd) {\\n    var stream = FS.getStream(fd);\\n    if (!stream) throw new FS.ErrnoError(8);\\n    return stream;\\n  },\\n  get64: function (low, high) {\\n    return low;\\n  }\\n};\\n\\nfunction ___sys_fcntl64(fd, cmd, varargs) {\\n  SYSCALLS.varargs = varargs;\\n\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n\\n    switch (cmd) {\\n      case 0:\\n        {\\n          var arg = SYSCALLS.get();\\n\\n          if (arg < 0) {\\n            return -28;\\n          }\\n\\n          var newStream;\\n          newStream = FS.open(stream.path, stream.flags, 0, arg);\\n          return newStream.fd;\\n        }\\n\\n      case 1:\\n      case 2:\\n        return 0;\\n\\n      case 3:\\n        return stream.flags;\\n\\n      case 4:\\n        {\\n          var arg = SYSCALLS.get();\\n          stream.flags |= arg;\\n          return 0;\\n        }\\n\\n      case 12:\\n        {\\n          var arg = SYSCALLS.get();\\n          var offset = 0;\\n          HEAP16[arg + offset >> 1] = 2;\\n          return 0;\\n        }\\n\\n      case 13:\\n      case 14:\\n        return 0;\\n\\n      case 16:\\n      case 8:\\n        return -28;\\n\\n      case 9:\\n        setErrNo(28);\\n        return -1;\\n\\n      default:\\n        {\\n          return -28;\\n        }\\n    }\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return -e.errno;\\n  }\\n}\\n\\nfunction ___sys_ioctl(fd, op, varargs) {\\n  SYSCALLS.varargs = varargs;\\n\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n\\n    switch (op) {\\n      case 21509:\\n      case 21505:\\n        {\\n          if (!stream.tty) return -59;\\n          return 0;\\n        }\\n\\n      case 21510:\\n      case 21511:\\n      case 21512:\\n      case 21506:\\n      case 21507:\\n      case 21508:\\n        {\\n          if (!stream.tty) return -59;\\n          return 0;\\n        }\\n\\n      case 21519:\\n        {\\n          if (!stream.tty) return -59;\\n          var argp = SYSCALLS.get();\\n          HEAP32[argp >> 2] = 0;\\n          return 0;\\n        }\\n\\n      case 21520:\\n        {\\n          if (!stream.tty) return -59;\\n          return -28;\\n        }\\n\\n      case 21531:\\n        {\\n          var argp = SYSCALLS.get();\\n          return FS.ioctl(stream, op, argp);\\n        }\\n\\n      case 21523:\\n        {\\n          if (!stream.tty) return -59;\\n          return 0;\\n        }\\n\\n      case 21524:\\n        {\\n          if (!stream.tty) return -59;\\n          return 0;\\n        }\\n\\n      default:\\n        abort(\\\"bad ioctl syscall \\\" + op);\\n    }\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return -e.errno;\\n  }\\n}\\n\\nfunction syscallMunmap(addr, len) {\\n  if ((addr | 0) === -1 || len === 0) {\\n    return -28;\\n  }\\n\\n  var info = SYSCALLS.mappings[addr];\\n  if (!info) return 0;\\n\\n  if (len === info.len) {\\n    var stream = FS.getStream(info.fd);\\n\\n    if (info.prot & 2) {\\n      SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);\\n    }\\n\\n    FS.munmap(stream);\\n    SYSCALLS.mappings[addr] = null;\\n\\n    if (info.allocated) {\\n      _free(info.malloc);\\n    }\\n  }\\n\\n  return 0;\\n}\\n\\nfunction ___sys_munmap(addr, len) {\\n  try {\\n    return syscallMunmap(addr, len);\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return -e.errno;\\n  }\\n}\\n\\nfunction ___sys_open(path, flags, varargs) {\\n  SYSCALLS.varargs = varargs;\\n\\n  try {\\n    var pathname = SYSCALLS.getStr(path);\\n    var mode = SYSCALLS.get();\\n    var stream = FS.open(pathname, flags, mode);\\n    return stream.fd;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return -e.errno;\\n  }\\n}\\n\\nfunction _abort() {\\n  abort();\\n}\\n\\nvar setjmpId = 0;\\n\\nfunction _saveSetjmp(env, label, table, size) {\\n  env = env | 0;\\n  label = label | 0;\\n  table = table | 0;\\n  size = size | 0;\\n  var i = 0;\\n  setjmpId = setjmpId + 1 | 0;\\n  HEAP32[env >> 2] = setjmpId;\\n\\n  while ((i | 0) < (size | 0)) {\\n    if ((HEAP32[table + (i << 3) >> 2] | 0) == 0) {\\n      HEAP32[table + (i << 3) >> 2] = setjmpId;\\n      HEAP32[table + ((i << 3) + 4) >> 2] = label;\\n      HEAP32[table + ((i << 3) + 8) >> 2] = 0;\\n      setTempRet0(size | 0);\\n      return table | 0;\\n    }\\n\\n    i = i + 1 | 0;\\n  }\\n\\n  size = size * 2 | 0;\\n  table = _realloc(table | 0, 8 * (size + 1 | 0) | 0) | 0;\\n  table = _saveSetjmp(env | 0, label | 0, table | 0, size | 0) | 0;\\n  setTempRet0(size | 0);\\n  return table | 0;\\n}\\n\\nfunction _testSetjmp(id, table, size) {\\n  id = id | 0;\\n  table = table | 0;\\n  size = size | 0;\\n  var i = 0,\\n      curr = 0;\\n\\n  while ((i | 0) < (size | 0)) {\\n    curr = HEAP32[table + (i << 3) >> 2] | 0;\\n    if ((curr | 0) == 0) break;\\n\\n    if ((curr | 0) == (id | 0)) {\\n      return HEAP32[table + ((i << 3) + 4) >> 2] | 0;\\n    }\\n\\n    i = i + 1 | 0;\\n  }\\n\\n  return 0;\\n}\\n\\nfunction _longjmp(env, value) {\\n  _setThrew(env, value || 1);\\n\\n  throw \\\"longjmp\\\";\\n}\\n\\nfunction _emscripten_longjmp(env, value) {\\n  _longjmp(env, value);\\n}\\n\\nfunction _emscripten_memcpy_big(dest, src, num) {\\n  HEAPU8.copyWithin(dest, src, src + num);\\n}\\n\\nfunction _emscripten_get_heap_size() {\\n  return HEAPU8.length;\\n}\\n\\nfunction emscripten_realloc_buffer(size) {\\n  try {\\n    wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\\n    updateGlobalBufferAndViews(wasmMemory.buffer);\\n    return 1;\\n  } catch (e) {}\\n}\\n\\nfunction _emscripten_resize_heap(requestedSize) {\\n  requestedSize = requestedSize >>> 0;\\n\\n  var oldSize = _emscripten_get_heap_size();\\n\\n  var PAGE_MULTIPLE = 65536;\\n  var maxHeapSize = 2147483648;\\n\\n  if (requestedSize > maxHeapSize) {\\n    return false;\\n  }\\n\\n  var minHeapSize = 16777216;\\n\\n  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\\n    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\\n    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\\n    var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));\\n    var replacement = emscripten_realloc_buffer(newSize);\\n\\n    if (replacement) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\nvar ENV = {};\\n\\nfunction __getExecutableName() {\\n  return thisProgram || \\\"./this.program\\\";\\n}\\n\\nfunction getEnvStrings() {\\n  if (!getEnvStrings.strings) {\\n    var env = {\\n      \\\"USER\\\": \\\"web_user\\\",\\n      \\\"LOGNAME\\\": \\\"web_user\\\",\\n      \\\"PATH\\\": \\\"/\\\",\\n      \\\"PWD\\\": \\\"/\\\",\\n      \\\"HOME\\\": \\\"/home/web_user\\\",\\n      \\\"LANG\\\": (typeof navigator === \\\"object\\\" && navigator.languages && navigator.languages[0] || \\\"C\\\").replace(\\\"-\\\", \\\"_\\\") + \\\".UTF-8\\\",\\n      \\\"_\\\": __getExecutableName()\\n    };\\n\\n    for (var x in ENV) {\\n      env[x] = ENV[x];\\n    }\\n\\n    var strings = [];\\n\\n    for (var x in env) {\\n      strings.push(x + \\\"=\\\" + env[x]);\\n    }\\n\\n    getEnvStrings.strings = strings;\\n  }\\n\\n  return getEnvStrings.strings;\\n}\\n\\nfunction _environ_get(__environ, environ_buf) {\\n  var bufSize = 0;\\n  getEnvStrings().forEach(function (string, i) {\\n    var ptr = environ_buf + bufSize;\\n    HEAP32[__environ + i * 4 >> 2] = ptr;\\n    writeAsciiToMemory(string, ptr);\\n    bufSize += string.length + 1;\\n  });\\n  return 0;\\n}\\n\\nfunction _environ_sizes_get(penviron_count, penviron_buf_size) {\\n  var strings = getEnvStrings();\\n  HEAP32[penviron_count >> 2] = strings.length;\\n  var bufSize = 0;\\n  strings.forEach(function (string) {\\n    bufSize += string.length + 1;\\n  });\\n  HEAP32[penviron_buf_size >> 2] = bufSize;\\n  return 0;\\n}\\n\\nfunction _fd_close(fd) {\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    FS.close(stream);\\n    return 0;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return e.errno;\\n  }\\n}\\n\\nfunction _fd_read(fd, iov, iovcnt, pnum) {\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    var num = SYSCALLS.doReadv(stream, iov, iovcnt);\\n    HEAP32[pnum >> 2] = num;\\n    return 0;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return e.errno;\\n  }\\n}\\n\\nfunction _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    var HIGH_OFFSET = 4294967296;\\n    var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);\\n    var DOUBLE_LIMIT = 9007199254740992;\\n\\n    if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {\\n      return -61;\\n    }\\n\\n    FS.llseek(stream, offset, whence);\\n    tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\\n    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\\n    return 0;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return e.errno;\\n  }\\n}\\n\\nfunction _fd_write(fd, iov, iovcnt, pnum) {\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    var num = SYSCALLS.doWritev(stream, iov, iovcnt);\\n    HEAP32[pnum >> 2] = num;\\n    return 0;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return e.errno;\\n  }\\n}\\n\\nfunction _getTempRet0() {\\n  return getTempRet0() | 0;\\n}\\n\\nfunction _round(d) {\\n  d = +d;\\n  return d >= +0 ? +Math_floor(d + +.5) : +Math_ceil(d - +.5);\\n}\\n\\nfunction _setTempRet0($i) {\\n  setTempRet0($i | 0);\\n}\\n\\nfunction __isLeapYear(year) {\\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\\n}\\n\\nfunction __arraySum(array, index) {\\n  var sum = 0;\\n\\n  for (var i = 0; i <= index; sum += array[i++]) {}\\n\\n  return sum;\\n}\\n\\nvar __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\nvar __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nfunction __addDays(date, days) {\\n  var newDate = new Date(date.getTime());\\n\\n  while (days > 0) {\\n    var leap = __isLeapYear(newDate.getFullYear());\\n\\n    var currentMonth = newDate.getMonth();\\n    var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\\n\\n    if (days > daysInCurrentMonth - newDate.getDate()) {\\n      days -= daysInCurrentMonth - newDate.getDate() + 1;\\n      newDate.setDate(1);\\n\\n      if (currentMonth < 11) {\\n        newDate.setMonth(currentMonth + 1);\\n      } else {\\n        newDate.setMonth(0);\\n        newDate.setFullYear(newDate.getFullYear() + 1);\\n      }\\n    } else {\\n      newDate.setDate(newDate.getDate() + days);\\n      return newDate;\\n    }\\n  }\\n\\n  return newDate;\\n}\\n\\nfunction _strftime(s, maxsize, format, tm) {\\n  var tm_zone = HEAP32[tm + 40 >> 2];\\n  var date = {\\n    tm_sec: HEAP32[tm >> 2],\\n    tm_min: HEAP32[tm + 4 >> 2],\\n    tm_hour: HEAP32[tm + 8 >> 2],\\n    tm_mday: HEAP32[tm + 12 >> 2],\\n    tm_mon: HEAP32[tm + 16 >> 2],\\n    tm_year: HEAP32[tm + 20 >> 2],\\n    tm_wday: HEAP32[tm + 24 >> 2],\\n    tm_yday: HEAP32[tm + 28 >> 2],\\n    tm_isdst: HEAP32[tm + 32 >> 2],\\n    tm_gmtoff: HEAP32[tm + 36 >> 2],\\n    tm_zone: tm_zone ? UTF8ToString(tm_zone) : \\\"\\\"\\n  };\\n  var pattern = UTF8ToString(format);\\n  var EXPANSION_RULES_1 = {\\n    \\\"%c\\\": \\\"%a %b %d %H:%M:%S %Y\\\",\\n    \\\"%D\\\": \\\"%m/%d/%y\\\",\\n    \\\"%F\\\": \\\"%Y-%m-%d\\\",\\n    \\\"%h\\\": \\\"%b\\\",\\n    \\\"%r\\\": \\\"%I:%M:%S %p\\\",\\n    \\\"%R\\\": \\\"%H:%M\\\",\\n    \\\"%T\\\": \\\"%H:%M:%S\\\",\\n    \\\"%x\\\": \\\"%m/%d/%y\\\",\\n    \\\"%X\\\": \\\"%H:%M:%S\\\",\\n    \\\"%Ec\\\": \\\"%c\\\",\\n    \\\"%EC\\\": \\\"%C\\\",\\n    \\\"%Ex\\\": \\\"%m/%d/%y\\\",\\n    \\\"%EX\\\": \\\"%H:%M:%S\\\",\\n    \\\"%Ey\\\": \\\"%y\\\",\\n    \\\"%EY\\\": \\\"%Y\\\",\\n    \\\"%Od\\\": \\\"%d\\\",\\n    \\\"%Oe\\\": \\\"%e\\\",\\n    \\\"%OH\\\": \\\"%H\\\",\\n    \\\"%OI\\\": \\\"%I\\\",\\n    \\\"%Om\\\": \\\"%m\\\",\\n    \\\"%OM\\\": \\\"%M\\\",\\n    \\\"%OS\\\": \\\"%S\\\",\\n    \\\"%Ou\\\": \\\"%u\\\",\\n    \\\"%OU\\\": \\\"%U\\\",\\n    \\\"%OV\\\": \\\"%V\\\",\\n    \\\"%Ow\\\": \\\"%w\\\",\\n    \\\"%OW\\\": \\\"%W\\\",\\n    \\\"%Oy\\\": \\\"%y\\\"\\n  };\\n\\n  for (var rule in EXPANSION_RULES_1) {\\n    pattern = pattern.replace(new RegExp(rule, \\\"g\\\"), EXPANSION_RULES_1[rule]);\\n  }\\n\\n  var WEEKDAYS = [\\\"Sunday\\\", \\\"Monday\\\", \\\"Tuesday\\\", \\\"Wednesday\\\", \\\"Thursday\\\", \\\"Friday\\\", \\\"Saturday\\\"];\\n  var MONTHS = [\\\"January\\\", \\\"February\\\", \\\"March\\\", \\\"April\\\", \\\"May\\\", \\\"June\\\", \\\"July\\\", \\\"August\\\", \\\"September\\\", \\\"October\\\", \\\"November\\\", \\\"December\\\"];\\n\\n  function leadingSomething(value, digits, character) {\\n    var str = typeof value === \\\"number\\\" ? value.toString() : value || \\\"\\\";\\n\\n    while (str.length < digits) {\\n      str = character[0] + str;\\n    }\\n\\n    return str;\\n  }\\n\\n  function leadingNulls(value, digits) {\\n    return leadingSomething(value, digits, \\\"0\\\");\\n  }\\n\\n  function compareByDay(date1, date2) {\\n    function sgn(value) {\\n      return value < 0 ? -1 : value > 0 ? 1 : 0;\\n    }\\n\\n    var compare;\\n\\n    if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\\n      if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\\n        compare = sgn(date1.getDate() - date2.getDate());\\n      }\\n    }\\n\\n    return compare;\\n  }\\n\\n  function getFirstWeekStartDate(janFourth) {\\n    switch (janFourth.getDay()) {\\n      case 0:\\n        return new Date(janFourth.getFullYear() - 1, 11, 29);\\n\\n      case 1:\\n        return janFourth;\\n\\n      case 2:\\n        return new Date(janFourth.getFullYear(), 0, 3);\\n\\n      case 3:\\n        return new Date(janFourth.getFullYear(), 0, 2);\\n\\n      case 4:\\n        return new Date(janFourth.getFullYear(), 0, 1);\\n\\n      case 5:\\n        return new Date(janFourth.getFullYear() - 1, 11, 31);\\n\\n      case 6:\\n        return new Date(janFourth.getFullYear() - 1, 11, 30);\\n    }\\n  }\\n\\n  function getWeekBasedYear(date) {\\n    var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\\n\\n    var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\\n    var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\\n    var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\\n    var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\\n\\n    if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\\n      if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\\n        return thisDate.getFullYear() + 1;\\n      } else {\\n        return thisDate.getFullYear();\\n      }\\n    } else {\\n      return thisDate.getFullYear() - 1;\\n    }\\n  }\\n\\n  var EXPANSION_RULES_2 = {\\n    \\\"%a\\\": function (date) {\\n      return WEEKDAYS[date.tm_wday].substring(0, 3);\\n    },\\n    \\\"%A\\\": function (date) {\\n      return WEEKDAYS[date.tm_wday];\\n    },\\n    \\\"%b\\\": function (date) {\\n      return MONTHS[date.tm_mon].substring(0, 3);\\n    },\\n    \\\"%B\\\": function (date) {\\n      return MONTHS[date.tm_mon];\\n    },\\n    \\\"%C\\\": function (date) {\\n      var year = date.tm_year + 1900;\\n      return leadingNulls(year / 100 | 0, 2);\\n    },\\n    \\\"%d\\\": function (date) {\\n      return leadingNulls(date.tm_mday, 2);\\n    },\\n    \\\"%e\\\": function (date) {\\n      return leadingSomething(date.tm_mday, 2, \\\" \\\");\\n    },\\n    \\\"%g\\\": function (date) {\\n      return getWeekBasedYear(date).toString().substring(2);\\n    },\\n    \\\"%G\\\": function (date) {\\n      return getWeekBasedYear(date);\\n    },\\n    \\\"%H\\\": function (date) {\\n      return leadingNulls(date.tm_hour, 2);\\n    },\\n    \\\"%I\\\": function (date) {\\n      var twelveHour = date.tm_hour;\\n      if (twelveHour == 0) twelveHour = 12;else if (twelveHour > 12) twelveHour -= 12;\\n      return leadingNulls(twelveHour, 2);\\n    },\\n    \\\"%j\\\": function (date) {\\n      return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\\n    },\\n    \\\"%m\\\": function (date) {\\n      return leadingNulls(date.tm_mon + 1, 2);\\n    },\\n    \\\"%M\\\": function (date) {\\n      return leadingNulls(date.tm_min, 2);\\n    },\\n    \\\"%n\\\": function () {\\n      return \\\"\\\\n\\\";\\n    },\\n    \\\"%p\\\": function (date) {\\n      if (date.tm_hour >= 0 && date.tm_hour < 12) {\\n        return \\\"AM\\\";\\n      } else {\\n        return \\\"PM\\\";\\n      }\\n    },\\n    \\\"%S\\\": function (date) {\\n      return leadingNulls(date.tm_sec, 2);\\n    },\\n    \\\"%t\\\": function () {\\n      return \\\"\\\\t\\\";\\n    },\\n    \\\"%u\\\": function (date) {\\n      return date.tm_wday || 7;\\n    },\\n    \\\"%U\\\": function (date) {\\n      var janFirst = new Date(date.tm_year + 1900, 0, 1);\\n      var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\\n      var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\\n\\n      if (compareByDay(firstSunday, endDate) < 0) {\\n        var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\\n        var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\\n        var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\\n        return leadingNulls(Math.ceil(days / 7), 2);\\n      }\\n\\n      return compareByDay(firstSunday, janFirst) === 0 ? \\\"01\\\" : \\\"00\\\";\\n    },\\n    \\\"%V\\\": function (date) {\\n      var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);\\n      var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);\\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\\n\\n      var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\\n\\n      if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\\n        return \\\"53\\\";\\n      }\\n\\n      if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\\n        return \\\"01\\\";\\n      }\\n\\n      var daysDifference;\\n\\n      if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {\\n        daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();\\n      } else {\\n        daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();\\n      }\\n\\n      return leadingNulls(Math.ceil(daysDifference / 7), 2);\\n    },\\n    \\\"%w\\\": function (date) {\\n      return date.tm_wday;\\n    },\\n    \\\"%W\\\": function (date) {\\n      var janFirst = new Date(date.tm_year, 0, 1);\\n      var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\\n      var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\\n\\n      if (compareByDay(firstMonday, endDate) < 0) {\\n        var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\\n        var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\\n        var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\\n        return leadingNulls(Math.ceil(days / 7), 2);\\n      }\\n\\n      return compareByDay(firstMonday, janFirst) === 0 ? \\\"01\\\" : \\\"00\\\";\\n    },\\n    \\\"%y\\\": function (date) {\\n      return (date.tm_year + 1900).toString().substring(2);\\n    },\\n    \\\"%Y\\\": function (date) {\\n      return date.tm_year + 1900;\\n    },\\n    \\\"%z\\\": function (date) {\\n      var off = date.tm_gmtoff;\\n      var ahead = off >= 0;\\n      off = Math.abs(off) / 60;\\n      off = off / 60 * 100 + off % 60;\\n      return (ahead ? \\\"+\\\" : \\\"-\\\") + String(\\\"0000\\\" + off).slice(-4);\\n    },\\n    \\\"%Z\\\": function (date) {\\n      return date.tm_zone;\\n    },\\n    \\\"%%\\\": function () {\\n      return \\\"%\\\";\\n    }\\n  };\\n\\n  for (var rule in EXPANSION_RULES_2) {\\n    if (pattern.indexOf(rule) >= 0) {\\n      pattern = pattern.replace(new RegExp(rule, \\\"g\\\"), EXPANSION_RULES_2[rule](date));\\n    }\\n  }\\n\\n  var bytes = intArrayFromString(pattern, false);\\n\\n  if (bytes.length > maxsize) {\\n    return 0;\\n  }\\n\\n  writeArrayToMemory(bytes, s);\\n  return bytes.length - 1;\\n}\\n\\nfunction _strftime_l(s, maxsize, format, tm) {\\n  return _strftime(s, maxsize, format, tm);\\n}\\n\\nvar FSNode = function (parent, name, mode, rdev) {\\n  if (!parent) {\\n    parent = this;\\n  }\\n\\n  this.parent = parent;\\n  this.mount = parent.mount;\\n  this.mounted = null;\\n  this.id = FS.nextInode++;\\n  this.name = name;\\n  this.mode = mode;\\n  this.node_ops = {};\\n  this.stream_ops = {};\\n  this.rdev = rdev;\\n};\\n\\nvar readMode = 292 | 73;\\nvar writeMode = 146;\\nObject.defineProperties(FSNode.prototype, {\\n  read: {\\n    get: function () {\\n      return (this.mode & readMode) === readMode;\\n    },\\n    set: function (val) {\\n      val ? this.mode |= readMode : this.mode &= ~readMode;\\n    }\\n  },\\n  write: {\\n    get: function () {\\n      return (this.mode & writeMode) === writeMode;\\n    },\\n    set: function (val) {\\n      val ? this.mode |= writeMode : this.mode &= ~writeMode;\\n    }\\n  },\\n  isFolder: {\\n    get: function () {\\n      return FS.isDir(this.mode);\\n    }\\n  },\\n  isDevice: {\\n    get: function () {\\n      return FS.isChrdev(this.mode);\\n    }\\n  }\\n});\\nFS.FSNode = FSNode;\\nFS.staticInit();\\n\\nfunction intArrayFromString(stringy, dontAddNull, length) {\\n  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\\n  var u8array = new Array(len);\\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\\n  if (dontAddNull) u8array.length = numBytesWritten;\\n  return u8array;\\n}\\n\\nvar asmLibraryArg = {\\n  \\\"o\\\": __ZN7VRegionC1ERK5VRect,\\n  \\\"m\\\": __ZN7VRegionD1Ev,\\n  \\\"n\\\": __ZN7VRegionpLERK5VRect,\\n  \\\"x\\\": __ZNK7VRegion12boundingRectEv,\\n  \\\"a\\\": ___assert_fail,\\n  \\\"u\\\": ___map_file,\\n  \\\"h\\\": ___sys_fcntl64,\\n  \\\"z\\\": ___sys_ioctl,\\n  \\\"t\\\": ___sys_munmap,\\n  \\\"A\\\": ___sys_open,\\n  \\\"d\\\": _abort,\\n  \\\"c\\\": _emscripten_longjmp,\\n  \\\"q\\\": _emscripten_memcpy_big,\\n  \\\"r\\\": _emscripten_resize_heap,\\n  \\\"v\\\": _environ_get,\\n  \\\"w\\\": _environ_sizes_get,\\n  \\\"g\\\": _fd_close,\\n  \\\"y\\\": _fd_read,\\n  \\\"p\\\": _fd_seek,\\n  \\\"f\\\": _fd_write,\\n  \\\"b\\\": _getTempRet0,\\n  \\\"k\\\": invoke_iii,\\n  \\\"B\\\": invoke_vi,\\n  \\\"memory\\\": wasmMemory,\\n  \\\"i\\\": _round,\\n  \\\"l\\\": _saveSetjmp,\\n  \\\"j\\\": _setTempRet0,\\n  \\\"s\\\": _strftime_l,\\n  \\\"table\\\": wasmTable,\\n  \\\"e\\\": _testSetjmp\\n};\\nvar asm = createWasm();\\nModule[\\\"asm\\\"] = asm;\\n\\nvar ___wasm_call_ctors = Module[\\\"___wasm_call_ctors\\\"] = function () {\\n  return (___wasm_call_ctors = Module[\\\"___wasm_call_ctors\\\"] = Module[\\\"asm\\\"][\\\"C\\\"]).apply(null, arguments);\\n};\\n\\nvar _lottie_init = Module[\\\"_lottie_init\\\"] = function () {\\n  return (_lottie_init = Module[\\\"_lottie_init\\\"] = Module[\\\"asm\\\"][\\\"D\\\"]).apply(null, arguments);\\n};\\n\\nvar _lottie_resize = Module[\\\"_lottie_resize\\\"] = function () {\\n  return (_lottie_resize = Module[\\\"_lottie_resize\\\"] = Module[\\\"asm\\\"][\\\"E\\\"]).apply(null, arguments);\\n};\\n\\nvar _free = Module[\\\"_free\\\"] = function () {\\n  return (_free = Module[\\\"_free\\\"] = Module[\\\"asm\\\"][\\\"F\\\"]).apply(null, arguments);\\n};\\n\\nvar _lottie_load_from_data = Module[\\\"_lottie_load_from_data\\\"] = function () {\\n  return (_lottie_load_from_data = Module[\\\"_lottie_load_from_data\\\"] = Module[\\\"asm\\\"][\\\"G\\\"]).apply(null, arguments);\\n};\\n\\nvar _lottie_buffer = Module[\\\"_lottie_buffer\\\"] = function () {\\n  return (_lottie_buffer = Module[\\\"_lottie_buffer\\\"] = Module[\\\"asm\\\"][\\\"H\\\"]).apply(null, arguments);\\n};\\n\\nvar _lottie_destroy = Module[\\\"_lottie_destroy\\\"] = function () {\\n  return (_lottie_destroy = Module[\\\"_lottie_destroy\\\"] = Module[\\\"asm\\\"][\\\"I\\\"]).apply(null, arguments);\\n};\\n\\nvar _lottie_render = Module[\\\"_lottie_render\\\"] = function () {\\n  return (_lottie_render = Module[\\\"_lottie_render\\\"] = Module[\\\"asm\\\"][\\\"J\\\"]).apply(null, arguments);\\n};\\n\\nvar _malloc = Module[\\\"_malloc\\\"] = function () {\\n  return (_malloc = Module[\\\"_malloc\\\"] = Module[\\\"asm\\\"][\\\"K\\\"]).apply(null, arguments);\\n};\\n\\nvar _realloc = Module[\\\"_realloc\\\"] = function () {\\n  return (_realloc = Module[\\\"_realloc\\\"] = Module[\\\"asm\\\"][\\\"L\\\"]).apply(null, arguments);\\n};\\n\\nvar ___errno_location = Module[\\\"___errno_location\\\"] = function () {\\n  return (___errno_location = Module[\\\"___errno_location\\\"] = Module[\\\"asm\\\"][\\\"M\\\"]).apply(null, arguments);\\n};\\n\\nvar _setThrew = Module[\\\"_setThrew\\\"] = function () {\\n  return (_setThrew = Module[\\\"_setThrew\\\"] = Module[\\\"asm\\\"][\\\"N\\\"]).apply(null, arguments);\\n};\\n\\nvar dynCall_vi = Module[\\\"dynCall_vi\\\"] = function () {\\n  return (dynCall_vi = Module[\\\"dynCall_vi\\\"] = Module[\\\"asm\\\"][\\\"O\\\"]).apply(null, arguments);\\n};\\n\\nvar dynCall_iii = Module[\\\"dynCall_iii\\\"] = function () {\\n  return (dynCall_iii = Module[\\\"dynCall_iii\\\"] = Module[\\\"asm\\\"][\\\"P\\\"]).apply(null, arguments);\\n};\\n\\nvar stackSave = Module[\\\"stackSave\\\"] = function () {\\n  return (stackSave = Module[\\\"stackSave\\\"] = Module[\\\"asm\\\"][\\\"Q\\\"]).apply(null, arguments);\\n};\\n\\nvar stackAlloc = Module[\\\"stackAlloc\\\"] = function () {\\n  return (stackAlloc = Module[\\\"stackAlloc\\\"] = Module[\\\"asm\\\"][\\\"R\\\"]).apply(null, arguments);\\n};\\n\\nvar stackRestore = Module[\\\"stackRestore\\\"] = function () {\\n  return (stackRestore = Module[\\\"stackRestore\\\"] = Module[\\\"asm\\\"][\\\"S\\\"]).apply(null, arguments);\\n};\\n\\nvar dynCall_v = Module[\\\"dynCall_v\\\"] = function () {\\n  return (dynCall_v = Module[\\\"dynCall_v\\\"] = Module[\\\"asm\\\"][\\\"T\\\"]).apply(null, arguments);\\n};\\n\\nfunction invoke_iii(index, a1, a2) {\\n  var sp = stackSave();\\n\\n  try {\\n    return dynCall_iii(index, a1, a2);\\n  } catch (e) {\\n    stackRestore(sp);\\n    if (e !== e + 0 && e !== \\\"longjmp\\\") throw e;\\n\\n    _setThrew(1, 0);\\n  }\\n}\\n\\nfunction invoke_vi(index, a1) {\\n  var sp = stackSave();\\n\\n  try {\\n    dynCall_vi(index, a1);\\n  } catch (e) {\\n    stackRestore(sp);\\n    if (e !== e + 0 && e !== \\\"longjmp\\\") throw e;\\n\\n    _setThrew(1, 0);\\n  }\\n}\\n\\nModule[\\\"asm\\\"] = asm;\\nModule[\\\"intArrayFromString\\\"] = intArrayFromString;\\nModule[\\\"cwrap\\\"] = cwrap;\\nModule[\\\"allocate\\\"] = allocate;\\nvar calledRun;\\n\\nfunction ExitStatus(status) {\\n  this.name = \\\"ExitStatus\\\";\\n  this.message = \\\"Program terminated with exit(\\\" + status + \\\")\\\";\\n  this.status = status;\\n}\\n\\ndependenciesFulfilled = function runCaller() {\\n  if (!calledRun) run();\\n  if (!calledRun) dependenciesFulfilled = runCaller;\\n};\\n\\nfunction run(args) {\\n  args = args || arguments_;\\n\\n  if (runDependencies > 0) {\\n    return;\\n  }\\n\\n  preRun();\\n  if (runDependencies > 0) return;\\n\\n  function doRun() {\\n    if (calledRun) return;\\n    calledRun = true;\\n    Module[\\\"calledRun\\\"] = true;\\n    if (ABORT) return;\\n    initRuntime();\\n    preMain();\\n    if (Module[\\\"onRuntimeInitialized\\\"]) Module[\\\"onRuntimeInitialized\\\"]();\\n    postRun();\\n  }\\n\\n  if (Module[\\\"setStatus\\\"]) {\\n    Module[\\\"setStatus\\\"](\\\"Running...\\\");\\n    setTimeout(function () {\\n      setTimeout(function () {\\n        Module[\\\"setStatus\\\"](\\\"\\\");\\n      }, 1);\\n      doRun();\\n    }, 1);\\n  } else {\\n    doRun();\\n  }\\n}\\n\\nModule[\\\"run\\\"] = run;\\n\\nif (Module[\\\"preInit\\\"]) {\\n  if (typeof Module[\\\"preInit\\\"] == \\\"function\\\") Module[\\\"preInit\\\"] = [Module[\\\"preInit\\\"]];\\n\\n  while (Module[\\\"preInit\\\"].length > 0) {\\n    Module[\\\"preInit\\\"].pop()();\\n  }\\n}\\n\\nnoExitRuntime = true;\\nrun();\"","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n","require(\"!!/Users/alexander/dev/telegram-tt/node_modules/script-loader/addScript.js\")(require(\"!!/Users/alexander/dev/telegram-tt/node_modules/raw-loader/index.js!/Users/alexander/dev/telegram-tt/node_modules/babel-loader/lib/index.js!/Users/alexander/dev/telegram-tt/src/lib/rlottie/rlottie-wasm.js\"))","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [5802], () => (__webpack_require__(52993)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + \"5a998479cf43543543ff\" + \".js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t2993: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunktelegram_t\"] = self[\"webpackChunktelegram_t\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","window","innerHeight","Math","round","Set","SUPPORTED_IMAGE_CONTENT_TYPES","SUPPORTED_VIDEO_CONTENT_TYPES","self","onerror","e","console","error","sendToOrigin","type","message","addEventListener","reason","callbackState","Map","isTransferable","obj","ArrayBuffer","ImageBitmap","data","transferables","postMessage","rLottieApi","rLottieApiPromise","Promise","resolve","Module","onRuntimeInitialized","init","cwrap","destroy","resize","buffer","render","loadFromData","renderers","async","extractJson","tgsUrl","response","fetch","contentType","headers","get","startsWith","text","arrayBuffer","inflate","to","calcParams","json","isLowPriority","framesCount","maxFps","sourceFps","JSON","parse","fr","reduceFactor","msPerFrame","reducedFramesCount","ceil","api","key","imgSize","customColor","onInit","stringOnWasmHeap","allocate","intArrayFromString","handle","imageData","ImageData","set","changeData","renderFrames","frameIndex","onProgress","realIndex","bufferPointer","HEAPU8","subarray","arr","Uint8ClampedArray","color","i","length","applyColor","createImageBitmap","isRepeated","renderer","delete","err","setTimeout","onmessage","messageId","name","args","withCallback","callback","callbackArgs","lastArg","undefined","push","arrayBuffers","isCanceled","module","exports","src","log","execScript","attachEvent","eval","call","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","m","x","__webpack_exports__","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","splice","r","f","chunkId","all","reduce","promises","u","miniCssF","g","globalThis","this","Function","o","prop","prototype","hasOwnProperty","scriptUrl","importScripts","location","document","currentScript","scripts","getElementsByTagName","Error","replace","p","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","then"],"sourceRoot":""}