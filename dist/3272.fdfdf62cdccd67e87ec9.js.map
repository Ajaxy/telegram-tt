{"version":3,"file":"3272.fdfdf62cdccd67e87ec9.js","mappings":"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","sources":["webpack://telegram-t/./node_modules/music-metadata/lib/mp4/AtomToken.js","webpack://telegram-t/./node_modules/music-metadata/lib/mp4/Atom.js","webpack://telegram-t/./node_modules/music-metadata/lib/mp4/MP4Parser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport initDebug from 'debug';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:MP4:atom');\nexport class Mp4ContentError extends makeUnexpectedFileContentError('MP4') {\n}\nexport const Header = {\n    len: 8,\n    get: (buf, off) => {\n        const length = Token.UINT32_BE.get(buf, off);\n        if (length < 0)\n            throw new Mp4ContentError('Invalid atom header length');\n        return {\n            length: BigInt(length),\n            name: new Token.StringType(4, 'latin1').get(buf, off + 4)\n        };\n    },\n    put: (buf, off, hdr) => {\n        Token.UINT32_BE.put(buf, off, Number(hdr.length));\n        return FourCcToken.put(buf, off + 4, hdr.name);\n    }\n};\n/**\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap1/qtff1.html#//apple_ref/doc/uid/TP40000939-CH203-38190\n */\nexport const ExtendedSize = Token.UINT64_BE;\nexport const ftyp = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            type: new Token.StringType(4, 'ascii').get(buf, off)\n        };\n    }\n};\nexport const tkhd = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            type: new Token.StringType(4, 'ascii').get(buf, off)\n        };\n    }\n};\n/**\n * Token: Movie Header Atom\n */\nexport const mhdr = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            nextItemID: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Base class for 'fixed' length atoms.\n * In some cases these atoms are longer then the sum of the described fields.\n * Issue: https://github.com/Borewit/music-metadata/issues/120\n */\nexport class FixedLengthAtom {\n    /**\n     *\n     * @param {number} len Length as specified in the size field\n     * @param {number} expLen Total length of sum of specified fields in the standard\n     * @param atomId Atom ID\n     */\n    constructor(len, expLen, atomId) {\n        if (len < expLen) {\n            throw new Mp4ContentError(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);\n        }\n        if (len > expLen) {\n            debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);\n        }\n        this.len = len;\n    }\n}\n/**\n * Timestamp stored in seconds since Mac Epoch (1 January 1904)\n */\nconst SecondsSinceMacEpoch = {\n    len: 4,\n    get: (buf, off) => {\n        const secondsSinceUnixEpoch = Token.UINT32_BE.get(buf, off) - 2082844800;\n        return new Date(secondsSinceUnixEpoch * 1000);\n    }\n};\n/**\n * Token: Media Header Atom\n * Ref:\n * - https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW34\n * - https://wiki.multimedia.cx/index.php/QuickTime_container#mdhd\n */\nexport class MdhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 24, 'mdhd');\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off + 0),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            language: Token.UINT16_BE.get(buf, off + 20),\n            quality: Token.UINT16_BE.get(buf, off + 22)\n        };\n    }\n}\n/**\n * Token: Movie Header Atom\n */\nexport class MvhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 100, 'mvhd');\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            preferredRate: Token.UINT32_BE.get(buf, off + 20),\n            preferredVolume: Token.UINT16_BE.get(buf, off + 24),\n            // ignore reserver: 10 bytes\n            // ignore matrix structure: 36 bytes\n            previewTime: Token.UINT32_BE.get(buf, off + 72),\n            previewDuration: Token.UINT32_BE.get(buf, off + 76),\n            posterTime: Token.UINT32_BE.get(buf, off + 80),\n            selectionTime: Token.UINT32_BE.get(buf, off + 84),\n            selectionDuration: Token.UINT32_BE.get(buf, off + 88),\n            currentTime: Token.UINT32_BE.get(buf, off + 92),\n            nextTrackID: Token.UINT32_BE.get(buf, off + 96)\n        };\n    }\n}\n/**\n * Data Atom Structure\n */\nexport class DataAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            type: {\n                set: Token.UINT8.get(buf, off + 0),\n                type: Token.UINT24_BE.get(buf, off + 1)\n            },\n            locale: Token.UINT24_BE.get(buf, off + 4),\n            value: new Token.Uint8ArrayType(this.len - 8).get(buf, off + 8)\n        };\n    }\n}\n/**\n * Data Atom Structure\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31\n */\nexport class NameAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            name: new Token.StringType(this.len - 4, 'utf-8').get(buf, off + 4)\n        };\n    }\n}\n/**\n * Track Header Atoms structure\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25550\n */\nexport class TrackHeaderAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            trackId: Token.UINT32_BE.get(buf, off + 12),\n            // reserved 4 bytes\n            duration: Token.UINT32_BE.get(buf, off + 20),\n            layer: Token.UINT16_BE.get(buf, off + 24),\n            alternateGroup: Token.UINT16_BE.get(buf, off + 26),\n            volume: Token.UINT16_BE.get(buf, off + 28) // ToDo: fixed point\n            // ToDo: add remaining fields\n        };\n    }\n}\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nconst stsdHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            numberOfEntries: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/documentation/quicktime-file-format/sample_description_atom\n */\nclass SampleDescriptionTable {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const descrLen = this.len - 12;\n        return {\n            dataFormat: FourCcToken.get(buf, off),\n            dataReferenceIndex: Token.UINT16_BE.get(buf, off + 10),\n            description: descrLen > 0 ? new Token.Uint8ArrayType(descrLen).get(buf, off + 12) : undefined\n        };\n    }\n}\n/**\n * Atom: Sample-description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nexport class StsdAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const header = stsdHeader.get(buf, off);\n        off += stsdHeader.len;\n        const table = [];\n        for (let n = 0; n < header.numberOfEntries; ++n) {\n            const size = Token.UINT32_BE.get(buf, off); // Sample description size\n            off += Token.UINT32_BE.len;\n            table.push(new SampleDescriptionTable(size - Token.UINT32_BE.len).get(buf, off));\n            off += size;\n        }\n        return {\n            header,\n            table\n        };\n    }\n}\n/**\n * Common Sound Sample Description (version & revision)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-57317\n */\nexport const SoundSampleDescriptionVersion = {\n    len: 8,\n    get(buf, off) {\n        return {\n            version: Token.INT16_BE.get(buf, off),\n            revision: Token.INT16_BE.get(buf, off + 2),\n            vendor: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Sound Sample Description (Version 0)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-130736\n */\nexport const SoundSampleDescriptionV0 = {\n    len: 12,\n    get(buf, off) {\n        return {\n            numAudioChannels: Token.INT16_BE.get(buf, off + 0),\n            sampleSize: Token.INT16_BE.get(buf, off + 2),\n            compressionId: Token.INT16_BE.get(buf, off + 4),\n            packetSize: Token.INT16_BE.get(buf, off + 6),\n            sampleRate: Token.UINT16_BE.get(buf, off + 8) + Token.UINT16_BE.get(buf, off + 10) / 10000\n        };\n    }\n};\nclass SimpleTableAtom {\n    constructor(len, token) {\n        this.len = len;\n        this.token = token;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 4);\n        return {\n            version: Token.INT8.get(buf, off + 0),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)\n        };\n    }\n}\nexport const TimeToSampleToken = {\n    len: 8,\n    get(buf, off) {\n        return {\n            count: Token.INT32_BE.get(buf, off + 0),\n            duration: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Time-to-sample('stts') atom.\n * Store duration information for a media’s samples.\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25696\n */\nexport class SttsAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, TimeToSampleToken);\n    }\n}\nexport const SampleToChunkToken = {\n    len: 12,\n    get(buf, off) {\n        return {\n            firstChunk: Token.INT32_BE.get(buf, off),\n            samplesPerChunk: Token.INT32_BE.get(buf, off + 4),\n            sampleDescriptionId: Token.INT32_BE.get(buf, off + 8)\n        };\n    }\n};\n/**\n * Sample-to-Chunk ('stsc') atom interface\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706\n */\nexport class StscAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, SampleToChunkToken);\n    }\n}\n/**\n * Sample-size ('stsz') atom\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25710\n */\nexport class StszAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 8);\n        return {\n            version: Token.INT8.get(buf, off),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            sampleSize: Token.INT32_BE.get(buf, off + 4),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, Token.INT32_BE, off + 12, this.len - 12, nrOfEntries)\n        };\n    }\n}\n/**\n * Chunk offset atom, 'stco'\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25715\n */\nexport class StcoAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, Token.INT32_BE);\n        this.len = len;\n    }\n}\n/**\n * Token used to decode text-track from 'mdat' atom (raw data stream)\n */\nexport class ChapterText {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const titleLen = Token.INT16_BE.get(buf, off + 0);\n        const str = new Token.StringType(titleLen, 'utf-8');\n        return str.get(buf, off + 2);\n    }\n}\nfunction readTokenTable(buf, token, off, remainingLen, numberOfEntries) {\n    debug(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);\n    if (remainingLen === 0)\n        return [];\n    if (remainingLen !== numberOfEntries * token.len)\n        throw new Mp4ContentError('mismatch number-of-entries with remaining atom-length');\n    const entries = [];\n    // parse offset-table\n    for (let n = 0; n < numberOfEntries; ++n) {\n        entries.push(token.get(buf, off));\n        off += token.len;\n    }\n    return entries;\n}\n//# sourceMappingURL=AtomToken.js.map","import initDebug from 'debug';\nimport * as AtomToken from './AtomToken.js';\nimport { Header } from './AtomToken.js';\nconst debug = initDebug('music-metadata:parser:MP4:Atom');\nexport class Atom {\n    static async readAtom(tokenizer, dataHandler, parent, remaining) {\n        // Parse atom header\n        const offset = tokenizer.position;\n        debug(`Reading next token on offset=${offset}...`); //  buf.toString('ascii')\n        const header = await tokenizer.readToken(AtomToken.Header);\n        const extended = header.length === 1n;\n        if (extended) {\n            header.length = await tokenizer.readToken(AtomToken.ExtendedSize);\n        }\n        const atomBean = new Atom(header, extended, parent);\n        const payloadLength = atomBean.getPayloadLength(remaining);\n        debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`); //  buf.toString('ascii')\n        await atomBean.readData(tokenizer, dataHandler, payloadLength);\n        return atomBean;\n    }\n    constructor(header, extended, parent) {\n        this.header = header;\n        this.extended = extended;\n        this.parent = parent;\n        this.children = [];\n        this.atomPath = (this.parent ? `${this.parent.atomPath}.` : '') + this.header.name;\n    }\n    getHeaderLength() {\n        return this.extended ? 16 : 8;\n    }\n    getPayloadLength(remaining) {\n        return (this.header.length === 0n ? remaining : Number(this.header.length)) - this.getHeaderLength();\n    }\n    async readAtoms(tokenizer, dataHandler, size) {\n        while (size > 0) {\n            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);\n            this.children.push(atomBean);\n            size -= atomBean.header.length === 0n ? size : Number(atomBean.header.length);\n        }\n    }\n    async readData(tokenizer, dataHandler, remaining) {\n        switch (this.header.name) {\n            // \"Container\" atoms, contains nested atoms\n            case 'moov': // The Movie Atom: contains other atoms\n            case 'udta': // User defined atom\n            case 'trak':\n            case 'mdia': // Media atom\n            case 'minf': // Media Information Atom\n            case 'stbl': // The Sample Table Atom\n            case '<id>':\n            case 'ilst':\n            case 'tref':\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));\n            case 'meta': { // Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n                // meta has 4 bytes of padding, ignore\n                const peekHeader = await tokenizer.peekToken(Header);\n                const paddingLength = peekHeader.name === 'hdlr' ? 0 : 4;\n                await tokenizer.ignore(paddingLength);\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);\n            }\n            default:\n                return dataHandler(this, remaining);\n        }\n    }\n}\n//# sourceMappingURL=Atom.js.map","import initDebug from 'debug';\nimport * as Token from 'token-types';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { Genres } from '../id3v1/ID3v1Parser.js';\nimport { Atom } from './Atom.js';\nimport * as AtomToken from './AtomToken.js';\nimport { Mp4ContentError } from './AtomToken.js';\nimport { TrackType } from '../type.js';\nimport { uint8ArrayToHex, uint8ArrayToString } from 'uint8array-extras';\nconst debug = initDebug('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n    raw: {\n        lossy: false,\n        format: 'raw'\n    },\n    MAC3: {\n        lossy: true,\n        format: 'MACE 3:1'\n    },\n    MAC6: {\n        lossy: true,\n        format: 'MACE 6:1'\n    },\n    ima4: {\n        lossy: true,\n        format: 'IMA 4:1'\n    },\n    ulaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    alaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    Qclp: {\n        lossy: true,\n        format: 'QUALCOMM PureVoice'\n    },\n    '.mp3': {\n        lossy: true,\n        format: 'MPEG-1 layer 3'\n    },\n    alac: {\n        lossy: false,\n        format: 'ALAC'\n    },\n    'ac-3': {\n        lossy: true,\n        format: 'AC-3'\n    },\n    mp4a: {\n        lossy: true,\n        format: 'MPEG-4/AAC'\n    },\n    mp4s: {\n        lossy: true,\n        format: 'MP4S'\n    },\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n    c608: {\n        lossy: true,\n        format: 'CEA-608'\n    },\n    c708: {\n        lossy: true,\n        format: 'CEA-708'\n    }\n};\nfunction distinct(value, index, self) {\n    return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nexport class MP4Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.tracks = [];\n        this.atomParsers = {\n            /**\n             * Parse movie header (mvhd) atom\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n             */\n            mvhd: async (len) => {\n                const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n                this.metadata.setFormat('creationTime', mvhd.creationTime);\n                this.metadata.setFormat('modificationTime', mvhd.modificationTime);\n            },\n            /**\n             * Parse media header (mdhd) atom\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\n             */\n            mdhd: async (len) => {\n                const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len));\n                // this.parse_mxhd(mdhd_data, this.currentTrack);\n                const td = this.getTrackDescription();\n                td.creationTime = mdhd_data.creationTime;\n                td.modificationTime = mdhd_data.modificationTime;\n                td.timeScale = mdhd_data.timeScale;\n                td.duration = mdhd_data.duration;\n            },\n            chap: async (len) => {\n                const td = this.getTrackDescription();\n                const trackIds = [];\n                while (len >= Token.UINT32_BE.len) {\n                    trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n                    len -= Token.UINT32_BE.len;\n                }\n                td.chapterList = trackIds;\n            },\n            tkhd: async (len) => {\n                const track = (await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len)));\n                this.tracks.push(track);\n            },\n            /**\n             * Parse mdat atom.\n             * Will scan for chapters\n             */\n            mdat: async (len) => {\n                this.audioLengthInBytes = len;\n                this.calculateBitRate();\n                if (this.options.includeChapters) {\n                    const trackWithChapters = this.tracks.filter(track => track.chapterList);\n                    if (trackWithChapters.length === 1) {\n                        const chapterTrackIds = trackWithChapters[0].chapterList;\n                        const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\n                        if (chapterTracks.length === 1) {\n                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n                        }\n                    }\n                }\n                await this.tokenizer.ignore(len);\n            },\n            ftyp: async (len) => {\n                const types = [];\n                while (len > 0) {\n                    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n                    len -= AtomToken.ftyp.len;\n                    const value = ftype.type.replace(/\\W/g, '');\n                    if (value.length > 0) {\n                        types.push(value); // unshift for backward compatibility\n                    }\n                }\n                debug(`ftyp: ${types.join('/')}`);\n                const x = types.filter(distinct).join('/');\n                this.metadata.setFormat('container', x);\n            },\n            /**\n             * Parse sample description atom\n             */\n            stsd: async (len) => {\n                const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n                const trackDescription = this.getTrackDescription();\n                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n            },\n            /**\n             * sample-to-Chunk Atoms\n             */\n            stsc: async (len) => {\n                const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\n                this.getTrackDescription().sampleToChunkTable = stsc.entries;\n            },\n            /**\n             * time-to-sample table\n             */\n            stts: async (len) => {\n                const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n                this.getTrackDescription().timeToSampleTable = stts.entries;\n            },\n            /**\n             * Parse sample-sizes atom ('stsz')\n             */\n            stsz: async (len) => {\n                const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n                const td = this.getTrackDescription();\n                td.sampleSize = stsz.sampleSize;\n                td.sampleSizeTable = stsz.entries;\n            },\n            /**\n             * Parse chunk-offset atom ('stco')\n             */\n            stco: async (len) => {\n                const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n                this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n            },\n            date: async (len) => {\n                const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n                await this.addTag('date', date);\n            }\n        };\n    }\n    static read_BE_Integer(array, signed) {\n        const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\n        const token = Token[integerType];\n        if (!token) {\n            throw new Mp4ContentError(`Token for integer type not found: \"${integerType}\"`);\n        }\n        return Number(token.get(array, 0));\n    }\n    async parse() {\n        this.tracks = [];\n        let remainingFileSize = this.tokenizer.fileInfo.size || 0;\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n            try {\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\n                if (token.name === '\\0\\0\\0\\0') {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                    break;\n                }\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                }\n                else\n                    throw error;\n                break;\n            }\n            const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\n        }\n        // Post process metadata\n        const formatList = [];\n        this.tracks.forEach(track => {\n            const trackFormats = [];\n            track.soundSampleDescription.forEach(ssd => {\n                const streamInfo = {};\n                const encoderInfo = encoderDict[ssd.dataFormat];\n                if (encoderInfo) {\n                    trackFormats.push(encoderInfo.format);\n                    streamInfo.codecName = encoderInfo.format;\n                }\n                else {\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\n                }\n                if (ssd.description) {\n                    const { description } = ssd;\n                    if (description.sampleRate > 0) {\n                        streamInfo.type = TrackType.audio;\n                        streamInfo.audio = {\n                            samplingFrequency: description.sampleRate,\n                            bitDepth: description.sampleSize,\n                            channels: description.numAudioChannels\n                        };\n                    }\n                }\n                this.metadata.addStreamInfo(streamInfo);\n            });\n            if (trackFormats.length >= 1) {\n                formatList.push(trackFormats.join('/'));\n            }\n        });\n        if (formatList.length > 0) {\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n        }\n        const audioTracks = this.tracks.filter(track => {\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n        });\n        if (audioTracks.length >= 1) {\n            const audioTrack = audioTracks[0];\n            if (audioTrack.timeScale > 0) {\n                const duration = audioTrack.duration / audioTrack.timeScale; // calculate duration in seconds\n                this.metadata.setFormat('duration', duration);\n            }\n            const ssd = audioTrack.soundSampleDescription[0];\n            if (ssd.description) {\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n                if (audioTrack.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\n                    const totalSampleSize = audioTrack.timeToSampleTable\n                        .map(ttstEntry => ttstEntry.count * ttstEntry.duration)\n                        .reduce((total, sampleSize) => total + sampleSize);\n                    const duration = totalSampleSize / ssd.description.sampleRate;\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            const encoderInfo = encoderDict[ssd.dataFormat];\n            if (encoderInfo) {\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\n            }\n            this.calculateBitRate();\n        }\n    }\n    async handleAtom(atom, remaining) {\n        if (atom.parent) {\n            switch (atom.parent.header.name) {\n                case 'ilst':\n                case '<id>':\n                    return this.parseMetadataItemData(atom);\n            }\n        }\n        // const payloadLength = atom.getPayloadLength(remaining);\n        if (this.atomParsers[atom.header.name]) {\n            return this.atomParsers[atom.header.name](remaining);\n        }\n        debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\n        await this.tokenizer.ignore(remaining);\n    }\n    getTrackDescription() {\n        return this.tracks[this.tracks.length - 1];\n    }\n    calculateBitRate() {\n        if (this.audioLengthInBytes && this.metadata.format.duration) {\n            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n        }\n    }\n    async addTag(id, value) {\n        await this.metadata.addTag(tagFormat, id, value);\n    }\n    addWarning(message) {\n        debug(`Warning: ${message}`);\n        this.metadata.addWarning(message);\n    }\n    /**\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n     * @param metaAtom\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n     */\n    parseMetadataItemData(metaAtom) {\n        let tagKey = metaAtom.header.name;\n        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'data': // value atom\n                    return this.parseValueAtom(tagKey, child);\n                case 'name': // name atom (optional)\n                case 'mean':\n                case 'rate': {\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n                    tagKey += `:${name.name}`;\n                    break;\n                }\n                default: {\n                    const uint8Array = await this.tokenizer.readToken(new Token.Uint8ArrayType(payLoadLength));\n                    this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${uint8ArrayToString(uint8Array, 'ascii')}`);\n                }\n            }\n        }, metaAtom.getPayloadLength(0));\n    }\n    async parseValueAtom(tagKey, metaAtom) {\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\n        if (dataAtom.type.set !== 0) {\n            throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);\n        }\n        // Use well-known-type table\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n        switch (dataAtom.type.type) {\n            case 0: // reserved: Reserved for use where no type needs to be indicated\n                switch (tagKey) {\n                    case 'trkn':\n                    case 'disk': {\n                        const num = Token.UINT8.get(dataAtom.value, 3);\n                        const of = Token.UINT8.get(dataAtom.value, 5);\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n                        await this.addTag(tagKey, `${num}/${of}`);\n                        break;\n                    }\n                    case 'gnre': {\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\n                        const genreStr = Genres[genreInt - 1];\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n                        await this.addTag(tagKey, genreStr);\n                        break;\n                    }\n                    case 'rate': {\n                        const rate = new TextDecoder('ascii').decode(dataAtom.value);\n                        await this.addTag(tagKey, rate);\n                        break;\n                    }\n                    default:\n                        debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);\n                }\n                break;\n            case 1: // UTF-8: Without any count or NULL terminator\n            case 18: // Unknown: Found in m4b in combination with a '©gen' tag\n                await this.addTag(tagKey, new TextDecoder('utf-8').decode(dataAtom.value));\n                break;\n            case 13: // JPEG\n                if (this.options.skipCovers)\n                    break;\n                await this.addTag(tagKey, {\n                    format: 'image/jpeg',\n                    data: Uint8Array.from(dataAtom.value)\n                });\n                break;\n            case 14: // PNG\n                if (this.options.skipCovers)\n                    break;\n                await this.addTag(tagKey, {\n                    format: 'image/png',\n                    data: Uint8Array.from(dataAtom.value)\n                });\n                break;\n            case 21: // BE Signed Integer\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\n                break;\n            case 22: // BE Unsigned Integer\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\n                break;\n            case 65: // An 8-bit signed integer\n                await this.addTag(tagKey, Token.UINT8.get(dataAtom.value, 0));\n                break;\n            case 66: // A big-endian 16-bit signed integer\n                await this.addTag(tagKey, Token.UINT16_BE.get(dataAtom.value, 0));\n                break;\n            case 67: // A big-endian 32-bit signed integer\n                await this.addTag(tagKey, Token.UINT32_BE.get(dataAtom.value, 0));\n                break;\n            default:\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n        }\n    }\n    /**\n     * @param sampleDescription\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n     */\n    parseSoundSampleDescription(sampleDescription) {\n        const ssd = {\n            dataFormat: sampleDescription.dataFormat,\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\n        };\n        let offset = 0;\n        if (sampleDescription.description) {\n            const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n            offset += AtomToken.SoundSampleDescriptionVersion.len;\n            if (version.version === 0 || version.version === 1) {\n                // Sound Sample Description (Version 0)\n                ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n            }\n            else {\n                debug(`Warning: sound-sample-description ${version} not implemented`);\n            }\n        }\n        return ssd;\n    }\n    async parseChapterTrack(chapterTrack, track, len) {\n        if (!chapterTrack.sampleSize) {\n            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n        }\n        const chapters = [];\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n            const start = chapterTrack.timeToSampleTable\n                .slice(0, i)\n                .reduce((acc, cur) => acc + cur.duration, 0);\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n            len -= nextChunkLen + sampleSize;\n            if (len < 0)\n                throw new Mp4ContentError('Chapter chunk exceeding token length');\n            await this.tokenizer.ignore(nextChunkLen);\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n            debug(`Chapter ${i + 1}: ${title}`);\n            const chapter = {\n                title,\n                timeScale: chapterTrack.timeScale,\n                start,\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n            };\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\n            chapters.push(chapter);\n        }\n        this.metadata.setFormat('chapters', chapters);\n        await this.tokenizer.ignore(len);\n    }\n    findSampleOffset(track, chapterOffset) {\n        let totalDuration = 0;\n        track.timeToSampleTable.forEach(e => {\n            totalDuration += e.count * e.duration;\n        });\n        debug(`Total duration=${totalDuration}`);\n        let chunkIndex = 0;\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n            ++chunkIndex;\n        }\n        return this.getChunkDuration(chunkIndex + 1, track);\n    }\n    getChunkDuration(chunkId, track) {\n        let ttsi = 0;\n        let ttsc = track.timeToSampleTable[ttsi].count;\n        let ttsd = track.timeToSampleTable[ttsi].duration;\n        let curChunkId = 1;\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n        let totalDuration = 0;\n        while (curChunkId < chunkId) {\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n            totalDuration += nrOfSamples * ttsd;\n            ttsc -= nrOfSamples;\n            samplesPerChunk -= nrOfSamples;\n            if (samplesPerChunk === 0) {\n                ++curChunkId;\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n            }\n            else {\n                ++ttsi;\n                ttsc = track.timeToSampleTable[ttsi].count;\n                ttsd = track.timeToSampleTable[ttsi].duration;\n            }\n        }\n        return totalDuration;\n    }\n    getSamplesPerChunk(chunkId, stcTable) {\n        for (let i = 0; i < stcTable.length - 1; ++i) {\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n                return stcTable[i].samplesPerChunk;\n            }\n        }\n        return stcTable[stcTable.length - 1].samplesPerChunk;\n    }\n}\n//# sourceMappingURL=MP4Parser.js.map"],"names":["debug","Mp4ContentError","Header","len","get","buf","off","length","BigInt","name","put","hdr","Number","ExtendedSize","ftyp","type","FixedLengthAtom","constructor","expLen","atomId","this","SecondsSinceMacEpoch","secondsSinceUnixEpoch","Date","MdhdAtom","super","version","flags","creationTime","modificationTime","timeScale","duration","language","quality","MvhdAtom","preferredRate","preferredVolume","previewTime","previewDuration","posterTime","selectionTime","selectionDuration","currentTime","nextTrackID","DataAtom","set","locale","value","NameAtom","TrackHeaderAtom","trackId","layer","alternateGroup","volume","SampleDescriptionTable","descrLen","dataFormat","dataReferenceIndex","description","undefined","StsdAtom","header","numberOfEntries","stsdHeader","table","n","size","push","SoundSampleDescriptionVersion","revision","vendor","SoundSampleDescriptionV0","numAudioChannels","sampleSize","compressionId","packetSize","sampleRate","SimpleTableAtom","token","nrOfEntries","entries","readTokenTable","TimeToSampleToken","count","SttsAtom","SampleToChunkToken","firstChunk","samplesPerChunk","sampleDescriptionId","StscAtom","StszAtom","StcoAtom","ChapterText","titleLen","remainingLen","Atom","readAtom","tokenizer","dataHandler","parent","remaining","offset","position","readToken","extended","atomBean","payloadLength","getPayloadLength","atomPath","readData","children","getHeaderLength","readAtoms","paddingLength","peekToken","ignore","encoderDict","raw","lossy","format","MAC3","MAC6","ima4","ulaw","alaw","Qclp","alac","mp4a","mp4s","c608","c708","distinct","index","self","indexOf","MP4Parser","BasicParser","arguments","tracks","atomParsers","mvhd","async","metadata","setFormat","mdhd","mdhd_data","td","getTrackDescription","chap","trackIds","readNumber","chapterList","tkhd","track","mdat","audioLengthInBytes","calculateBitRate","options","includeChapters","trackWithChapters","filter","chapterTrackIds","chapterTracks","parseChapterTrack","types","ftype","replace","join","x","stsd","soundSampleDescription","map","dfEntry","parseSoundSampleDescription","stsc","sampleToChunkTable","stts","timeToSampleTable","stsz","sampleSizeTable","stco","chunkOffsetTable","date","addTag","read_BE_Integer","array","signed","integerType","parse","remainingFileSize","fileInfo","errMsg","addWarning","error","Error","message","rootAtom","atom","handleAtom","formatList","forEach","trackFormats","ssd","streamInfo","encoderInfo","codecName","audio","samplingFrequency","bitDepth","channels","addStreamInfo","audioTracks","audioTrack","ttstEntry","reduce","total","parseMetadataItemData","id","metaAtom","tagKey","child","payLoadLength","parseValueAtom","uint8Array","dataAtom","num","of","genreInt","genreStr","rate","TextDecoder","decode","skipCovers","data","Uint8Array","from","sampleDescription","chapterTrack","chapters","i","start","slice","acc","cur","nextChunkLen","title","chapter","sampleOffset","findSampleOffset","chapterOffset","totalDuration","e","chunkIndex","getChunkDuration","chunkId","ttsi","ttsc","ttsd","curChunkId","getSamplesPerChunk","nrOfSamples","Math","min","stcTable"],"sourceRoot":""}