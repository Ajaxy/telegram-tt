"use strict";(self.webpackChunktelegram_t=self.webpackChunktelegram_t||[]).push([[7408],{47408:(e,t,a)=>{a.r(t),a.d(t,{DsdiffContentParseError:()=>u,DsdiffParser:()=>d});var n=a(4017),i=a(17833),s=a(10718),r=a(5031),o=a(74604),h=a(78621);const k={len:12,get:(e,t)=>({chunkID:r.e.get(e,t),chunkSize:n.INT64_BE.get(e,t+4)})};var m=a(63324);const c=i("music-metadata:parser:aiff");class u extends((0,m.fO)("DSDIFF")){}class d extends o.s{async parse(){const e=await this.tokenizer.readToken(k);if("FRM8"!==e.chunkID)throw new u("Unexpected chunk-ID");this.metadata.setAudioOnly();const t=(await this.tokenizer.readToken(r.e)).trim();if("DSD"===t)return this.metadata.setFormat("container",`DSDIFF/${t}`),this.metadata.setFormat("lossless",!0),this.readFmt8Chunks(e.chunkSize-BigInt(r.e.len));throw new u(`Unsupported DSDIFF type: ${t}`)}async readFmt8Chunks(e){for(;e>=k.len;){const t=await this.tokenizer.readToken(k);c(`Chunk id=${t.chunkID}`),await this.readData(t),e-=BigInt(k.len)+t.chunkSize}}async readData(e){c(`Reading data of chunk[ID=${e.chunkID}, size=${e.chunkSize}]`);const t=this.tokenizer.position;switch(e.chunkID.trim()){case"FVER":{const e=await this.tokenizer.readToken(n.UINT32_LE);c(`DSDIFF version=${e}`);break}case"PROP":if("SND "!==await this.tokenizer.readToken(r.e))throw new u("Unexpected PROP-chunk ID");await this.handleSoundPropertyChunks(e.chunkSize-BigInt(r.e.len));break;case"ID3":{const t=await this.tokenizer.readToken(new n.Uint8ArrayType(Number(e.chunkSize))),a=s.vY(t);await(new h.S).parse(this.metadata,a,this.options);break}case"DSD":this.metadata.format.numberOfChannels&&this.metadata.setFormat("numberOfSamples",Number(e.chunkSize*BigInt(8)/BigInt(this.metadata.format.numberOfChannels))),this.metadata.format.numberOfSamples&&this.metadata.format.sampleRate&&this.metadata.setFormat("duration",this.metadata.format.numberOfSamples/this.metadata.format.sampleRate);break;default:c(`Ignore chunk[ID=${e.chunkID}, size=${e.chunkSize}]`)}const a=e.chunkSize-BigInt(this.tokenizer.position-t);a>0&&(c(`After Parsing chunk, remaining ${a} bytes`),await this.tokenizer.ignore(Number(a)))}async handleSoundPropertyChunks(e){for(c(`Parsing sound-property-chunks, remainingSize=${e}`);e>0;){const t=await this.tokenizer.readToken(k);c(`Sound-property-chunk[ID=${t.chunkID}, size=${t.chunkSize}]`);const a=this.tokenizer.position;switch(t.chunkID.trim()){case"FS":{const e=await this.tokenizer.readToken(n.UINT32_BE);this.metadata.setFormat("sampleRate",e);break}case"CHNL":{const e=await this.tokenizer.readToken(n.UINT16_BE);this.metadata.setFormat("numberOfChannels",e),await this.handleChannelChunks(t.chunkSize-BigInt(n.UINT16_BE.len));break}case"CMPR":{const e=(await this.tokenizer.readToken(r.e)).trim(),t=await this.tokenizer.readToken(n.UINT8),a=await this.tokenizer.readToken(new n.StringType(t,"ascii"));"DSD"===e&&(this.metadata.setFormat("lossless",!0),this.metadata.setFormat("bitsPerSample",1)),this.metadata.setFormat("codec",`${e} (${a})`);break}case"ABSS":{const e=await this.tokenizer.readToken(n.UINT16_BE),t=await this.tokenizer.readToken(n.UINT8),a=await this.tokenizer.readToken(n.UINT8),i=await this.tokenizer.readToken(n.UINT32_BE);c(`ABSS ${e}:${t}:${a}.${i}`);break}case"LSCO":{const e=await this.tokenizer.readToken(n.UINT16_BE);c(`LSCO lsConfig=${e}`);break}default:c(`Unknown sound-property-chunk[ID=${t.chunkID}, size=${t.chunkSize}]`),await this.tokenizer.ignore(Number(t.chunkSize))}const i=t.chunkSize-BigInt(this.tokenizer.position-a);i>0&&(c(`After Parsing sound-property-chunk ${t.chunkSize}, remaining ${i} bytes`),await this.tokenizer.ignore(Number(i))),e-=BigInt(k.len)+t.chunkSize,c(`Parsing sound-property-chunks, remainingSize=${e}`)}if(this.metadata.format.lossless&&this.metadata.format.sampleRate&&this.metadata.format.numberOfChannels&&this.metadata.format.bitsPerSample){const e=this.metadata.format.sampleRate*this.metadata.format.numberOfChannels*this.metadata.format.bitsPerSample;this.metadata.setFormat("bitrate",e)}}async handleChannelChunks(e){c(`Parsing channel-chunks, remainingSize=${e}`);const t=[];for(;e>=r.e.len;){const a=await this.tokenizer.readToken(r.e);c(`Channel[ID=${a}]`),t.push(a),e-=BigInt(r.e.len)}return c(`Channels: ${t.join(", ")}`),t}}}}]);
//# sourceMappingURL=7408.cdb042f2399d30cec5aa.js.map