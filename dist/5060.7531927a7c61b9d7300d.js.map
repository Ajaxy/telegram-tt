{"version":3,"file":"5060.7531927a7c61b9d7300d.js","mappings":"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","sources":["webpack://telegram-t/./src/util/data/freeze.ts","webpack://telegram-t/./src/util/iteratees.ts","webpack://telegram-t/./src/util/deepDiff.ts","webpack://telegram-t/./src/util/deepMerge.ts","webpack://telegram-t/./src/global/shared/sharedState.worker.ts"],"sourcesContent":["export function deepFreeze<T extends object | undefined>(o: T) {\n  if (!o) return o;\n  Object.values(o).forEach((v) => Object.isFrozen(v) || deepFreeze(v));\n  return Object.freeze(o);\n}\n","type CollectionByKey<Member> = Record<number | string, Member>;\n\ntype OrderDirection =\n  'asc'\n  | 'desc';\n\ntype OrderCallback<T> = (member: T) => unknown;\n\nexport function buildCollectionByKey<T extends AnyLiteral>(collection: T[], key: keyof T) {\n  return collection.reduce((byKey: CollectionByKey<T>, member: T) => {\n    byKey[member[key]] = member;\n\n    return byKey;\n  }, {});\n}\n\nexport function buildCollectionByCallback<T extends AnyLiteral, K extends number | string, R>(\n  collection: T[],\n  callback: (member: T) => [K, R],\n) {\n  return collection.reduce((byKey: Record<K, R>, member: T) => {\n    const [key, value] = callback(member);\n    byKey[key] = value;\n\n    return byKey;\n  }, {} as Record<K, R>);\n}\n\nexport function mapValues<R, M>(\n  byKey: CollectionByKey<M>,\n  callback: (member: M, key: string, index: number, originalByKey: CollectionByKey<M>) => R,\n): CollectionByKey<R> {\n  return Object.keys(byKey).reduce((newByKey: CollectionByKey<R>, key, index) => {\n    newByKey[key] = callback(byKey[key], key, index, byKey);\n    return newByKey;\n  }, {});\n}\n\nexport function pick<T, K extends keyof T>(object: T, keys: K[]) {\n  return keys.reduce((result, key) => {\n    result[key] = object[key];\n    return result;\n  }, {} as Pick<T, K>);\n}\n\nexport function pickTruthy<T, K extends keyof T>(object: T, keys: K[]) {\n  return keys.reduce((result, key) => {\n    if (object[key]) {\n      result[key] = object[key];\n    }\n\n    return result;\n  }, {} as Pick<T, K>);\n}\n\nexport function omit<T extends object, K extends keyof T>(object: T, keys: K[]): Omit<T, K> {\n  const stringKeys = new Set(keys.map(String));\n  const savedKeys = Object.keys(object)\n    .filter((key) => !stringKeys.has(key)) as Array<Exclude<keyof T, K>>;\n\n  return pick(object, savedKeys);\n}\n\nexport function omitUndefined<T extends object>(object: T): T {\n  return Object.keys(object).reduce((result, stringKey) => {\n    const key = stringKey as keyof T;\n    if (object[key] !== undefined) {\n      result[key] = object[key];\n    }\n    return result;\n  }, {} as T);\n}\n\nexport function orderBy<T>(\n  collection: T[],\n  orderRule: (keyof T) | OrderCallback<T> | ((keyof T) | OrderCallback<T>)[],\n  mode: OrderDirection | [OrderDirection, OrderDirection] = 'asc',\n): T[] {\n  function compareValues(a: T, b: T, currentOrderRule: (keyof T) | OrderCallback<T>, isAsc: boolean) {\n    const aValue = (typeof currentOrderRule === 'function' ? currentOrderRule(a) : a[currentOrderRule]) || 0;\n    const bValue = (typeof currentOrderRule === 'function' ? currentOrderRule(b) : b[currentOrderRule]) || 0;\n\n    // @ts-expect-error Rely on the JS to handle the comparison\n    return isAsc ? aValue - bValue : bValue - aValue;\n  }\n\n  if (Array.isArray(orderRule)) {\n    const [mode1, mode2] = Array.isArray(mode) ? mode : [mode, mode];\n    const [orderRule1, orderRule2] = orderRule;\n    const isAsc1 = mode1 === 'asc';\n    const isAsc2 = mode2 === 'asc';\n\n    return collection.sort((a, b) => {\n      return compareValues(a, b, orderRule1, isAsc1) || compareValues(a, b, orderRule2, isAsc2);\n    });\n  }\n\n  const isAsc = mode === 'asc';\n  return collection.sort((a, b) => {\n    return compareValues(a, b, orderRule, isAsc);\n  });\n}\n\nexport function unique<T>(array: T[]): T[] {\n  return Array.from(new Set(array));\n}\n\nexport function uniqueByField<T>(array: T[], field: keyof T): T[] {\n  return [...new Map(array.map((item) => [item[field], item])).values()];\n}\n\nexport function compact<T>(array: T[]) {\n  return array.filter(Boolean);\n}\n\nexport function areSortedArraysEqual(array1: any[], array2: any[]) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n\n  return array1.every((item, i) => item === array2[i]);\n}\n\nexport function areSortedArraysIntersecting(array1: any[], array2: any[]) {\n  return array1[0] <= array2[array2.length - 1] && array1[array1.length - 1] >= array2[0];\n}\nexport function isInsideSortedArrayRange(value: any, array: any[]) {\n  return array[0] <= value && value <= array[array.length - 1];\n}\n\nexport function findIntersectionWithSet<T>(array: T[], set: Set<T>): T[] {\n  return array.filter((a) => set.has(a));\n}\n/**\n * Exlude elements from base array. Both arrays should be sorted in same order\n * @param base\n * @param toExclude\n * @returns New array without excluded elements\n */\nexport function excludeSortedArray<T>(base: T[], toExclude: T[]) {\n  if (!base?.length) return base;\n\n  const result: T[] = [];\n\n  let excludeIndex = 0;\n\n  for (let i = 0; i < base.length; i++) {\n    if (toExclude[excludeIndex] === base[i]) {\n      excludeIndex += 1;\n    } else {\n      result.push(base[i]);\n    }\n  }\n\n  return result;\n}\n\nexport function split<T>(array: T[], chunkSize: number) {\n  const result: T[][] = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n\nexport function partition<T>(\n  array: T[], filter: (value: T, index: number, array: T[]) => boolean | undefined,\n): [T[], T[]] {\n  const pass: T[] = [];\n  const fail: T[] = [];\n\n  array.forEach((e, idx, arr) => (filter(e, idx, arr) ? pass : fail).push(e));\n\n  return [pass, fail];\n}\n\nexport function cloneDeep<T>(value: T): T {\n  if (!isObject(value)) {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(cloneDeep) as typeof value;\n  }\n\n  return Object.keys(value).reduce((acc, key) => {\n    acc[key as keyof T] = cloneDeep(value[key as keyof T]);\n    return acc;\n  }, {} as T);\n}\n\nexport function isLiteralObject(value: any): value is AnyLiteral {\n  return isObject(value) && !Array.isArray(value);\n}\n\nfunction isObject(value: any): value is object {\n  // eslint-disable-next-line no-null/no-null\n  return typeof value === 'object' && value !== null;\n}\n\nexport function findLast<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): T | undefined {\n  let cursor = array.length;\n\n  while (cursor--) {\n    if (predicate(array[cursor], cursor, array)) {\n      return array[cursor];\n    }\n  }\n\n  return undefined;\n}\n\nexport function compareFields<T>(a: T, b: T) {\n  return Number(b) - Number(a);\n}\n","import { isLiteralObject, unique } from './iteratees';\n\nconst EQUAL = Symbol('EQUAL');\nconst DELETE = { __delete: true };\nconst DELETE_ALL_CHILDREN = { __deleteAllChildren: true };\n\ntype NestedDiff<T> = T extends object\n  ? { [K in keyof T]?: NestedDiff<T[K]> | typeof DELETE_ALL_CHILDREN | typeof DELETE | null } : T;\n\nexport type DiffObject<T> = T extends object\n  ? { [K in keyof T]?: NestedDiff<T[K]> } | typeof DELETE_ALL_CHILDREN\n  : T;\n\nexport function deepDiff<T>(value1: T, value2: T): Partial<T> | typeof EQUAL | typeof DELETE_ALL_CHILDREN {\n  if (value1 === value2) {\n    return EQUAL;\n  }\n\n  const type1 = typeof value1;\n  const type2 = typeof value2;\n\n  if (type1 !== type2) {\n    return value2;\n  }\n\n  if (Array.isArray(value1) && Array.isArray(value2) && areSortedArraysDeepEqual(value1, value2)) {\n    return EQUAL;\n  }\n\n  if (!isLiteralObject(value1) || !isLiteralObject(value2)) {\n    return value2;\n  }\n\n  const object1 = value1 as AnyLiteral;\n  const object2 = value2 as AnyLiteral;\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (!keys2.length) {\n    return !keys1.length ? EQUAL : DELETE_ALL_CHILDREN;\n  }\n\n  const allKeys = unique(keys1.concat(keys2));\n\n  const diff = allKeys.reduce((acc: any, key) => {\n    const subValue1 = object1[key];\n    const subValue2 = object2[key];\n\n    if (!object2.hasOwnProperty(key)) {\n      acc[key] = DELETE;\n      return acc;\n    }\n\n    if (!object1.hasOwnProperty(key)) {\n      acc[key] = subValue2;\n      return acc;\n    }\n\n    const subDiff = deepDiff(subValue1, subValue2);\n    if (subDiff !== EQUAL) {\n      acc[key] = subDiff;\n    }\n\n    return acc;\n  }, {});\n\n  if (Object.keys(diff).length === 0) {\n    return EQUAL;\n  }\n\n  return diff;\n}\n\nfunction areSortedArraysDeepEqual<T extends Array<any>>(array1: T, array2: T) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n\n  return array1.every((item, i) => deepDiff(item, array2[i]) === EQUAL);\n}\n","import type { DiffObject } from './deepDiff';\n\nimport { isLiteralObject, unique } from './iteratees';\n\nexport function deepMerge<T extends object>(value1: T, value2: DiffObject<T>): T {\n  if (value1 === value2) {\n    return value2 as unknown as T;\n  }\n\n  if (!isLiteralObject(value2)) {\n    return value2;\n  }\n\n  if (!isLiteralObject(value1)) {\n    return reduceDiff(value2) as T;\n  }\n\n  if ('__deleteAllChildren' in value2) {\n    return {} as T;\n  }\n\n  const allKeys = unique(Object.keys(value1).concat(Object.keys(value2)));\n\n  return allKeys.reduce((acc: AnyLiteral, key) => {\n    const oldValue = (value1 as AnyLiteral)[key];\n\n    if (!value2.hasOwnProperty(key)) {\n      acc[key] = oldValue;\n    } else {\n      const newValue = value2[key];\n\n      if (!newValue?.__delete) {\n        acc[key] = deepMerge(oldValue, newValue);\n      }\n    }\n\n    return acc;\n  }, {}) as T;\n}\n\nfunction reduceDiff(diff: AnyLiteral) {\n  if (diff.__deleteAllChildren) {\n    return {};\n  }\n\n  return Object.entries(diff).reduce((acc: AnyLiteral, [key, value]) => {\n    if (!value?.__delete) {\n      acc[key] = isLiteralObject(value) ? reduceDiff(value) : value;\n    }\n\n    return acc;\n  }, {});\n}\n","import type { SharedState } from '../types';\nimport type { WorkerBoundMessageEvent } from './sharedStateConnector';\n\nimport { deepFreeze } from '../../util/data/freeze';\nimport { deepDiff, type DiffObject } from '../../util/deepDiff';\nimport { deepMerge } from '../../util/deepMerge';\n\ndeclare const self: SharedWorkerGlobalScope;\n\ninterface StateUpdateEvent {\n  type: 'stateUpdate';\n  update: DiffObject<SharedState>;\n}\n\ninterface FullStateEvent {\n  type: 'fullState';\n  state: SharedState;\n}\n\nexport type ClientBoundMessageEvent = StateUpdateEvent | FullStateEvent;\n\nlet state: SharedState | undefined;\n\nconst ports: MessagePort[] = [];\n\nself.onconnect = (e: MessageEvent) => {\n  const port = e.ports[0];\n  ports.push(port);\n  port.start();\n\n  port.onmessage = (event: MessageEvent<WorkerBoundMessageEvent>) => {\n    const data = event.data;\n    switch (data.type) {\n      case 'reqGetFullState': {\n        const localState = data.localState;\n        if (!state) {\n          // First tab to load, use this state as the source of truth.\n          state = localState;\n        }\n        sendToClient(port, { type: 'fullState', state });\n        break;\n      }\n\n      case 'reqUpdateState': {\n        if (!state) return; // Client should request full state first\n        const prevState = state;\n        state = deepMerge(state, data.update as SharedState);\n        state.isInitial = undefined; // Remove the flag\n\n        const diff = deepDiff(prevState, state);\n        if (typeof diff !== 'symbol') {\n          broadcast({ type: 'stateUpdate', update: diff }, port);\n        }\n        break;\n      }\n    }\n  };\n};\n\nfunction sendToClient(port: MessagePort, message: ClientBoundMessageEvent) {\n  port.postMessage(message);\n}\n\nfunction broadcast(message: ClientBoundMessageEvent, ignorePort?: MessagePort) {\n  // Iterate backwards to safely remove ports if needed.\n  for (let i = ports.length - 1; i >= 0; i--) {\n    if (ports[i] === ignorePort) { // Prevent infinite loopback\n      continue;\n    }\n\n    try {\n      sendToClient(ports[i], message);\n    } catch (e) {\n      ports.splice(i, 1);\n    }\n  }\n}\n\n// DEBUG\n(self as any).getState = () => deepFreeze(state);\n"],"names":["deepFreeze","o","Object","values","forEach","v","isFrozen","freeze","unique","array","Array","from","Set","isLiteralObject","value","isObject","isArray","EQUAL","Symbol","DELETE","__delete","DELETE_ALL_CHILDREN","__deleteAllChildren","deepDiff","value1","value2","array2","array1","length","every","item","i","object1","object2","keys1","keys","keys2","diff","concat","reduce","acc","key","subValue1","subValue2","hasOwnProperty","subDiff","deepMerge","oldValue","newValue","reduceDiff","entries","state","ports","sendToClient","port","message","postMessage","self","onconnect","e","push","start","onmessage","event","data","type","localState","prevState","update","isInitial","undefined","ignorePort","splice","broadcast","getState"],"sourceRoot":""}