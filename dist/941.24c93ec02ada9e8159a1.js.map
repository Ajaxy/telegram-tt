{"version":3,"file":"941.24c93ec02ada9e8159a1.js","mappings":"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","sources":["webpack://telegram-t/./src/util/WorkerConnector.ts","webpack://telegram-t/./src/lib/rlottie/RLottie.ts","webpack://telegram-t/./src/util/cycleRestrict.ts"],"sourcesContent":["import generateIdFor from './generateIdFor';\n\nexport interface CancellableCallback {\n  (\n    ...args: any[]\n  ): void;\n\n  isCanceled?: boolean;\n  acceptsBuffer?: boolean;\n}\n\ntype CallMethodData = {\n  type: 'callMethod';\n  messageId?: string;\n  name: string;\n  args: any;\n};\n\ntype OriginMessageData = CallMethodData | {\n  type: 'cancelProgress';\n  messageId: string;\n};\n\nexport interface OriginMessageEvent {\n  data: OriginMessageData;\n}\n\nexport type WorkerMessageData = {\n  type: 'methodResponse';\n  messageId: string;\n  response?: any;\n  error?: { message: string };\n} | {\n  type: 'methodCallback';\n  messageId: string;\n  callbackArgs: any[];\n} | {\n  type: 'unhandledError';\n  error?: { message: string };\n};\n\nexport interface WorkerMessageEvent {\n  data: WorkerMessageData;\n}\n\ninterface RequestStates {\n  messageId: string;\n  resolve: Function;\n  reject: Function;\n  callback: AnyToVoidFunction;\n}\n\n// TODO Replace `any` with proper generics\nexport default class WorkerConnector {\n  private requestStates = new Map<string, RequestStates>();\n\n  private requestStatesByCallback = new Map<AnyToVoidFunction, RequestStates>();\n\n  constructor(private worker: Worker) {\n    this.subscribe();\n  }\n\n  request(messageData: { name: string; args: any }) {\n    const { worker, requestStates, requestStatesByCallback } = this;\n\n    const messageId = generateIdFor(requestStates);\n    const payload: CallMethodData = {\n      type: 'callMethod',\n      messageId,\n      ...messageData,\n    };\n\n    const requestState = { messageId } as RequestStates;\n\n    // Re-wrap type because of `postMessage`\n    const promise: Promise<any> = new Promise((resolve, reject) => {\n      Object.assign(requestState, { resolve, reject });\n    });\n\n    if (typeof payload.args[payload.args.length - 1] === 'function') {\n      const callback = payload.args.pop() as AnyToVoidFunction;\n      requestState.callback = callback;\n      requestStatesByCallback.set(callback, requestState);\n    }\n\n    requestStates.set(messageId, requestState);\n    promise\n      .catch(() => undefined)\n      .finally(() => {\n        requestStates.delete(messageId);\n\n        if (requestState.callback) {\n          requestStatesByCallback.delete(requestState.callback);\n        }\n      });\n\n    worker.postMessage(payload);\n\n    return promise;\n  }\n\n  cancelCallback(progressCallback: CancellableCallback) {\n    progressCallback.isCanceled = true;\n\n    const { messageId } = this.requestStatesByCallback.get(progressCallback) || {};\n    if (!messageId) {\n      return;\n    }\n\n    this.worker.postMessage({\n      type: 'cancelProgress',\n      messageId,\n    });\n  }\n\n  private subscribe() {\n    const { worker, requestStates } = this;\n\n    worker.addEventListener('message', ({ data }: WorkerMessageEvent) => {\n      if (data.type === 'methodResponse') {\n        const requestState = requestStates.get(data.messageId);\n        if (requestState) {\n          if (data.error) {\n            requestState.reject(data.error);\n          } else {\n            requestState.resolve(data.response);\n          }\n        }\n      } else if (data.type === 'methodCallback') {\n        const requestState = requestStates.get(data.messageId);\n        requestState?.callback?.(...data.callbackArgs);\n      } else if (data.type === 'unhandledError') {\n        throw new Error(data.error?.message);\n      }\n    });\n  }\n}\n","import {\n  DPR,\n  IS_SINGLE_COLUMN_LAYOUT,\n  IS_SAFARI,\n  IS_ANDROID,\n} from '../../util/environment';\nimport WorkerConnector from '../../util/WorkerConnector';\nimport { animate } from '../../util/animation';\nimport cycleRestrict from '../../util/cycleRestrict';\n\ninterface Params {\n  noLoop?: boolean;\n  size?: number;\n  quality?: number;\n  isLowPriority?: boolean;\n}\n\ntype Frames = ArrayBuffer[];\ntype Chunks = (Frames | undefined)[];\n\n// TODO Consider removing chunks\nconst CHUNK_SIZE = 1;\nconst MAX_WORKERS = 4;\nconst HIGH_PRIORITY_QUALITY = IS_SINGLE_COLUMN_LAYOUT ? 0.75 : 1;\nconst LOW_PRIORITY_QUALITY = IS_ANDROID ? 0.5 : 0.75;\nconst HIGH_PRIORITY_CACHE_MODULO = IS_SAFARI ? 2 : 4;\nconst LOW_PRIORITY_CACHE_MODULO = 0;\n\nconst workers = new Array(MAX_WORKERS).fill(undefined).map(\n  () => new WorkerConnector(new Worker(new URL('./rlottie.worker.ts', import.meta.url))),\n);\nlet lastWorkerIndex = -1;\n\nclass RLottie {\n  // Config\n\n  private imgSize!: number;\n\n  private key!: string;\n\n  private msPerFrame = 1000 / 60;\n\n  private reduceFactor = 1;\n\n  private cacheModulo!: number;\n\n  private chunkSize!: number;\n\n  private workerIndex!: number;\n\n  private chunks: Chunks = [];\n\n  private framesCount?: number;\n\n  private chunksCount?: number;\n\n  // Container\n\n  private canvas = document.createElement('canvas');\n\n  private ctx = this.canvas.getContext('2d')!;\n\n  // State\n\n  private isAnimating = false;\n\n  private isWaiting = true;\n\n  private isOnLoadFired = false;\n\n  private isDestroyed = false;\n\n  private approxFrameIndex = 0;\n\n  private prevFrameIndex = -1;\n\n  private stopFrameIndex? = 0;\n\n  private speed = 1;\n\n  private direction: 1 | -1 = 1;\n\n  private lastRenderAt?: number;\n\n  constructor(\n    private id: string,\n    private container: HTMLDivElement,\n    private animationData: string,\n    private params: Params = {},\n    private onLoad?: () => void,\n    private customColor?: [number, number, number],\n    private onEnded?: (isDestroyed?: boolean) => void,\n  ) {\n    this.initContainer();\n    this.initConfig();\n    this.initRenderer();\n  }\n\n  isPlaying() {\n    return this.isAnimating || this.isWaiting;\n  }\n\n  play() {\n    this.stopFrameIndex = undefined;\n    this.direction = 1;\n    this.doPlay();\n  }\n\n  pause() {\n    if (this.isWaiting) {\n      this.stopFrameIndex = this.approxFrameIndex;\n    } else {\n      this.isAnimating = false;\n    }\n\n    const currentChunkIndex = this.getChunkIndex(this.approxFrameIndex);\n    this.chunks = this.chunks.map((chunk, i) => (i === currentChunkIndex ? chunk : undefined));\n  }\n\n  goToAndPlay(frameIndex: number) {\n    this.approxFrameIndex = Math.floor(frameIndex / this.reduceFactor);\n    this.stopFrameIndex = undefined;\n    this.direction = 1;\n    this.doPlay();\n  }\n\n  goToAndStop(frameIndex: number) {\n    this.approxFrameIndex = Math.floor(frameIndex / this.reduceFactor);\n    this.stopFrameIndex = Math.floor(frameIndex / this.reduceFactor);\n    this.direction = 1;\n    this.doPlay();\n  }\n\n  playSegment([startFrameIndex, stopFrameIndex]: [number, number]) {\n    this.approxFrameIndex = Math.floor(startFrameIndex / this.reduceFactor);\n    this.stopFrameIndex = Math.floor(stopFrameIndex / this.reduceFactor);\n    this.direction = startFrameIndex < stopFrameIndex ? 1 : -1;\n    this.doPlay();\n  }\n\n  setSpeed(speed: number) {\n    this.speed = speed;\n  }\n\n  destroy() {\n    this.isDestroyed = true;\n    this.pause();\n    this.destroyRenderer();\n    this.destroyContainer();\n  }\n\n  private initContainer() {\n    if (!(this.container.parentNode instanceof HTMLElement)) {\n      throw new Error('[RLottie] Container is not mounted');\n    }\n\n    let { size } = this.params;\n\n    if (!size) {\n      size = (\n        this.container.offsetWidth\n        || parseInt(this.container.style.width, 10)\n        || this.container.parentNode.offsetWidth\n      );\n\n      if (!size) {\n        throw new Error('[RLottie] Failed to detect width from container');\n      }\n    }\n\n    this.canvas.style.width = `${size}px`;\n    this.canvas.style.height = `${size}px`;\n\n    const { isLowPriority, quality = isLowPriority ? LOW_PRIORITY_QUALITY : HIGH_PRIORITY_QUALITY } = this.params;\n    // Reduced quality only looks acceptable on high DPR screens\n    const imgSize = Math.round(size * Math.max(DPR * quality, 1));\n\n    this.canvas.width = imgSize;\n    this.canvas.height = imgSize;\n\n    this.container.appendChild(this.canvas);\n\n    this.imgSize = imgSize;\n  }\n\n  private initConfig() {\n    this.key = `${this.id}_${this.imgSize}`;\n\n    const { isLowPriority } = this.params;\n\n    this.cacheModulo = isLowPriority ? LOW_PRIORITY_CACHE_MODULO : HIGH_PRIORITY_CACHE_MODULO;\n    this.chunkSize = CHUNK_SIZE;\n  }\n\n  private destroyContainer() {\n    this.canvas.remove();\n  }\n\n  setColor(newColor: [number, number, number] | undefined) {\n    this.customColor = newColor;\n\n    // TODO Remove?\n    if (this.customColor) {\n      const imageData = this.ctx.getImageData(0, 0, this.imgSize, this.imgSize);\n      const arr = imageData.data;\n      for (let i = 0; i < arr.length; i += 4) {\n        /* eslint-disable prefer-destructuring */\n        arr[i] = this.customColor[0];\n        arr[i + 1] = this.customColor[1];\n        arr[i + 2] = this.customColor[2];\n        /* eslint-enable prefer-destructuring */\n      }\n      this.ctx.putImageData(imageData, 0, 0);\n    }\n  }\n\n  private initRenderer() {\n    this.workerIndex = cycleRestrict(MAX_WORKERS, ++lastWorkerIndex);\n\n    workers[this.workerIndex].request({\n      name: 'init',\n      args: [\n        this.key,\n        this.animationData,\n        this.imgSize,\n        this.params.isLowPriority,\n        this.onRendererInit.bind(this),\n      ],\n    });\n  }\n\n  private destroyRenderer() {\n    workers[this.workerIndex].request({\n      name: 'destroy',\n      args: [this.key],\n    });\n  }\n\n  private onRendererInit(reduceFactor: number, msPerFrame: number, framesCount: number) {\n    this.reduceFactor = reduceFactor;\n    this.msPerFrame = msPerFrame;\n    this.framesCount = framesCount;\n    this.chunksCount = Math.ceil(framesCount / this.chunkSize);\n\n    if (this.isWaiting) {\n      this.doPlay();\n    }\n  }\n\n  changeData(animationData: string) {\n    this.pause();\n    this.animationData = animationData;\n    this.initConfig();\n\n    workers[this.workerIndex].request({\n      name: 'changeData',\n      args: [\n        this.key,\n        this.animationData,\n        this.params.isLowPriority,\n        this.onChangeData.bind(this),\n      ],\n    });\n  }\n\n  private onChangeData(reduceFactor: number, msPerFrame: number, framesCount: number) {\n    this.reduceFactor = reduceFactor;\n    this.msPerFrame = msPerFrame;\n    this.framesCount = framesCount;\n    this.chunksCount = Math.ceil(framesCount / this.chunkSize);\n    this.isWaiting = false;\n    this.isAnimating = false;\n\n    this.doPlay();\n  }\n\n  private doPlay() {\n    if (!this.framesCount) {\n      return;\n    }\n\n    if (this.isDestroyed) {\n      return;\n    }\n\n    if (this.isAnimating) {\n      return;\n    }\n\n    if (!this.isWaiting) {\n      this.lastRenderAt = undefined;\n    }\n\n    this.isAnimating = true;\n    this.isWaiting = false;\n\n    animate(() => {\n      if (this.isDestroyed) {\n        return false;\n      }\n\n      // Paused from outside\n      if (!this.isAnimating && this.isOnLoadFired) {\n        return false;\n      }\n\n      const frameIndex = Math.round(this.approxFrameIndex);\n      const chunkIndex = this.getChunkIndex(frameIndex);\n      const chunk = this.chunks[chunkIndex];\n\n      if (!chunk || chunk.length === 0) {\n        this.requestChunk(chunkIndex);\n        this.isAnimating = false;\n        this.isWaiting = true;\n        return false;\n      }\n\n      if (this.cacheModulo && chunkIndex % this.cacheModulo === 0) {\n        this.cleanupPrevChunk(chunkIndex);\n      }\n\n      if (frameIndex !== this.prevFrameIndex) {\n        const frame = this.getFrame(frameIndex);\n        if (!frame) {\n          this.isAnimating = false;\n          this.isWaiting = true;\n          return false;\n        }\n\n        const arr = new Uint8ClampedArray(frame);\n        if (this.customColor) {\n          for (let i = 0; i < arr.length; i += 4) {\n            /* eslint-disable prefer-destructuring */\n            arr[i] = this.customColor[0];\n            arr[i + 1] = this.customColor[1];\n            arr[i + 2] = this.customColor[2];\n            /* eslint-enable prefer-destructuring */\n          }\n        }\n        const imageData = new ImageData(arr, this.imgSize, this.imgSize);\n        this.ctx.putImageData(imageData, 0, 0);\n\n        if (this.onLoad && !this.isOnLoadFired) {\n          this.isOnLoadFired = true;\n          this.onLoad();\n        }\n\n        this.prevFrameIndex = frameIndex;\n      }\n\n      const now = Date.now();\n      const currentSpeed = this.lastRenderAt ? this.msPerFrame / (now - this.lastRenderAt) : 1;\n      const delta = Math.min(1, (this.direction * this.speed) / currentSpeed);\n      const expectedNextFrameIndex = Math.round(this.approxFrameIndex + delta);\n\n      this.lastRenderAt = now;\n\n      // Forward animation finished\n      if (delta > 0 && (frameIndex === this.framesCount! - 1 || expectedNextFrameIndex > this.framesCount! - 1)) {\n        if (this.params.noLoop) {\n          this.isAnimating = false;\n          this.onEnded?.();\n          return false;\n        }\n\n        this.approxFrameIndex = 0;\n\n        // Backward animation finished\n      } else if (delta < 0 && (frameIndex === 0 || expectedNextFrameIndex < 0)) {\n        if (this.params.noLoop) {\n          this.isAnimating = false;\n          this.onEnded?.();\n          return false;\n        }\n\n        this.approxFrameIndex = this.framesCount! - 1;\n\n        // Stop frame reached\n      } else if (\n        this.stopFrameIndex !== undefined\n        && (frameIndex === this.stopFrameIndex\n        || (\n          (delta > 0 && expectedNextFrameIndex > this.stopFrameIndex)\n          || (delta < 0 && expectedNextFrameIndex < this.stopFrameIndex)\n        ))\n      ) {\n        this.stopFrameIndex = undefined;\n        this.isAnimating = false;\n        return false;\n\n        // Preparing next frame\n      } else {\n        this.approxFrameIndex += delta;\n      }\n\n      const nextFrameIndex = Math.round(this.approxFrameIndex);\n\n      if (!this.getFrame(nextFrameIndex)) {\n        this.requestChunk(this.getChunkIndex(nextFrameIndex));\n        this.isWaiting = true;\n        this.isAnimating = false;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  private getFrame(frameIndex: number) {\n    const chunkIndex = this.getChunkIndex(frameIndex);\n    const indexInChunk = this.getFrameIndexInChunk(frameIndex);\n    const chunk = this.chunks[chunkIndex];\n    if (!chunk) {\n      return undefined;\n    }\n\n    return chunk[indexInChunk];\n  }\n\n  private getFrameIndexInChunk(frameIndex: number) {\n    const chunkIndex = this.getChunkIndex(frameIndex);\n    return frameIndex - chunkIndex * this.chunkSize;\n  }\n\n  private getChunkIndex(frameIndex: number) {\n    return Math.floor(frameIndex / this.chunkSize);\n  }\n\n  private requestChunk(chunkIndex: number) {\n    if (this.chunks[chunkIndex] && this.chunks[chunkIndex]?.length !== 0) {\n      return;\n    }\n\n    this.chunks[chunkIndex] = [];\n\n    const fromIndex = chunkIndex * this.chunkSize;\n    const toIndex = Math.min(fromIndex + this.chunkSize - 1, this.framesCount! - 1);\n\n    workers[this.workerIndex].request({\n      name: 'renderFrames',\n      args: [this.key, fromIndex, toIndex, this.onFrameLoad.bind(this)],\n    });\n  }\n\n  private cleanupPrevChunk(chunkIndex: number) {\n    if (this.chunksCount! < 3) {\n      return;\n    }\n\n    const prevChunkIndex = cycleRestrict(this.chunksCount!, chunkIndex - 1);\n    this.chunks[prevChunkIndex] = undefined;\n  }\n\n  private requestNextChunk(chunkIndex: number) {\n    if (this.chunksCount === 1) {\n      return;\n    }\n\n    const nextChunkIndex = cycleRestrict(this.chunksCount!, chunkIndex + 1);\n\n    if (!this.chunks[nextChunkIndex]) {\n      this.requestChunk(nextChunkIndex);\n    }\n  }\n\n  private onFrameLoad(frameIndex: number, arrayBuffer: ArrayBuffer) {\n    const chunkIndex = this.getChunkIndex(frameIndex);\n    const chunk = this.chunks[chunkIndex];\n    // Frame can be skipped and chunk can be already cleaned up\n    if (!chunk) {\n      return;\n    }\n\n    chunk[this.getFrameIndexInChunk(frameIndex)] = arrayBuffer;\n\n    if (this.isWaiting) {\n      this.doPlay();\n    }\n  }\n}\n\nexport default RLottie;\n","export default function cycleRestrict(length: number, index: number) {\n  return index - Math.floor(index / length) * length;\n}\n"],"names":["WorkerConnector","constructor","worker","Map","this","subscribe","request","messageData","requestStates","requestStatesByCallback","messageId","generateIdFor","payload","type","requestState","promise","Promise","resolve","reject","Object","assign","args","length","callback","pop","set","catch","finally","delete","postMessage","cancelCallback","progressCallback","isCanceled","get","addEventListener","data","error","response","callbackArgs","Error","message","HIGH_PRIORITY_QUALITY","IS_SINGLE_COLUMN_LAYOUT","LOW_PRIORITY_QUALITY","IS_ANDROID","HIGH_PRIORITY_CACHE_MODULO","IS_SAFARI","workers","Array","fill","undefined","map","Worker","URL","lastWorkerIndex","id","container","animationData","params","onLoad","customColor","onEnded","document","createElement","canvas","getContext","initContainer","initConfig","initRenderer","isPlaying","isAnimating","isWaiting","play","stopFrameIndex","direction","doPlay","pause","approxFrameIndex","currentChunkIndex","getChunkIndex","chunks","chunk","i","goToAndPlay","frameIndex","Math","floor","reduceFactor","goToAndStop","playSegment","startFrameIndex","setSpeed","speed","destroy","isDestroyed","destroyRenderer","destroyContainer","parentNode","HTMLElement","size","offsetWidth","parseInt","style","width","height","isLowPriority","quality","imgSize","round","max","DPR","appendChild","key","cacheModulo","chunkSize","remove","setColor","newColor","imageData","ctx","getImageData","arr","putImageData","workerIndex","cycleRestrict","name","onRendererInit","bind","msPerFrame","framesCount","chunksCount","ceil","changeData","onChangeData","lastRenderAt","animate","isOnLoadFired","chunkIndex","requestChunk","cleanupPrevChunk","prevFrameIndex","frame","getFrame","Uint8ClampedArray","ImageData","now","Date","currentSpeed","delta","min","expectedNextFrameIndex","noLoop","nextFrameIndex","indexInChunk","getFrameIndexInChunk","fromIndex","toIndex","onFrameLoad","prevChunkIndex","requestNextChunk","nextChunkIndex","arrayBuffer","index"],"sourceRoot":""}