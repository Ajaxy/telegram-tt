{"version":3,"file":"1184.68efc66b5ecdd36e1df7.js","mappings":"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","sources":["webpack://telegram-t/./src/lib/lovely-chart/constants.js","webpack://telegram-t/./src/lib/lovely-chart/utils.js","webpack://telegram-t/./src/lib/lovely-chart/formulas.js","webpack://telegram-t/./src/lib/lovely-chart/StateManager.js","webpack://telegram-t/./src/lib/lovely-chart/TransitionManager.js","webpack://telegram-t/./src/lib/lovely-chart/minifiers.js","webpack://telegram-t/./src/lib/lovely-chart/toggleText.js","webpack://telegram-t/./src/lib/lovely-chart/format.js","webpack://telegram-t/./src/lib/lovely-chart/skin.js","webpack://telegram-t/./src/lib/lovely-chart/Projection.js","webpack://telegram-t/./src/lib/lovely-chart/canvas.js","webpack://telegram-t/./src/lib/lovely-chart/preparePoints.js","webpack://telegram-t/./src/lib/lovely-chart/simplify.js","webpack://telegram-t/./src/lib/lovely-chart/drawDatasets.js","webpack://telegram-t/./src/lib/lovely-chart/captureEvents.js","webpack://telegram-t/./src/lib/lovely-chart/Tooltip.js","webpack://telegram-t/./src/lib/lovely-chart/data.js","webpack://telegram-t/./src/lib/lovely-chart/LovelyChart.js","webpack://telegram-t/./src/lib/lovely-chart/Header.js","webpack://telegram-t/./src/lib/lovely-chart/Axes.js","webpack://telegram-t/./src/lib/lovely-chart/Minimap.js","webpack://telegram-t/./src/lib/lovely-chart/Tools.js","webpack://telegram-t/./src/lib/lovely-chart/Zoomer.js"],"sourcesContent":["export const DPR = window.devicePixelRatio || 1;\n\nexport const DEFAULT_RANGE = { begin: 0.8, end: 1 };\nexport const TRANSITION_DEFAULT_DURATION = 300;\nexport const LONG_PRESS_TIMEOUT = 500;\n\nexport const GUTTER = 10;\nexport const PLOT_HEIGHT = 320;\nexport const PLOT_TOP_PADDING = 15;\nexport const PLOT_LINE_WIDTH = 2;\nexport const PLOT_PIE_RADIUS_FACTOR = 0.9 / 2;\nexport const PLOT_PIE_SHIFT = 10;\nexport const PLOT_BARS_WIDTH_SHIFT = 0.5;\n\nexport const PIE_MINIMUM_VISIBLE_PERCENT = 0.02;\n\nexport const BALLOON_OFFSET = 20;\n\nexport const AXES_FONT = '300 10px Helvetica, Arial, sans-serif';\nexport const AXES_MAX_COLUMN_WIDTH = 45;\nexport const AXES_MAX_ROW_HEIGHT = 50;\nexport const X_AXIS_HEIGHT = 30;\nexport const X_AXIS_SHIFT_START = 1;\nexport const Y_AXIS_ZERO_BASED_THRESHOLD = 0.1;\n\nexport const MINIMAP_HEIGHT = 40;\nexport const MINIMAP_MARGIN = 10;\nexport const MINIMAP_LINE_WIDTH = 1;\nexport const MINIMAP_EAR_WIDTH = 8;\nexport const MINIMAP_MAX_ANIMATED_DATASETS = 4;\n\nexport const ZOOM_TIMEOUT = TRANSITION_DEFAULT_DURATION;\nexport const ZOOM_RANGE_DELTA = 0.1;\nexport const ZOOM_RANGE_MIDDLE = .5;\n\nexport const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\nexport const WEEK_DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nexport const WEEK_DAYS_SHORT = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n\nexport const MILISECONDS_IN_DAY = 24 * 60 * 60 * 1000;\n\nexport const SPEED_TEST_INTERVAL = 200;\nexport const SPEED_TEST_FAST_FPS = 4;\n\nexport const SIMPLIFIER_MIN_POINTS = 1000;\nexport const SIMPLIFIER_PLOT_FACTOR = 1;\nexport const SIMPLIFIER_MINIMAP_FACTOR = 0.5;\n\nexport const ANIMATE_PROPS = [\n  // Viewport X-axis\n  'begin 200 fast', 'end 200 fast', 'labelFromIndex 200 fast floor', 'labelToIndex 200 fast ceil',\n\n  // X-axis labels\n  'xAxisScale 400',\n\n  // Viewport Y-axis\n  'yMinViewport', 'yMaxViewport', 'yMinViewportSecond', 'yMaxViewportSecond',\n\n  // Minimap Y-axis\n  'yMinMinimap', 'yMaxMinimap', 'yMinMinimapSecond', 'yMaxMinimapSecond',\n\n  // Y-axis labels\n  'yAxisScale', 'yAxisScaleSecond',\n];\n","// https://jsperf.com/finding-maximum-element-in-an-array\nexport function getMaxMin(array) {\n  const length = array.length;\n  let max = array[0];\n  let min = array[0];\n\n  for (let i = 0; i < length; i++) {\n    const value = array[i];\n\n    if (value > max) {\n      max = value;\n    } else if (value < min) {\n      min = value;\n    }\n  }\n\n  return { max, min };\n}\n\n// https://jsperf.com/multi-array-concat/24\nexport function mergeArrays(arrays) {\n  return [].concat.apply([], arrays);\n}\n\nexport function sumArrays(arrays) {\n  const sums = [];\n  const n = arrays.length;\n\n  for (let i = 0, l = arrays[0].length; i < l; i++) {\n    sums[i] = 0;\n\n    for (let j = 0; j < n; j++) {\n      sums[i] += arrays[j][i];\n    }\n  }\n\n  return sums;\n}\n\nexport function proxyMerge(obj1, obj2) {\n  return new Proxy({}, {\n    get: (obj, prop) => {\n      if (obj[prop] !== undefined) {\n        return obj[prop];\n      } else if (obj2[prop] !== undefined) {\n        return obj2[prop];\n      } else {\n        return obj1[prop];\n      }\n    },\n  });\n}\n\nexport function throttle(\n  fn,\n  ms,\n  shouldRunFirst = true,\n) {\n  let interval = null;\n  let isPending;\n  let args;\n\n  return (..._args) => {\n    isPending = true;\n    args = _args;\n\n    if (!interval) {\n      if (shouldRunFirst) {\n        isPending = false;\n        // @ts-ignore\n        fn(...args);\n      }\n\n      interval = window.setInterval(() => {\n        if (!isPending) {\n          window.clearInterval(interval);\n          interval = null;\n          return;\n        }\n\n        isPending = false;\n        // @ts-ignore\n        fn(...args);\n      }, ms);\n    }\n  };\n}\n\nexport function throttleWithRaf(fn) {\n  let waiting = false;\n  let args;\n\n  return function (..._args) {\n    args = _args;\n\n    if (!waiting) {\n      waiting = true;\n\n      requestAnimationFrame(() => {\n        waiting = false;\n        fn(...args);\n      });\n    }\n  };\n}\n\nexport function debounce(fn, ms, shouldRunFirst = true, shouldRunLast = true) {\n  let waitingTimeout = null;\n\n  return function () {\n    if (waitingTimeout) {\n      clearTimeout(waitingTimeout);\n      waitingTimeout = null;\n    } else if (shouldRunFirst) {\n      fn();\n    }\n\n    waitingTimeout = setTimeout(() => {\n      if (shouldRunLast) {\n        fn();\n      }\n\n      waitingTimeout = null;\n    }, ms);\n  };\n}\n","import { GUTTER, PLOT_PIE_RADIUS_FACTOR, MILISECONDS_IN_DAY, SIMPLIFIER_MIN_POINTS } from './constants';\n\nexport function xScaleLevelToStep(scaleLevel) {\n  return Math.pow(2, scaleLevel);\n}\n\nexport function xStepToScaleLevel(step) {\n  return Math.ceil(Math.log2(step || 1));\n}\n\nconst SCALE_LEVELS = [\n  1, 2, 8, 18, 50, 100, 250, 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000,\n  250000, 500000, 1000000, 2500000, 5000000, 10000000, 25000000, 50000000, 100000000,\n];\n\nexport function yScaleLevelToStep(scaleLevel) {\n  return SCALE_LEVELS[scaleLevel] || SCALE_LEVELS[SCALE_LEVELS.length - 1];\n}\n\nexport function yStepToScaleLevel(neededStep) {\n  return SCALE_LEVELS.findIndex((step) => step >= neededStep) || SCALE_LEVELS.length - 1;\n}\n\nexport function applyYEdgeOpacity(opacity, xPx, plotWidth) {\n  const edgeOffset = Math.min(xPx + GUTTER, plotWidth - xPx);\n  if (edgeOffset <= GUTTER * 4) {\n    opacity = Math.min(1, opacity, edgeOffset / (GUTTER * 4));\n  }\n  return opacity;\n}\n\nexport function applyXEdgeOpacity(opacity, yPx) {\n  return (yPx - GUTTER <= GUTTER * 2)\n    ? Math.min(1, opacity, (yPx - GUTTER) / (GUTTER * 2))\n    : opacity;\n}\n\nexport function getPieRadius(projection) {\n  return Math.min(...projection.getSize()) * PLOT_PIE_RADIUS_FACTOR;\n}\n\nexport function getPieTextSize(percent, radius) {\n  return (radius + percent * 200) / 10;\n}\n\nexport function getPieTextShift(percent, radius, shift) {\n  return percent >= 0.99 ? 0 : Math.min(1 - Math.log(percent * 30) / 5, 4 / 5) * radius;\n}\n\nexport function isDataRange(labelFrom, labelTo) {\n  return Math.abs(labelTo.value - labelFrom.value) > MILISECONDS_IN_DAY;\n}\n\nexport function getSimplificationDelta(pointsLength) {\n  return pointsLength >= SIMPLIFIER_MIN_POINTS ? Math.min((pointsLength / 1000), 1) : 0;\n}\n","import { createTransitionManager } from './TransitionManager';\nimport { throttleWithRaf, getMaxMin, mergeArrays, proxyMerge, sumArrays } from './utils';\nimport {\n  AXES_MAX_COLUMN_WIDTH,\n  AXES_MAX_ROW_HEIGHT,\n  X_AXIS_HEIGHT,\n  ANIMATE_PROPS,\n  Y_AXIS_ZERO_BASED_THRESHOLD,\n} from './constants';\nimport { xStepToScaleLevel, yScaleLevelToStep, yStepToScaleLevel } from './formulas';\n\nexport function createStateManager(data, viewportSize, callback) {\n  const _range = { begin: 0, end: 1 };\n  const _filter = _buildDefaultFilter();\n  const _transitionConfig = _buildTransitionConfig();\n  const _transitions = createTransitionManager(_runCallback);\n  const _runCallbackOnRaf = throttleWithRaf(_runCallback);\n\n  let _state = {};\n\n  function update({ range = {}, filter = {}, focusOn, minimapDelta } = {}, noTransition) {\n    Object.assign(_range, range);\n    Object.assign(_filter, filter);\n\n    const prevState = _state;\n    _state = calculateState(data, viewportSize, _range, _filter, focusOn, minimapDelta, prevState);\n\n    if (!noTransition) {\n      _transitionConfig.forEach(({ prop, duration, options }) => {\n        const transition = _transitions.get(prop);\n        const currentTarget = transition ? transition.to : prevState[prop];\n\n        if (currentTarget !== undefined && currentTarget !== _state[prop]) {\n          const current = transition\n            ? (options.includes('fast') ? prevState[prop] : transition.current)\n            : prevState[prop];\n\n          if (transition) {\n            _transitions.remove(prop);\n          }\n\n          _transitions.add(prop, current, _state[prop], duration, options);\n        }\n      });\n    }\n\n    if (!_transitions.isRunning() || !_transitions.isFast()) {\n      _runCallbackOnRaf();\n    }\n  }\n\n  function hasAnimations() {\n    return _transitions.isFast();\n  }\n\n  function _buildTransitionConfig() {\n    const transitionConfig = [];\n    const datasetVisibilities = data.datasets.map(({ key }) => `opacity#${key} 300`);\n\n    mergeArrays([\n      ANIMATE_PROPS,\n      datasetVisibilities,\n    ]).forEach((transition) => {\n      const [prop, duration, ...options] = transition.split(' ');\n      transitionConfig.push({ prop, duration, options });\n    });\n\n    return transitionConfig;\n  }\n\n  function _buildDefaultFilter() {\n    const filter = {};\n\n    data.datasets.forEach(({ key }) => {\n      filter[key] = true;\n    });\n\n    return filter;\n  }\n\n  function _runCallback() {\n    const state = _transitions.isFast() ? proxyMerge(_state, _transitions.getState()) : _state;\n    state.static = _state;\n    callback(state);\n  }\n\n  return { update, hasAnimations };\n}\n\nfunction calculateState(data, viewportSize, range, filter, focusOn, minimapDelta, prevState) {\n  const { begin, end } = range;\n  const totalXWidth = data.xLabels.length - 1;\n\n  const labelFromIndex = Math.max(0, Math.ceil(totalXWidth * begin));\n  const labelToIndex = Math.min(Math.floor(totalXWidth * end), totalXWidth);\n\n  const xAxisScale = calculateXAxisScale(viewportSize.width, labelFromIndex, labelToIndex);\n\n  const yRanges = data.isStacked\n    ? calculateYRangesStacked(data, filter, labelFromIndex, labelToIndex, prevState)\n    : calculateYRanges(data, filter, labelFromIndex, labelToIndex, prevState);\n\n  const yAxisScale = calculateYAxisScale(viewportSize.height, yRanges.yMinViewport, yRanges.yMaxViewport);\n  const yAxisScaleSecond = data.hasSecondYAxis &&\n    calculateYAxisScale(viewportSize.height, yRanges.yMinViewportSecond, yRanges.yMaxViewportSecond);\n\n  const yStep = yScaleLevelToStep(yAxisScale);\n  yRanges.yMinViewport -= yRanges.yMinViewport % yStep;\n\n  if (yAxisScaleSecond) {\n    const yStepSecond = yScaleLevelToStep(yAxisScaleSecond);\n    yRanges.yMinViewportSecond -= yRanges.yMinViewportSecond % yStepSecond;\n  }\n\n  const datasetsOpacity = {};\n  data.datasets.forEach(({ key }) => {\n    datasetsOpacity[`opacity#${key}`] = filter[key] ? 1 : 0;\n  });\n\n  // TODO perf\n  return Object.assign(\n    {\n      totalXWidth,\n      xAxisScale,\n      yAxisScale,\n      yAxisScaleSecond,\n      labelFromIndex: Math.max(0, labelFromIndex - 1),\n      labelToIndex: Math.min(labelToIndex + 1, totalXWidth),\n      filter: Object.assign({}, filter),\n      focusOn: focusOn !== undefined ? focusOn : prevState.focusOn,\n      minimapDelta: minimapDelta !== undefined ? minimapDelta : prevState.minimapDelta,\n    },\n    yRanges,\n    datasetsOpacity,\n    range,\n  );\n}\n\nfunction calculateYRanges(data, filter, labelFromIndex, labelToIndex, prevState) {\n  const secondaryYAxisDataset = data.hasSecondYAxis && data.datasets.slice(-1)[0];\n  const filteredDatasets = data.datasets.filter((d) => filter[d.key] && d !== secondaryYAxisDataset);\n\n  const yRanges = calculateYRangesForGroup(data, labelFromIndex, labelToIndex, prevState, filteredDatasets);\n\n  if (secondaryYAxisDataset) {\n    const {\n      yMinViewport: yMinViewportSecond,\n      yMaxViewport: yMaxViewportSecond,\n      yMinMinimap: yMinMinimapSecond,\n      yMaxMinimap: yMaxMinimapSecond,\n    } = calculateYRangesForGroup(data, labelFromIndex, labelToIndex, prevState, [secondaryYAxisDataset]);\n\n    Object.assign(yRanges, {\n      yMinViewportSecond,\n      yMaxViewportSecond,\n      yMinMinimapSecond,\n      yMaxMinimapSecond,\n    });\n  }\n\n  return yRanges;\n}\n\nfunction calculateYRangesForGroup(data, labelFromIndex, labelToIndex, prevState, datasets) {\n  const { min: yMinMinimapReal = prevState.yMinMinimap, max: yMaxMinimap = prevState.yMaxMinimap }\n    = getMaxMin(mergeArrays(datasets.map(({ yMax, yMin }) => [yMax, yMin])));\n  const yMinMinimap = yMinMinimapReal / yMaxMinimap > Y_AXIS_ZERO_BASED_THRESHOLD ? yMinMinimapReal : 0;\n\n  let yMinViewport;\n  let yMaxViewport;\n\n  if (labelFromIndex === 0 && labelToIndex === data.xLabels.length - 1) {\n    yMinViewport = yMinMinimap;\n    yMaxViewport = yMaxMinimap;\n  } else {\n    const filteredValues = datasets.map(({ values }) => values);\n    const viewportValues = filteredValues.map((values) => values.slice(labelFromIndex, labelToIndex + 1));\n    const viewportMaxMin = getMaxMin(mergeArrays(viewportValues));\n    const yMinViewportReal = viewportMaxMin.min !== undefined ? viewportMaxMin.min : prevState.yMinViewport;\n    yMaxViewport = viewportMaxMin.max !== undefined ? viewportMaxMin.max : prevState.yMaxViewport;\n    yMinViewport = yMinViewportReal / yMaxViewport > Y_AXIS_ZERO_BASED_THRESHOLD ? yMinViewportReal : 0;\n  }\n\n  return {\n    yMinViewport,\n    yMaxViewport,\n    yMinMinimap,\n    yMaxMinimap,\n  };\n}\n\nfunction calculateYRangesStacked(data, filter, labelFromIndex, labelToIndex, prevState) {\n  const filteredDatasets = data.datasets.filter((d) => filter[d.key]);\n  const filteredValues = filteredDatasets.map(({ values }) => values);\n\n  const sums = filteredValues.length ? sumArrays(filteredValues) : [];\n  const { max: yMaxMinimap = prevState.yMaxMinimap } = getMaxMin(sums);\n  const { max: yMaxViewport = prevState.yMaxViewport } = getMaxMin(sums.slice(labelFromIndex, labelToIndex + 1));\n\n  return {\n    yMinViewport: 0,\n    yMaxViewport,\n    yMinMinimap: 0,\n    yMaxMinimap,\n  };\n}\n\nfunction calculateXAxisScale(plotWidth, labelFromIndex, labelToIndex) {\n  const viewportLabelsCount = labelToIndex - labelFromIndex;\n  const maxColumns = Math.floor(plotWidth / AXES_MAX_COLUMN_WIDTH);\n\n  return xStepToScaleLevel(viewportLabelsCount / maxColumns);\n}\n\nfunction calculateYAxisScale(plotHeight, yMin, yMax) {\n  const availableHeight = plotHeight - X_AXIS_HEIGHT;\n  const viewportLabelsCount = yMax - yMin;\n  const maxRows = Math.floor(availableHeight / AXES_MAX_ROW_HEIGHT);\n\n  return yStepToScaleLevel(viewportLabelsCount / maxRows);\n}\n","import { SPEED_TEST_FAST_FPS, SPEED_TEST_INTERVAL, TRANSITION_DEFAULT_DURATION } from './constants';\n\nfunction transition(t) {\n  // faster\n  // return -t * (t - 2);\n  // easeOut\n  return 1 - Math.pow(1 - t, 1.675);\n}\n\nexport function createTransitionManager(onTick) {\n  const _transitions = {};\n\n  let _nextFrame = null;\n\n  let _testStartedAt = null;\n  let _fps = null;\n  let _testingFps = null;\n  let _slowDetectedAt = null;\n  let _startedAsSlow = null;\n\n  function add(prop, from, to, duration, options) {\n    _transitions[prop] = {\n      from,\n      to,\n      duration,\n      options,\n      current: from,\n      startedAt: Date.now(),\n      progress: 0,\n    };\n\n    if (!_nextFrame) {\n      _resetSpeedTest();\n      _nextFrame = requestAnimationFrame(_tick);\n    }\n  }\n\n  function remove(prop) {\n    delete _transitions[prop];\n\n    if (!isRunning()) {\n      cancelAnimationFrame(_nextFrame);\n      _nextFrame = null;\n    }\n  }\n\n  function get(prop) {\n    return _transitions[prop];\n  }\n\n  function getState() {\n    const state = {};\n\n    Object.keys(_transitions).forEach((prop) => {\n      const { current, from, to, progress } = _transitions[prop];\n      state[prop] = current;\n      // TODO perf lazy\n      state[`${prop}From`] = from;\n      state[`${prop}To`] = to;\n      state[`${prop}Progress`] = progress;\n    });\n\n    return state;\n  }\n\n  function isRunning() {\n    return Boolean(Object.keys(_transitions).length);\n  }\n\n  function isFast(forceCheck) {\n    if (!forceCheck && (_startedAsSlow || _slowDetectedAt)) {\n      return false;\n    }\n\n    return _fps === null || _fps >= SPEED_TEST_FAST_FPS;\n  }\n\n  function _tick() {\n    const isSlow = !isFast();\n    _speedTest();\n\n    const state = {};\n\n    Object.keys(_transitions).forEach((prop) => {\n      const { startedAt, from, to, duration = TRANSITION_DEFAULT_DURATION, options } = _transitions[prop];\n      const progress = Math.min(1, (Date.now() - startedAt) / duration);\n      let current = from + (to - from) * transition(progress);\n\n      if (options.includes('ceil')) {\n        current = Math.ceil(current);\n      } else if (options.includes('floor')) {\n        current = Math.floor(current);\n      }\n\n      _transitions[prop].current = current;\n      _transitions[prop].progress = progress;\n      state[prop] = current;\n\n      if (progress === 1) {\n        remove(prop);\n      }\n    });\n\n    if (!isSlow) {\n      onTick(state);\n    }\n\n    if (isRunning()) {\n      _nextFrame = requestAnimationFrame(_tick);\n    }\n  }\n\n  function _resetSpeedTest() {\n    _testStartedAt = null;\n    _testingFps = null;\n    if (_slowDetectedAt && Date.now() - _slowDetectedAt > 5000) {\n      _slowDetectedAt = null;\n    }\n    _startedAsSlow = Boolean(_slowDetectedAt) || !isFast(true);\n  }\n\n  function _speedTest() {\n    if (!_testStartedAt || (Date.now() - _testStartedAt) >= SPEED_TEST_INTERVAL) {\n      if (_testingFps) {\n        _fps = _testingFps;\n        if (!_slowDetectedAt && !isFast(true)) {\n          _slowDetectedAt = Date.now();\n        }\n      }\n      _testStartedAt = Date.now();\n      _testingFps = 0;\n    } else {\n      _testingFps++;\n    }\n  }\n\n  return { add, remove, get, getState, isRunning, isFast };\n}\n","export const createElement = (tagName = 'div') => {\n  return document.createElement(tagName);\n};\n\nexport function addEventListener(element, event, cb) {\n  element.addEventListener(event, cb);\n}\n\nexport function removeEventListener(element, event, cb) {\n  element.removeEventListener(event, cb);\n}\n","import { createElement } from './minifiers';\n\nexport function toggleText(element, newText, className = '', inverse = false) {\n  const container = element.parentNode;\n  container.classList.add('lovely-chart--transition-container');\n\n  const newElement = createElement(element.tagName);\n  newElement.className = `${className} lovely-chart--transition lovely-chart--position-${inverse ? 'top' : 'bottom'} lovely-chart--state-hidden`;\n  newElement.innerHTML = newText;\n\n  const selector = className.length ? `.${className.split(' ').join('.')}` : '';\n  const oldElements = container.querySelectorAll(`${selector}.lovely-chart--state-hidden`);\n  oldElements.forEach(e => e.remove());\n\n  element.classList.add('lovely-chart--transition');\n  element.classList.remove('lovely-chart--position-bottom', 'lovely-chart--position-top');\n  element.classList.add(inverse ? 'lovely-chart--position-bottom' : 'lovely-chart--position-top');\n  container.insertBefore(newElement, element.nextSibling);\n\n  toggleElementIn(newElement);\n  toggleElementOut(element);\n\n  return newElement;\n}\n\nfunction toggleElementIn(element) {\n  // Remove and add `animated` class to re-trigger animation\n  element.classList.remove('lovely-chart--state-animated');\n  element.classList.add('lovely-chart--state-animated');\n  element.classList.remove('lovely-chart--state-hidden');\n}\n\nfunction toggleElementOut(element) {\n  // Remove and add `animated` class to re-trigger animation\n  element.classList.remove('lovely-chart--state-animated');\n  element.classList.add('lovely-chart--state-animated');\n  element.classList.add('lovely-chart--state-hidden');\n}\n","import { MONTHS, WEEK_DAYS, WEEK_DAYS_SHORT } from './constants';\n\nexport function statsFormatDayHour(labels) {\n  return labels.map((value) => ({\n    value,\n    text: `${value}:00`,\n  }));\n}\n\nexport function statsFormatDayHourFull(value) {\n  return `${value}:00`;\n}\n\nexport function statsFormatDay(labels) {\n  return labels.map((value) => {\n    const date = new Date(value);\n    const day = date.getDate();\n    const month = MONTHS[date.getMonth()];\n\n    return ({\n      value,\n      text: `${day} ${month}`,\n    });\n  });\n}\n\nexport function statsFormatMin(labels) {\n  return labels.map((value) => ({\n    value,\n    text: new Date(value).toString().match(/(\\d+:\\d+):/)[1],\n  }));\n}\n\nexport function statsFormatText(labels) {\n  return labels.map((value, i) => {\n    return ({\n      value: i,\n      text: value,\n    });\n  });\n}\n\nexport function humanize(value, decimals = 1) {\n  if (value >= 1e6) {\n    return keepThreeDigits(value / 1e6, decimals) + 'M';\n  } else if (value >= 1e3) {\n    return keepThreeDigits(value / 1e3, decimals) + 'K';\n  }\n\n  return value;\n}\n\n// TODO perf\nfunction keepThreeDigits(value, decimals) {\n  return value\n    .toFixed(decimals)\n    .replace(/(\\d{3,})\\.\\d+/, '$1')\n    .replace(/\\.0+$/, '');\n}\n\nexport function formatInteger(n) {\n  return String(n).replace(/\\d(?=(\\d{3})+$)/g, '$& ');\n}\n\nexport function formatCryptoValue(n) {\n  return Number(n / 10 ** 9);\n}\n\nexport function getFullLabelDate(label, { isShort = false } = {}) {\n  return getLabelDate(label, { isShort, displayWeekDay: true });\n}\n\nexport function getLabelDate(label, { isShort = false, displayWeekDay = false, displayYear = true, displayHours = false } = {}) {\n  const { value } = label;\n  const date = new Date(value);\n  const weekDaysArray = isShort ? WEEK_DAYS_SHORT : WEEK_DAYS;\n\n  let string = `${date.getUTCDate()} ${MONTHS[date.getUTCMonth()]}`;\n  if (displayWeekDay) {\n    string = `${weekDaysArray[date.getUTCDay()]}, ` + string;\n  }\n  if (displayYear) {\n    string += ` ${date.getUTCFullYear()}`;\n  }\n  if (displayHours) {\n    string += `, ${('0' + date.getUTCHours()).slice(-2)}:${('0' + date.getUTCMinutes()).slice(-2)}`\n  }\n\n  return string;\n}\n\nexport function getLabelTime(label) {\n  return new Date(label.value).toString().match(/(\\d+:\\d+):/)[1];\n}\n","function detectSkin() {\n  return document.documentElement.classList.contains('theme-dark') ? 'skin-night' : 'skin-day';\n}\n\nlet skin = detectSkin();\n\nconst COLORS = {\n  'skin-day': {\n    'background': '#FFFFFF',\n    'text-color': '#222222',\n    'minimap-mask': '#E2EEF9/0.6',\n    'minimap-slider': '#C0D1E1',\n    'grid-lines': '#182D3B/0.1',\n    'zoom-out-text': '#108BE3',\n    'tooltip-background': '#FFFFFF',\n    'tooltip-arrow': '#D2D5D7',\n    'mask': '#FFFFFF/0.5',\n    'x-axis-text': '#252529/0.6',\n    'y-axis-text': '#252529/0.6',\n  },\n  'skin-night': {\n    'background': '#242F3E',\n    'text-color': '#FFFFFF',\n    'minimap-mask': '#304259/0.6',\n    'minimap-slider': '#56626D',\n    'grid-lines': '#FFFFFF/0.1',\n    'zoom-out-text': '#48AAF0',\n    'tooltip-background': '#1c2533',\n    'tooltip-arrow': '#D2D5D7',\n    'mask': '#242F3E/0.5',\n    'x-axis-text': '#A3B1C2/0.6',\n    'y-axis-text': '#A3B1C2/0.6',\n  },\n};\n\nconst styleElement = document.createElement('style');\nstyleElement.type = 'text/css';\nstyleElement.appendChild(document.createTextNode(''));\ndocument.head.appendChild(styleElement);\nconst styleSheet = styleElement.sheet;\n\ndocument.documentElement.addEventListener('darkmode', () => {\n  skin = detectSkin();\n});\n\nexport function createColors(datasetColors) {\n  const colors = {};\n  const baseClass = `.lovely-chart--color`;\n\n  ['skin-day', 'skin-night'].forEach((skin) => {\n    colors[skin] = {};\n\n    Object.keys(COLORS[skin]).forEach((prop) => {\n      colors[skin][prop] = hexToChannels(COLORS[skin][prop]);\n    });\n\n    Object.keys(datasetColors).forEach((key) => {\n      colors[skin][`dataset#${key}`] = hexToChannels(datasetColors[key]);\n\n      addCssRule(styleSheet, `.lovely-chart--tooltip-dataset-value${baseClass}-${datasetColors[key].slice(1)}`, `color: ${datasetColors[key]}`);\n      addCssRule(styleSheet, `.lovely-chart--button${baseClass}-${datasetColors[key].slice(1)}`, `border-color: ${datasetColors[key]}; color: ${datasetColors[key]}`);\n      addCssRule(styleSheet, `.lovely-chart--button.lovely-chart--state-checked${baseClass}-${datasetColors[key].slice(1)}`, `background-color: ${datasetColors[key]}`);\n    });\n  });\n\n  return colors;\n}\n\nexport function getCssColor(colors, key, opacity) {\n  return buildCssColor(colors[skin][key], opacity);\n}\n\nfunction hexToChannels(hexWithAlpha) {\n  const [hex, alpha] = hexWithAlpha.replace('#', '').split('/');\n\n  return [\n    parseInt(hex.slice(0, 2), 16),\n    parseInt(hex.slice(2, 4), 16),\n    parseInt(hex.slice(4, 6), 16),\n    alpha ? parseFloat(alpha) : 1,\n  ];\n}\n\nfunction buildCssColor([r, g, b, a = 1], opacity = 1) {\n  return `rgba(${r}, ${g}, ${b}, ${a * opacity})`;\n}\n\nfunction addCssRule(sheet, selector, rule) {\n  sheet.insertRule(`${selector} { ${rule} }`, sheet.cssRules.length);\n}\n","import { proxyMerge } from './utils';\n\nexport function createProjection(params) {\n  const {\n    begin,\n    end,\n    totalXWidth,\n    yMin,\n    yMax,\n    availableWidth,\n    availableHeight,\n    xPadding = 0,\n    yPadding = 0,\n  } = params;\n\n  let effectiveWidth = availableWidth;\n\n  // TODO bug get rid of padding jumps\n  if (begin === 0) {\n    effectiveWidth -= xPadding;\n  }\n  if (end === 1) {\n    effectiveWidth -= xPadding;\n  }\n  const xFactor = effectiveWidth / ((end !== begin ? end - begin : 1) * totalXWidth);\n  let xOffsetPx = (begin * totalXWidth) * xFactor;\n  if (begin === 0) {\n    xOffsetPx -= xPadding;\n  }\n\n  const effectiveHeight = availableHeight - yPadding;\n  const yFactor = effectiveHeight / (yMax - yMin);\n  const yOffsetPx = yMin * yFactor;\n\n  function getState() {\n    return { xFactor, xOffsetPx, availableHeight, yFactor, yOffsetPx };\n  }\n\n  function findClosestLabelIndex(xPx) {\n    return Math.round((xPx + xOffsetPx) / xFactor);\n  }\n\n  function copy(overrides, cons) {\n    return createProjection(proxyMerge(params, overrides), cons);\n  }\n\n  function getCenter() {\n    return [\n      availableWidth / 2,\n      availableHeight - effectiveHeight / 2,\n    ];\n  }\n\n  function getSize() {\n    return [availableWidth, effectiveHeight];\n  }\n\n  function getParams() {\n    return params;\n  }\n\n  return {\n    findClosestLabelIndex,\n    copy,\n    getCenter,\n    getSize,\n    getParams,\n    getState,\n  };\n}\n\nexport function toPixels(projection, labelIndex, value) {\n  const { xFactor, xOffsetPx, availableHeight, yFactor, yOffsetPx } = projection.getState();\n\n  return [\n    labelIndex * xFactor - xOffsetPx,\n    availableHeight - (value * yFactor - yOffsetPx),\n  ];\n}\n","import { DPR } from './constants';\nimport { createElement } from './minifiers';\n\nexport function setupCanvas(container, { width, height }) {\n  const canvas = createElement('canvas');\n\n  canvas.width = width * DPR;\n  canvas.height = height * DPR;\n  canvas.style.width = '100%';\n  canvas.style.height = `${height}px`;\n\n  const context = canvas.getContext('2d');\n  context.scale(DPR, DPR);\n\n  container.appendChild(canvas);\n\n  return { canvas, context };\n}\n\nexport function clearCanvas(canvas, context) {\n  context.clearRect(0, 0, canvas.width, canvas.height);\n}\n","import { sumArrays } from './utils';\n\nexport function preparePoints(data, datasets, range, visibilities, bounds, pieToArea) {\n  let values = datasets.map(({ values }) => (\n    values.slice(range.from, range.to + 1)\n  ));\n\n  if (data.isPie && !pieToArea) {\n    values = prepareSumsByX(values);\n  }\n\n  const points = values.map((datasetValues, i) => (\n    datasetValues.map((value, j) => {\n      let visibleValue = value;\n\n      if (data.isStacked) {\n        visibleValue *= visibilities[i];\n      }\n\n      return {\n        labelIndex: range.from + j,\n        value,\n        visibleValue,\n        stackOffset: 0,\n        stackValue: visibleValue,\n      };\n    })\n  ));\n\n  if (data.isPercentage) {\n    preparePercentage(points, bounds);\n  }\n\n  if (data.isStacked) {\n    prepareStacked(points);\n  }\n\n  return points;\n}\n\nfunction getSumsByY(points) {\n  return sumArrays(points.map((datasetPoints) => (\n    datasetPoints.map(({ visibleValue }) => visibleValue)\n  )));\n}\n\n// TODO perf cache for [0..1], use in state\nfunction preparePercentage(points, bounds) {\n  const sumsByY = getSumsByY(points);\n\n  points.forEach((datasetPoints) => {\n    datasetPoints.forEach((point, j) => {\n      point.percent = point.visibleValue / sumsByY[j];\n      point.visibleValue = point.percent * bounds.yMax;\n    });\n  });\n}\n\nfunction prepareStacked(points) {\n  const accum = [];\n\n  points.forEach((datasetPoints) => {\n    datasetPoints.forEach((point, j) => {\n      if (accum[j] === undefined) {\n        accum[j] = 0;\n      }\n\n      point.stackOffset = accum[j];\n      accum[j] += point.visibleValue;\n      point.stackValue = accum[j];\n    });\n  });\n}\n\nfunction prepareSumsByX(values) {\n  return values.map((datasetValues) => (\n    [datasetValues.reduce((sum, value) => sum + value, 0)]\n  ));\n}\n","export const simplify = (() => {\n  function simplify(points, indexes, fixedPoints) {\n    if (points.length < 6) {\n      return function () {\n        return {\n          points: points,\n          indexes: indexes,\n          removed: [],\n        };\n      };\n    }\n\n    let worker = precalculate(points, fixedPoints);\n\n    return function (delta) {\n      let result = [],\n        resultIndexes = [],\n        removed = [];\n\n      let delta2 = delta * delta,\n        markers = worker(delta2);\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        if (markers[i] >= delta2 || i == 0 || i == l - 1) {\n          result.push(points[i]);\n          resultIndexes.push(indexes ? indexes[i] : i);\n        } else {\n          removed.push(i);\n        }\n      }\n      return {\n        points: result,\n        indexes: resultIndexes,\n        removed: removed,\n      };\n    };\n  }\n\n  let E1 = 1.0 / Math.pow(2, 22), // максимальная дельта\n    MAXLIMIT = 100000;\n\n  function precalculate(points, fixedPoints) {\n\n    let len = points.length,\n      distances = [],\n      queue = [],\n      maximumDelta;\n    for (let i = 0, l = points.length; i < l; ++i) {\n      distances[i] = 0;\n    }\n\n    if (!fixedPoints) {\n      fixedPoints = [];\n    }\n\n    //инициализируем дерево срединным значением\n    //чтобы не попадает в ситуации когда начало линии близко к концу(те полигон)\n    //и правильные расчеты сложны\n    let subdivisionTree = 0;\n\n    for (let i = 0, l = fixedPoints.length; i < l; ++i) {\n      distances[fixedPoints[i]] = MAXLIMIT;\n    }\n\n\n    function worker(params) {\n\n      let start = params.start,\n        end = params.end,\n        record = params.record,\n        currentLimit = params.currentLimit,\n        usedDistance = 0;\n\n      if (!record) {\n        //let deltaShifts = getDeltaShifts(points);\n        let usedIndex = -1,\n          vector = [\n            points[end][0] - points[start][0],\n            points[end][1] - points[start][1],\n          ];\n        for (let i = 0, l = fixedPoints.length; i < l; ++i) {\n          let fixId = fixedPoints[i];\n          if (fixId > start) {\n            if (fixId < end) {\n              usedIndex = fixId;\n              usedDistance = MAXLIMIT;\n              break;\n            } else {\n              break;\n            }\n          }\n        }\n        if (usedIndex < 0) {\n          if (Math.abs(vector[0]) > E1 || Math.abs(vector[1]) > E1) {\n            let vectorLength = vector[0] * vector[0] + vector[1] * vector[1],\n              vectorLength_1 = +1.0 / vectorLength;\n\n            for (let i = start + 1; i < end; ++i) {\n              let segmentDistance = pointToSegmentDistanceSquare(points[i], points[start], points[end], vector, vectorLength_1);\n\n              if (segmentDistance > usedDistance) {\n                usedIndex = i;\n                usedDistance = segmentDistance;\n              }\n            }\n\n          } else {\n            //фиксируем на среднинной точке\n            usedIndex = Math.round((start + end) * 0.5);\n            usedDistance = currentLimit;\n          }\n          distances[usedIndex] = usedDistance;\n        }\n        record = {\n          start: start,\n          end: end,\n          index: usedIndex,\n          distance: usedDistance,\n        };\n      }\n\n      if (record.index && record.distance > maximumDelta) {\n        if (record.index - start >= 2) {\n          queue.push({\n            start: start,\n            end: record.index,\n            record: record.left,\n            currentLimit: record.distance,\n            parent: record,\n            parentProperty: 'left',\n          });\n        }\n        if (end - record.index >= 2) {\n          queue.push({\n            start: record.index,\n            end: end,\n            record: record.right,\n            currentLimit: record.distance,\n            parent: record,\n            parentProperty: 'right',\n          });\n        }\n      }\n\n      return record;\n    }\n\n    function tick() {\n      let request = queue.pop(),\n        result = worker(request);\n\n      if (request.parent && request.parentProperty) {\n        request.parent[request.parentProperty] = result;\n      }\n\n      return result;\n    }\n\n    return function (delta) {\n      maximumDelta = delta;\n      queue.push({\n        start: 0,\n        end: len - 1,\n        record: subdivisionTree,\n        currentLimit: MAXLIMIT,\n      });\n      subdivisionTree = tick();\n\n      while (queue.length) {\n        tick();\n      }\n\n      return distances;\n    };\n\n  }\n\n  function pointToSegmentDistanceSquare(p, v1, v2, dv, dvlen_1) {\n\n    let t;\n    let vx = +v1[0],\n      vy = +v1[1];\n\n    t = +((p[0] - vx) * dv[0] + (p[1] - vy) * dv[1]) * (dvlen_1);\n\n    if (t > 1) {\n      vx = +v2[0];\n      vy = +v2[1];\n    } else if (t > 0) {\n      vx += +dv[0] * t;\n      vy += +dv[1] * t;\n    }\n\n    let a = +p[0] - vx,\n      b = +p[1] - vy;\n\n    return +a * a + b * b;\n  }\n\n  return simplify;\n})();\n","import { getCssColor } from './skin';\nimport { mergeArrays } from './utils';\nimport { getPieRadius, getPieTextShift, getPieTextSize } from './formulas';\nimport { PLOT_BARS_WIDTH_SHIFT, PLOT_PIE_SHIFT, PIE_MINIMUM_VISIBLE_PERCENT } from './constants';\nimport { simplify } from './simplify';\nimport { toPixels } from './Projection';\n\nexport function drawDatasets(\n  context, state, data,\n  range, points, projection, secondaryPoints, secondaryProjection,\n  lineWidth, visibilities, colors, pieToBar, simplification,\n) {\n  data.datasets.forEach(({ key, type, hasOwnYAxis }, i) => {\n    if (!visibilities[i]) {\n      return;\n    }\n\n    const options = {\n      color: getCssColor(colors, `dataset#${key}`),\n      lineWidth,\n      opacity: data.isStacked ? 1 : visibilities[i],\n      simplification,\n    };\n\n    const datasetType = type === 'pie' && pieToBar ? 'bar' : type;\n    let datasetPoints = hasOwnYAxis ? secondaryPoints : points[i];\n    let datasetProjection = hasOwnYAxis ? secondaryProjection : projection;\n\n    if (datasetType === 'area') {\n      const { yMin, yMax } = projection.getParams();\n      const yHeight = yMax - yMin;\n      const bottomLine = [\n        { labelIndex: range.from, stackValue: 0 },\n        { labelIndex: range.to, stackValue: 0 },\n      ];\n      const topLine = [\n        { labelIndex: range.to, stackValue: yHeight },\n        { labelIndex: range.from, stackValue: yHeight },\n      ];\n\n      datasetPoints = mergeArrays([points[i - 1] || bottomLine, topLine]);\n    }\n\n    if (datasetType === 'pie') {\n      options.center = projection.getCenter();\n      options.radius = getPieRadius(projection);\n      options.pointerVector = state.focusOn;\n    }\n\n    if (datasetType === 'bar') {\n      const [x0] = toPixels(projection, 0, 0);\n      const [x1] = toPixels(projection, 1, 0);\n\n      options.lineWidth = x1 - x0;\n      options.focusOn = state.focusOn;\n    }\n\n    drawDataset(datasetType, context, datasetPoints, datasetProjection, options);\n  });\n\n  if (state.focusOn && (data.isBars || data.isSteps)) {\n    const [x0] = toPixels(projection, 0, 0);\n    const [x1] = toPixels(projection, 1, 0);\n\n    drawBarsMask(context, projection, {\n      focusOn: state.focusOn,\n      color: getCssColor(colors, 'mask'),\n      lineWidth: data.isSteps ? x1 - x0 + lineWidth : x1 - x0,\n    });\n  }\n}\n\nfunction drawDataset(type, ...args) {\n  switch (type) {\n    case 'line':\n      return drawDatasetLine(...args);\n    case 'bar':\n      return drawDatasetBars(...args);\n    case 'step':\n      return drawDatasetSteps(...args);\n    case 'area':\n      return drawDatasetArea(...args);\n    case 'pie':\n      return drawDatasetPie(...args);\n  }\n}\n\nfunction drawDatasetLine(context, points, projection, options) {\n  context.beginPath();\n\n  let pixels = [];\n\n  for (let j = 0, l = points.length; j < l; j++) {\n    const { labelIndex, stackValue } = points[j];\n    pixels.push(toPixels(projection, labelIndex, stackValue));\n  }\n\n  if (options.simplification) {\n    const simplifierFn = simplify(pixels);\n    pixels = simplifierFn(options.simplification).points;\n  }\n\n  pixels.forEach(([x, y]) => {\n    context.lineTo(x, y);\n  });\n\n  context.save();\n  context.strokeStyle = options.color;\n  context.lineWidth = options.lineWidth;\n  context.globalAlpha = options.opacity;\n  context.lineJoin = 'bevel';\n  context.lineCap = 'butt';\n  context.stroke();\n  context.restore();\n}\n\n// TODO try areas\nfunction drawDatasetBars(context, points, projection, options) {\n  const { yMin } = projection.getParams();\n\n  context.save();\n  context.globalAlpha = options.opacity;\n  context.fillStyle = options.color;\n\n  for (let j = 0, l = points.length; j < l; j++) {\n    const { labelIndex, stackValue, stackOffset = 0 } = points[j];\n\n    const [, yFrom] = toPixels(projection, labelIndex, Math.max(stackOffset, yMin));\n    const [x, yTo] = toPixels(projection, labelIndex, stackValue);\n    const rectX = x - options.lineWidth / 2;\n    const rectY = yTo;\n    const rectW = options.opacity === 1 ?\n      options.lineWidth + PLOT_BARS_WIDTH_SHIFT :\n      options.lineWidth + PLOT_BARS_WIDTH_SHIFT * options.opacity;\n    const rectH = yFrom - yTo;\n\n    context.fillRect(rectX, rectY, rectW, rectH);\n  }\n\n  context.restore();\n}\n\nfunction drawDatasetSteps(context, points, projection, options) {\n  context.beginPath();\n\n  let pixels = [];\n\n  for (let j = 0, l = points.length; j < l; j++) {\n    const { labelIndex, stackValue } = points[j];\n    pixels.push(\n      toPixels(projection, labelIndex - PLOT_BARS_WIDTH_SHIFT, stackValue),\n      toPixels(projection, labelIndex + PLOT_BARS_WIDTH_SHIFT, stackValue),\n    );\n  }\n\n  pixels.forEach(([x, y]) => {\n    context.lineTo(x, y);\n  });\n\n  context.save();\n  context.strokeStyle = options.color;\n  context.lineWidth = options.lineWidth;\n  context.globalAlpha = options.opacity;\n  context.stroke();\n  context.restore();\n}\n\nfunction drawBarsMask(context, projection, options) {\n  const [xCenter, yCenter] = projection.getCenter();\n  const [width, height] = projection.getSize();\n\n  const [x] = toPixels(projection, options.focusOn, 0);\n\n  context.fillStyle = options.color;\n  context.fillRect(xCenter - width / 2, yCenter - height / 2, x - options.lineWidth / 2 + PLOT_BARS_WIDTH_SHIFT, height);\n  context.fillRect(x + options.lineWidth / 2, yCenter - height / 2, width - (x + options.lineWidth / 2), height);\n}\n\nfunction drawDatasetArea(context, points, projection, options) {\n  context.beginPath();\n\n  let pixels = [];\n\n  for (let j = 0, l = points.length; j < l; j++) {\n    const { labelIndex, stackValue } = points[j];\n    pixels.push(toPixels(projection, labelIndex, stackValue));\n  }\n\n  if (options.simplification) {\n    const simplifierFn = simplify(pixels);\n    pixels = simplifierFn(options.simplification).points;\n  }\n\n  pixels.forEach(([x, y]) => {\n    context.lineTo(x, y);\n  });\n\n  context.save();\n  context.fillStyle = options.color;\n  context.lineWidth = options.lineWidth;\n  context.globalAlpha = options.opacity;\n  context.lineJoin = 'bevel';\n  context.lineCap = 'butt';\n  context.fill();\n  context.restore();\n}\n\nfunction drawDatasetPie(context, points, projection, options) {\n  const { visibleValue, stackValue, stackOffset = 0 } = points[0];\n\n  if (!visibleValue) {\n    return;\n  }\n\n  const { yMin, yMax } = projection.getParams();\n  const percentFactor = 1 / (yMax - yMin);\n  const percent = visibleValue * percentFactor;\n\n  const beginAngle = stackOffset * percentFactor * Math.PI * 2 - Math.PI / 2;\n  const endAngle = stackValue * percentFactor * Math.PI * 2 - Math.PI / 2;\n\n  const { radius = 120, center: [x, y], pointerVector } = options;\n\n  const shift = (\n    pointerVector &&\n    beginAngle <= pointerVector.angle &&\n    pointerVector.angle < endAngle &&\n    pointerVector.distance <= radius\n  ) ? PLOT_PIE_SHIFT : 0;\n\n  const shiftAngle = (beginAngle + endAngle) / 2;\n  const directionX = Math.cos(shiftAngle);\n  const directionY = Math.sin(shiftAngle);\n  const shiftX = directionX * shift;\n  const shiftY = directionY * shift;\n\n  context.save();\n\n  context.beginPath();\n  context.fillStyle = options.color;\n  context.moveTo(x + shiftX, y + shiftY);\n  context.arc(x + shiftX, y + shiftY, radius, beginAngle, endAngle);\n  context.lineTo(x + shiftX, y + shiftY);\n  context.fill();\n\n  if (percent >= PIE_MINIMUM_VISIBLE_PERCENT) {\n    context.font = `700 ${getPieTextSize(percent, radius)}px Helvetica, Arial, sans-serif`;\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    context.fillStyle = 'white';\n    const textShift = getPieTextShift(percent, radius);\n    context.fillText(\n      `${Math.round(percent * 100)}%`, x + directionX * textShift + shiftX, y + directionY * textShift + shiftY,\n    );\n  }\n\n  context.restore();\n}\n","import { addEventListener, removeEventListener } from './minifiers';\nimport { LONG_PRESS_TIMEOUT } from './constants';\n\nexport function captureEvents(element, options) {\n  let captureEvent = null;\n  let longPressTimeout = null;\n\n  function onCapture(e) {\n    captureEvent = e;\n\n    if (e.type === 'mousedown') {\n      addEventListener(document, 'mousemove', onMove);\n      addEventListener(document, 'mouseup', onRelease);\n    } else if (e.type === 'touchstart') {\n      addEventListener(document, 'touchmove', onMove);\n      addEventListener(document, 'touchend', onRelease);\n      addEventListener(document, 'touchcancel', onRelease);\n\n      // https://stackoverflow.com/questions/11287877/how-can-i-get-e-offsetx-on-mobile-ipad\n      // Android does not have this value, and iOS has it but as read-only.\n      if (e.pageX === undefined) {\n        e.pageX = e.touches[0].pageX;\n      }\n    }\n\n    if (options.draggingCursor) {\n      document.body.classList.add(`cursor-${options.draggingCursor}`);\n    }\n\n    options.onCapture && options.onCapture(e);\n\n    if (options.onLongPress) {\n      longPressTimeout = setTimeout(() => options.onLongPress(), LONG_PRESS_TIMEOUT);\n    }\n  }\n\n  function onRelease(e) {\n    if (captureEvent) {\n      if (longPressTimeout) {\n        clearTimeout(longPressTimeout);\n        longPressTimeout = null;\n      }\n\n      if (options.draggingCursor) {\n        document.body.classList.remove(`cursor-${options.draggingCursor}`);\n      }\n\n      removeEventListener(document, 'mouseup', onRelease);\n      removeEventListener(document, 'mousemove', onMove);\n      removeEventListener(document, 'touchcancel', onRelease);\n      removeEventListener(document, 'touchend', onRelease);\n      removeEventListener(document, 'touchmove', onMove);\n\n      captureEvent = null;\n\n      options.onRelease && options.onRelease(e);\n    }\n  }\n\n  function onMove(e) {\n    if (captureEvent) {\n      if (longPressTimeout) {\n        clearTimeout(longPressTimeout);\n        longPressTimeout = null;\n      }\n\n      if (e.type === 'touchmove' && e.pageX === undefined) {\n        e.pageX = e.touches[0].pageX;\n      }\n\n      options.onDrag && options.onDrag(e, captureEvent, {\n        dragOffsetX: e.pageX - captureEvent.pageX,\n      });\n    }\n  }\n\n  addEventListener(element, 'mousedown', onCapture);\n  addEventListener(element, 'touchstart', onCapture);\n}\n","import { setupCanvas, clearCanvas } from './canvas';\nimport { BALLOON_OFFSET, X_AXIS_HEIGHT } from './constants';\nimport { getPieRadius } from './formulas';\nimport {formatCryptoValue, formatInteger, getLabelDate, getLabelTime, statsFormatDayHourFull} from './format';\nimport { getCssColor } from './skin';\nimport { throttle, throttleWithRaf } from './utils';\nimport { addEventListener, createElement } from './minifiers';\nimport { toPixels } from './Projection';\n\nexport function createTooltip(container, data, plotSize, colors, onZoom, onFocus) {\n  let _state;\n  let _points;\n  let _projection;\n  let _secondaryPoints;\n  let _secondaryProjection;\n\n  let _element;\n  let _canvas;\n  let _context;\n  let _balloon;\n\n  let _offsetX;\n  let _offsetY;\n  let _clickedOnLabel = null;\n\n  let _isZoomed = false;\n  let _isZooming = false;\n\n  const _selectLabelOnRaf = throttleWithRaf(_selectLabel);\n  const _throttledUpdateContent = throttle(_updateContent, 100, true, true);\n\n  _setupLayout();\n\n  function update(state, points, projection, secondaryPoints, secondaryProjection) {\n    _state = state;\n    _points = points;\n    _projection = projection;\n    _secondaryPoints = secondaryPoints;\n    _secondaryProjection = secondaryProjection;\n    _selectLabel(true);\n  }\n\n  function toggleLoading(isLoading) {\n    _balloon.classList.toggle('lovely-chart--state-loading', isLoading);\n\n    if (!isLoading) {\n      _clear();\n    }\n  }\n\n  function toggleIsZoomed(isZoomed) {\n    if (isZoomed !== _isZoomed) {\n      _isZooming = true;\n    }\n    _isZoomed = isZoomed;\n    _balloon.classList.toggle('lovely-chart--state-inactive', isZoomed);\n  }\n\n  function _setupLayout() {\n    _element = createElement();\n    _element.className = `lovely-chart--tooltip`;\n\n    _setupCanvas();\n    _setupBalloon();\n\n    if ('ontouchstart' in window) {\n      addEventListener(_element, 'touchmove', _onMouseMove);\n      addEventListener(_element, 'touchstart', _onMouseMove);\n      addEventListener(document, 'touchstart', _onDocumentMove);\n    } else {\n      addEventListener(_element, 'mousemove', _onMouseMove);\n      addEventListener(_element, 'click', _onClick);\n      addEventListener(document, 'mousemove', _onDocumentMove);\n    }\n\n    container.appendChild(_element);\n  }\n\n  function _setupCanvas() {\n    const { canvas, context } = setupCanvas(_element, plotSize);\n\n    _canvas = canvas;\n    _context = context;\n  }\n\n  function _setupBalloon() {\n    _balloon = createElement();\n    _balloon.className = `lovely-chart--tooltip-balloon${!data.isZoomable ? ' lovely-chart--state-inactive' : ''}`;\n    _balloon.innerHTML = '<div class=\"lovely-chart--tooltip-title\"></div><div class=\"lovely-chart--tooltip-legend\"></div><div class=\"lovely-chart--spinner\"></div>';\n\n    if ('ontouchstart' in window && data.isZoomable) {\n      addEventListener(_balloon, 'click', _onBalloonClick);\n    }\n\n    _element.appendChild(_balloon);\n  }\n\n  function _onMouseMove(e) {\n    if (e.target === _balloon || _balloon.contains(e.target) || _clickedOnLabel) {\n      return;\n    }\n\n    _isZooming = false;\n\n    const pageOffset = _getPageOffset(_element);\n    _offsetX = (e.touches ? e.touches[0].clientX : e.clientX) - pageOffset.left;\n    _offsetY = (e.touches ? e.touches[0].clientY : e.clientY) - pageOffset.top;\n\n    _selectLabelOnRaf();\n  }\n\n  function _onDocumentMove(e) {\n    if (_offsetX !== null && e.target !== _element && !_element.contains(e.target)) {\n      _clear();\n    }\n  }\n\n  function _onClick(e) {\n    if (_isZooming) {\n      return;\n    }\n\n    if (data.isZoomable) {\n      const oldLabelIndex = _clickedOnLabel;\n\n      _clickedOnLabel = null;\n      _onMouseMove(e, true);\n\n      const newLabelIndex = _getLabelIndex();\n      if (newLabelIndex !== oldLabelIndex) {\n        _clickedOnLabel = newLabelIndex;\n      }\n\n      onZoom(newLabelIndex);\n    }\n  }\n\n  function _onBalloonClick() {\n    if (_balloon.classList.contains('lovely-chart--state-inactive')) {\n      return;\n    }\n\n    const labelIndex = _projection.findClosestLabelIndex(_offsetX);\n    onZoom(labelIndex);\n  }\n\n  function _clear(isExternal) {\n    _offsetX = null;\n    _clickedOnLabel = null;\n    clearCanvas(_canvas, _context);\n    _hideBalloon();\n\n    if (!isExternal && onFocus) {\n      onFocus(null);\n    }\n  }\n\n  function _getLabelIndex() {\n    const labelIndex = _projection.findClosestLabelIndex(_offsetX);\n    return labelIndex < _state.labelFromIndex || labelIndex > _state.labelToIndex ? null : labelIndex;\n  }\n\n  function _selectLabel(isExternal) {\n    if (!_offsetX || !_state || _isZooming) {\n      return;\n    }\n\n    const labelIndex = _getLabelIndex();\n    if (labelIndex === null) {\n      _clear(isExternal);\n      return;\n    }\n\n    const pointerVector = getPointerVector();\n    const shouldShowBalloon = data.isPie ? pointerVector.distance <= getPieRadius(_projection) : true;\n\n    if (!isExternal && onFocus) {\n      if (data.isPie) {\n        onFocus(pointerVector);\n      } else {\n        onFocus(labelIndex);\n      }\n    }\n\n    function getValue(values, labelIndex) {\n      if (data.isPie) {\n        return values.slice(_state.labelFromIndex, _state.labelToIndex + 1).reduce((a, x) => a + x, 0);\n      }\n\n      return values[labelIndex];\n    }\n\n    const [xPx] = toPixels(_projection, labelIndex, 0);\n    const statistics = data.datasets\n      .map(({ key, name, values, hasOwnYAxis }, i) => ({\n        key,\n        name,\n        value: getValue(values, labelIndex),\n        hasOwnYAxis,\n        originalIndex: i,\n      }))\n      .filter(({ key }) => _state.filter[key]);\n\n    if (statistics.length && shouldShowBalloon) {\n      _updateBalloon(statistics, labelIndex);\n    } else {\n      _hideBalloon();\n    }\n\n    clearCanvas(_canvas, _context);\n    if (data.isLines || data.isAreas) {\n      if (data.isLines) {\n        _drawCircles(statistics, labelIndex);\n      }\n\n      _drawTail(xPx, plotSize.height - X_AXIS_HEIGHT, getCssColor(colors, 'grid-lines'));\n    }\n  }\n\n  function _drawCircles(statistics, labelIndex) {\n    statistics.forEach(({ value, key, hasOwnYAxis, originalIndex }) => {\n      const pointIndex = labelIndex - _state.labelFromIndex;\n      const point = hasOwnYAxis ? _secondaryPoints[pointIndex] : _points[originalIndex][pointIndex];\n\n      if (!point) {\n        return;\n      }\n\n      const [x, y] = hasOwnYAxis\n        ? toPixels(_secondaryProjection, labelIndex, point.stackValue)\n        : toPixels(_projection, labelIndex, point.stackValue);\n\n      // TODO animate\n      _drawCircle(\n        [x, y],\n        getCssColor(colors, `dataset#${key}`),\n        getCssColor(colors, 'background'),\n      );\n    });\n  }\n\n  function _drawCircle([xPx, yPx], strokeColor, fillColor) {\n    _context.strokeStyle = strokeColor;\n    _context.fillStyle = fillColor;\n    _context.lineWidth = 2;\n\n    _context.beginPath();\n    _context.arc(xPx, yPx, 4, 0, 2 * Math.PI);\n    _context.fill();\n    _context.stroke();\n  }\n\n  function _drawTail(xPx, height, color) {\n    _context.strokeStyle = color;\n    _context.lineWidth = 1;\n\n    _context.beginPath();\n    _context.moveTo(xPx, 0);\n    _context.lineTo(xPx, height);\n    _context.stroke();\n  }\n\n  function _getBalloonLeftOffset(labelIndex) {\n    const meanLabel = (_state.labelFromIndex + _state.labelToIndex) / 2;\n    const { angle } = getPointerVector();\n\n    const shouldPlaceRight = data.isPie ? angle > Math.PI / 2 : labelIndex < meanLabel;\n\n    const leftOffset = shouldPlaceRight ? _offsetX + BALLOON_OFFSET : _offsetX - (_balloon.offsetWidth + BALLOON_OFFSET);\n\n    return Math.min(Math.max(0, leftOffset), container.offsetWidth - _balloon.offsetWidth);\n  }\n\n  function _getBalloonTopOffset() {\n    return data.isPie ? `${_offsetY}px` : 0;\n  }\n\n  function _updateBalloon(statistics, labelIndex) {\n    _balloon.style.transform = `translate3D(${_getBalloonLeftOffset(labelIndex)}px, ${_getBalloonTopOffset()}, 0)`;\n    _balloon.classList.add('lovely-chart--state-shown');\n\n    if (data.isPie) {\n      _updateContent(null, statistics);\n    } else {\n      _throttledUpdateContent(_getTitle(data, labelIndex), statistics);\n    }\n  }\n\n  function _getTitle(data, labelIndex) {\n    switch (data.tooltipFormatter) {\n      case 'statsFormatDayHourFull':\n        return statsFormatDayHourFull(data.xLabels[labelIndex].value);\n      case 'statsTooltipFormat(\\'day\\')':\n        return getLabelDate(data.xLabels[labelIndex]);\n      case 'statsTooltipFormat(\\'hour\\')':\n      case 'statsTooltipFormat(\\'5min\\')':\n        return getLabelTime(data.xLabels[labelIndex]);\n      default:\n        return data.xLabels[labelIndex].text;\n    }\n  }\n\n  function _isPieSectorSelected(statistics, value, totalValue, index, pointerVector) {\n    const offset = index > 0 ? statistics.slice(0, index).reduce((a, x) => a + x.value, 0) : 0;\n    const beginAngle = offset / totalValue * Math.PI * 2 - Math.PI / 2;\n    const endAngle = (offset + value) / totalValue * Math.PI * 2 - Math.PI / 2;\n\n    return pointerVector &&\n      beginAngle <= pointerVector.angle &&\n      pointerVector.angle < endAngle &&\n      pointerVector.distance <= getPieRadius(_projection);\n  }\n\n  function _updateTitle(title) {\n    const titleContainer = _balloon.children[0];\n\n    if (data.isPie) {\n      if (titleContainer) {\n        titleContainer.style.display = 'none';\n      }\n    } else {\n      if (titleContainer.style.display === 'none') {\n        titleContainer.style.display = '';\n      }\n      const currentTitle = titleContainer.querySelector(':not(.lovely-chart--state-hidden)');\n\n      if (!titleContainer.innerHTML || !currentTitle) {\n        titleContainer.innerHTML = `<span>${title}</span>`;\n      } else {\n        currentTitle.innerHTML = title;\n      }\n    }\n  }\n\n  function _insertNewDataSet(dataSetContainer, { name, key, value }, totalValue) {\n    const className = `lovely-chart--tooltip-dataset-value lovely-chart--position-right lovely-chart--color-${data.colors[key].slice(1)}`;\n    const newDataSet = createElement();\n    newDataSet.className = 'lovely-chart--tooltip-dataset';\n    newDataSet.setAttribute('data-present', 'true');\n    newDataSet.setAttribute('data-name', name);\n    newDataSet.innerHTML = `<span class=\"lovely-chart--dataset-title\">${name}</span><span class=\"${className}\">${formatInteger(value)}</span>`;\n    _renderPercentageValue(newDataSet, value, totalValue);\n\n    const totalText = dataSetContainer.querySelector(`[data-total=\"true\"]`);\n    if (totalText) {\n      dataSetContainer.insertBefore(newDataSet, totalText);\n    } else {\n      dataSetContainer.appendChild(newDataSet);\n    }\n  }\n\n  function _updateDataSet(currentDataSet, { key, value } = {}, totalValue) {\n    currentDataSet.setAttribute('data-present', 'true');\n\n    const valueElement = currentDataSet.querySelector(`.lovely-chart--tooltip-dataset-value.lovely-chart--color-${data.colors[key].slice(1)}:not(.lovely-chart--state-hidden)`);\n\n    if (data.isCurrency) {\n      valueElement.innerHTML = formatCryptoValue(value);\n    } else {\n      valueElement.innerHTML = formatInteger(value);\n    }\n\n    _renderPercentageValue(currentDataSet, value, totalValue);\n  }\n\n  function _renderPercentageValue(dataSet, value, totalValue) {\n    if (!data.isPercentage) {\n      return;\n    }\n\n    if (data.isPie) {\n      Array.from(dataSet.querySelectorAll(`.lovely-chart--percentage-title`)).forEach(e => e.remove());\n      return;\n    }\n\n    const percentageValue = totalValue ? Math.round(value / totalValue * 100) : 0;\n    const percentageElement = dataSet.querySelector(`.lovely-chart--percentage-title:not(.lovely-chart--state-hidden)`);\n\n    if (!percentageElement) {\n      const newPercentageTitle = createElement('span');\n      newPercentageTitle.className = 'lovely-chart--percentage-title lovely-chart--position-left';\n      newPercentageTitle.innerHTML = `${percentageValue}%`;\n      dataSet.prepend(newPercentageTitle);\n    } else {\n      percentageElement.innerHTML = `${percentageValue}%`;\n    }\n  }\n\n  function _updateDataSets(statistics) {\n    const dataSetContainer = _balloon.children[1];\n    if (data.isPie) {\n      dataSetContainer.classList.add('lovely-chart--tooltip-legend-pie');\n    }\n\n    Array.from(dataSetContainer.children).forEach((dataSet) => {\n      if (!data.isPie && dataSetContainer.classList.contains('lovely-chart--tooltip-legend-pie')) {\n        dataSet.remove();\n      } else {\n        dataSet.setAttribute('data-present', 'false');\n      }\n    });\n\n    const totalValue = statistics.reduce((a, x) => a + x.value, 0);\n    const pointerVector = getPointerVector();\n    const finalStatistics = data.isPie ? statistics.filter(({ value }, index) => _isPieSectorSelected(statistics, value, totalValue, index, pointerVector)) : statistics;\n\n    finalStatistics.forEach((statItem) => {\n      const currentDataSet = dataSetContainer.querySelector(`[data-name=\"${statItem.name}\"]`);\n\n      if (!currentDataSet) {\n        _insertNewDataSet(dataSetContainer, statItem, totalValue);\n      } else {\n        _updateDataSet(currentDataSet, statItem, totalValue);\n      }\n    });\n\n    if ((data.isBars || data.isSteps) && data.isStacked) {\n      _renderTotal(dataSetContainer, formatInteger(totalValue));\n    }\n\n    if (data.isCurrency) {\n      _renderCurrencyRate(dataSetContainer, formatCryptoValue(totalValue));\n    }\n\n    Array.from(dataSetContainer.querySelectorAll('[data-present=\"false\"]'))\n      .forEach((dataSet) => {\n        dataSet.remove();\n      });\n  }\n\n  function _updateContent(title, statistics) {\n    _updateTitle(title);\n    _updateDataSets(statistics);\n  }\n\n  function _renderTotal(dataSetContainer, totalValue) {\n    const totalText = dataSetContainer.querySelector(`[data-total=\"true\"]`);\n    const className = `lovely-chart--tooltip-dataset-value lovely-chart--position-right`;\n    if (!totalText) {\n      const newTotalText = createElement();\n      newTotalText.className = 'lovely-chart--tooltip-dataset';\n      newTotalText.setAttribute('data-present', 'true');\n      newTotalText.setAttribute('data-total', 'true');\n      newTotalText.innerHTML = `<span>All</span><span class=\"${className}\">${totalValue}</span>`;\n      dataSetContainer.appendChild(newTotalText);\n    } else {\n      totalText.setAttribute('data-present', 'true');\n\n      const valueElement = totalText.querySelector(`.lovely-chart--tooltip-dataset-value:not(.lovely-chart--state-hidden)`);\n      valueElement.innerHTML = totalValue;\n    }\n  }\n\n  function _renderCurrencyRate(dataSetContainer, totalValue) {\n    const totalText = dataSetContainer.querySelector(`[data-total=\"true\"]`);\n    const className = `lovely-chart--tooltip-dataset-value lovely-chart--position-right`;\n\n    const totalUsd = (parseFloat(totalValue) * data.currencyRate).toFixed(2);\n\n    if (!totalText) {\n      const newTotalText = createElement();\n      newTotalText.className = 'lovely-chart--tooltip-dataset';\n      newTotalText.setAttribute('data-present', 'true');\n      newTotalText.setAttribute('data-total', 'true');\n      newTotalText.innerHTML = `<span>USD ≈</span><span class=\"${className}\">$${totalUsd}</span>`;\n      dataSetContainer.appendChild(newTotalText);\n    } else {\n      totalText.setAttribute('data-present', 'true');\n\n      const valueElement = totalText.querySelector(`.lovely-chart--tooltip-dataset-value:not(.lovely-chart--state-hidden)`);\n      valueElement.innerHTML = `$${totalUsd}`;\n    }\n  }\n\n\n  function _hideBalloon() {\n    _balloon.classList.remove('lovely-chart--state-shown');\n  }\n\n  function getPointerVector() {\n    const { width, height } = _element.getBoundingClientRect();\n\n    const center = [width / 2, height / 2];\n    const angle = Math.atan2(_offsetY - center[1], _offsetX - center[0]);\n    const distance = Math.sqrt((_offsetX - center[0]) ** 2 + (_offsetY - center[1]) ** 2);\n\n    return {\n      angle: angle >= -Math.PI / 2 ? angle : 2 * Math.PI + angle,\n      distance,\n    };\n  }\n\n  function _getPageOffset(el) {\n    return el.getBoundingClientRect();\n  }\n\n  return { update, toggleLoading, toggleIsZoomed };\n}\n\n","import { getMaxMin } from './utils';\nimport { statsFormatDay, statsFormatDayHour, statsFormatText, statsFormatMin } from './format';\n\nexport function analyzeData(data) {\n  const { title, labelFormatter, tooltipFormatter, isStacked, isPercentage, isCurrency, currencyRate, hasSecondYAxis, onZoom, minimapRange, hideCaption, zoomOutLabel } = data;\n  const { datasets, labels } = prepareDatasets(data);\n\n  const colors = {};\n  let totalYMin = Infinity;\n  let totalYMax = -Infinity;\n  datasets.forEach(({ key, color, yMin, yMax }) => {\n    colors[key] = color;\n\n    if (yMin < totalYMin) {\n      totalYMin = yMin;\n    }\n\n    if (yMax > totalYMax) {\n      totalYMax = yMax;\n    }\n  });\n\n  let effectiveLabelFormatter = labelFormatter;\n  if (isCurrency) {\n    effectiveLabelFormatter = 'statsFormat(\\'day\\')';\n  }\n\n  let xLabels;\n  switch (effectiveLabelFormatter) {\n    case 'statsFormatDayHour':\n      xLabels = statsFormatDayHour(labels);\n      break;\n    case 'statsFormat(\\'day\\')':\n      xLabels = statsFormatDay(labels);\n      break;\n    case 'statsFormat(\\'hour\\')':\n    case 'statsFormat(\\'5min\\')':\n      xLabels = statsFormatMin(labels);\n      break;\n    default:\n      xLabels = statsFormatText(labels);\n      break;\n  }\n\n  const analyzed = {\n    title,\n    labelFormatter,\n    tooltipFormatter,\n    xLabels,\n    datasets,\n    isStacked,\n    isPercentage,\n    isCurrency,\n    currencyRate,\n    hasSecondYAxis,\n    onZoom,\n    isLines: data.type === 'line',\n    isBars: data.type === 'bar',\n    isSteps: data.type === 'step',\n    isAreas: data.type === 'area',\n    isPie: data.type === 'pie',\n    yMin: totalYMin,\n    yMax: totalYMax,\n    colors,\n    minimapRange,\n    hideCaption,\n    zoomOutLabel,\n  };\n\n  analyzed.shouldZoomToPie = !analyzed.onZoom && analyzed.isPercentage;\n  analyzed.isZoomable = analyzed.onZoom || analyzed.shouldZoomToPie;\n\n  return analyzed;\n}\n\nfunction prepareDatasets(data) {\n  const { type, labels, datasets, hasSecondYAxis } = data;\n\n  return {\n    labels: cloneArray(labels),\n    datasets: datasets.map(({ name, color, values }, i) => {\n      const { min: yMin, max: yMax } = getMaxMin(values);\n\n      return {\n        type,\n        key: `y${i}`,\n        name,\n        color,\n        values: cloneArray(values),\n        hasOwnYAxis: hasSecondYAxis && i === datasets.length - 1,\n        yMin,\n        yMax,\n      };\n    }),\n  };\n}\n\nfunction cloneArray(array) {\n  return array.slice(0);\n}\n","import { createStateManager } from './StateManager';\nimport { createHeader } from './Header';\nimport { createAxes } from './Axes';\nimport { createMinimap } from './Minimap';\nimport { createTooltip } from './Tooltip';\nimport { createTools } from './Tools';\nimport { createZoomer } from './Zoomer';\nimport { createColors } from './skin';\nimport { analyzeData } from './data';\nimport { setupCanvas, clearCanvas } from './canvas';\nimport { preparePoints } from './preparePoints';\nimport { createProjection } from './Projection';\nimport { drawDatasets } from './drawDatasets';\nimport { createElement } from './minifiers';\nimport { getFullLabelDate, getLabelDate } from './format';\nimport {\n  X_AXIS_HEIGHT,\n  GUTTER,\n  PLOT_TOP_PADDING,\n  PLOT_HEIGHT,\n  PLOT_LINE_WIDTH,\n  SIMPLIFIER_PLOT_FACTOR,\n} from './constants';\nimport { getSimplificationDelta, isDataRange } from './formulas';\nimport { debounce } from './utils';\nimport './styles/index.scss';\n\nfunction create(container, originalData) {\n  let _stateManager;\n\n  let _element;\n  let _plot;\n  let _context;\n  let _plotSize;\n\n  let _header;\n  let _axes;\n  let _minimap;\n  let _tooltip;\n  let _tools;\n  let _zoomer;\n\n  let _state;\n  let _windowWidth = window.innerWidth;\n\n  const _data = analyzeData(originalData);\n  const _colors = createColors(_data.colors);\n  const _redrawDebounced = debounce(_redraw, 500, false, true);\n\n  _setupComponents();\n  _setupGlobalListeners();\n\n  function _setupComponents() {\n    _setupContainer();\n    _header = createHeader(_element, _data.title, _data.zoomOutLabel, _onZoomOut);\n    _setupPlotCanvas();\n    _stateManager = createStateManager(_data, _plotSize, _onStateUpdate);\n    _axes = createAxes(_context, _data, _plotSize, _colors);\n    _minimap = createMinimap(_element, _data, _colors, _onRangeChange);\n    _tooltip = createTooltip(_element, _data, _plotSize, _colors, _onZoomIn, _onFocus);\n    _tools = createTools(_element, _data, _onFilterChange);\n    _zoomer = _data.isZoomable && createZoomer(_data, originalData, _colors, _stateManager, _element, _header, _minimap, _tooltip, _tools);\n    // hideOnScroll(_element);\n  }\n\n  function _setupContainer() {\n    _element = createElement();\n    _element.className = `lovely-chart--container${_data.shouldZoomToPie ? ' lovely-chart--container-type-pie' : ''}`;\n\n    container.appendChild(_element);\n  }\n\n  function _setupPlotCanvas() {\n    const { canvas, context } = setupCanvas(_element, {\n      width: _element.clientWidth,\n      height: PLOT_HEIGHT,\n    });\n\n    _plot = canvas;\n    _context = context;\n\n    _plotSize = {\n      width: _plot.offsetWidth,\n      height: _plot.offsetHeight,\n    };\n  }\n\n  function _onStateUpdate(state) {\n    _state = state;\n\n    const { datasets } = _data;\n    const range = {\n      from: state.labelFromIndex,\n      to: state.labelToIndex,\n    };\n    const boundsAndParams = {\n      begin: state.begin,\n      end: state.end,\n      totalXWidth: state.totalXWidth,\n      yMin: state.yMinViewport,\n      yMax: state.yMaxViewport,\n      availableWidth: _plotSize.width,\n      availableHeight: _plotSize.height - X_AXIS_HEIGHT,\n      xPadding: GUTTER,\n      yPadding: PLOT_TOP_PADDING,\n    };\n    const visibilities = datasets.map(({ key }) => state[`opacity#${key}`]);\n    const points = preparePoints(_data, datasets, range, visibilities, boundsAndParams);\n    const projection = createProjection(boundsAndParams);\n\n    let secondaryPoints = null;\n    let secondaryProjection = null;\n    if (_data.hasSecondYAxis) {\n      const secondaryDataset = datasets.find((d) => d.hasOwnYAxis);\n      const bounds = {\n        yMin: state.yMinViewportSecond,\n        yMax: state.yMaxViewportSecond,\n      };\n      secondaryPoints = preparePoints(_data, [secondaryDataset], range, visibilities, bounds)[0];\n      secondaryProjection = projection.copy(bounds);\n    }\n\n    if (!_data.hideCaption) {\n      _header.setCaption(_getCaption(state));\n    }\n\n    clearCanvas(_plot, _context);\n\n    const totalPoints = points.reduce((a, p) => a + p.length, 0);\n    const simplification = getSimplificationDelta(totalPoints) * SIMPLIFIER_PLOT_FACTOR;\n\n    drawDatasets(\n      _context, state, _data,\n      range, points, projection, secondaryPoints, secondaryProjection,\n      PLOT_LINE_WIDTH, visibilities, _colors, false, simplification,\n    );\n    if (!_data.isPie) {\n      _axes.drawYAxis(state, projection, secondaryProjection);\n      // TODO check isChanged\n      _axes.drawXAxis(state, projection);\n    }\n    _minimap.update(state);\n    _tooltip.update(state, points, projection, secondaryPoints, secondaryProjection);\n  }\n\n  function _onRangeChange(range) {\n    _stateManager.update({ range });\n  }\n\n  function _onFilterChange(filter) {\n    _stateManager.update({ filter });\n  }\n\n  function _onFocus(focusOn) {\n    if (_data.isBars || _data.isPie || _data.isSteps) {\n      // TODO animate\n      _stateManager.update({ focusOn });\n    }\n  }\n\n  function _onZoomIn(labelIndex) {\n    _zoomer.zoomIn(_state, labelIndex);\n  }\n\n  function _onZoomOut() {\n    _zoomer.zoomOut(_state);\n  }\n\n  function _setupGlobalListeners() {\n    document.documentElement.addEventListener('darkmode', () => {\n      _stateManager.update();\n    });\n\n    window.addEventListener('resize', () => {\n      if (window.innerWidth !== _windowWidth) {\n        _windowWidth = window.innerWidth;\n        _redrawDebounced();\n      }\n    });\n\n    window.addEventListener('orientationchange', () => {\n      _redrawDebounced();\n    });\n  }\n\n  function _redraw() {\n    Object.assign(_data, analyzeData(originalData));\n    _element.remove();\n    _setupComponents();\n  }\n\n  function _getCaption(state) {\n    let startIndex;\n    let endIndex;\n\n    if (_zoomer && _zoomer.isZoomed()) {\n      // TODO Fix label\n      startIndex = state.labelFromIndex === 0 ? 0 : state.labelFromIndex + 1;\n      endIndex = state.labelToIndex === state.totalXWidth - 1 ? state.labelToIndex : state.labelToIndex - 1;\n    } else {\n      startIndex = state.labelFromIndex;\n      endIndex = state.labelToIndex;\n    }\n\n    return isDataRange(_data.xLabels[startIndex], _data.xLabels[endIndex])\n      ? (\n        `${getLabelDate(_data.xLabels[startIndex])}` +\n        ' — ' +\n        `${getLabelDate(_data.xLabels[endIndex])}`\n      )\n      : getFullLabelDate(_data.xLabels[startIndex]);\n  }\n}\n\nexport { create };\n","import { createElement, addEventListener } from './minifiers';\nimport { toggleText } from './toggleText';\nimport { throttle } from './utils';\n\nexport function createHeader(container, title, zoomOutLabel = 'Zoom out', zoomOutCallback) {\n  let _element;\n  let _titleElement;\n  let _zoomOutElement;\n  let _captionElement;\n  let _isZooming;\n\n  const setCaptionThrottled = throttle(setCaption, 100, false);\n\n  _setupLayout();\n\n  function setCaption(caption) {\n    if (_isZooming) {\n      return;\n    }\n\n    _captionElement.innerHTML = caption;\n  }\n\n  function zoom(caption) {\n    _zoomOutElement = toggleText(_titleElement, zoomOutLabel, 'lovely-chart--header-title lovely-chart--header-zoom-out-control');\n    setTimeout(() => {\n      addEventListener(_zoomOutElement, 'click', _onZoomOut);\n    }, 500);\n\n    setCaption(caption);\n  }\n\n  function toggleIsZooming(isZooming) {\n    _isZooming = isZooming;\n  }\n\n  function _setupLayout() {\n    _element = createElement();\n    _element.className = 'lovely-chart--header';\n\n    _titleElement = createElement();\n    _titleElement.className = 'lovely-chart--header-title';\n    _titleElement.innerHTML = title;\n    _element.appendChild(_titleElement);\n\n    _captionElement = createElement();\n    _captionElement.className = 'lovely-chart--header-caption lovely-chart--position-right';\n    _element.appendChild(_captionElement);\n\n    container.appendChild(_element);\n  }\n\n  function _onZoomOut() {\n    _titleElement = toggleText(_zoomOutElement, title, 'lovely-chart--header-title', true);\n    _titleElement.classList.remove('lovely-chart--transition');\n\n    zoomOutCallback();\n  }\n\n  return {\n    setCaption: setCaptionThrottled,\n    zoom,\n    toggleIsZooming,\n  };\n}\n","import { GUTTER, AXES_FONT, X_AXIS_HEIGHT, X_AXIS_SHIFT_START, PLOT_TOP_PADDING } from './constants';\nimport { formatCryptoValue, humanize } from './format';\nimport { getCssColor } from './skin';\nimport { applyXEdgeOpacity, applyYEdgeOpacity, xScaleLevelToStep, yScaleLevelToStep } from './formulas';\nimport { toPixels } from './Projection';\n\nexport function createAxes(context, data, plotSize, colors) {\n  function drawXAxis(state, projection) {\n    context.clearRect(0, plotSize.height - X_AXIS_HEIGHT + 1, plotSize.width, X_AXIS_HEIGHT + 1);\n\n    const topOffset = plotSize.height - X_AXIS_HEIGHT / 2;\n    const scaleLevel = Math.floor(state.xAxisScale);\n    const step = xScaleLevelToStep(scaleLevel);\n    const opacityFactor = 1 - (state.xAxisScale - scaleLevel);\n\n    context.font = AXES_FONT;\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n\n    for (let i = state.labelFromIndex; i <= state.labelToIndex; i++) {\n      const shiftedI = i - X_AXIS_SHIFT_START;\n\n      if (shiftedI % step !== 0) {\n        continue;\n      }\n\n      const label = data.xLabels[i];\n      const [xPx] = toPixels(projection, i, 0);\n      let opacity = shiftedI % (step * 2) === 0 ? 1 : opacityFactor;\n      opacity = applyYEdgeOpacity(opacity, xPx, plotSize.width);\n\n      context.fillStyle = getCssColor(colors, 'x-axis-text', opacity);\n      context.fillText(label.text, xPx, topOffset);\n    }\n  }\n\n  function drawYAxis(state, projection, secondaryProjection) {\n    const {\n      yAxisScale, yAxisScaleFrom, yAxisScaleTo, yAxisScaleProgress = 0,\n      yMinViewport, yMinViewportFrom, yMinViewportTo,\n      yMaxViewport, yMaxViewportFrom, yMaxViewportTo,\n      yMinViewportSecond, yMinViewportSecondFrom, yMinViewportSecondTo,\n      yMaxViewportSecond, yMaxViewportSecondFrom, yMaxViewportSecondTo,\n    } = state;\n    const colorKey = secondaryProjection && `dataset#${data.datasets[0].key}`;\n    const isYChanging = yMinViewportFrom !== undefined || yMaxViewportFrom !== undefined;\n\n    if (data.isPercentage) {\n      _drawYAxisPercents(projection);\n    } else if (data.isCurrency) {\n      _drawYAxisCurrency(projection, data);\n    } else {\n      _drawYAxisScaled(\n        state,\n        projection,\n        Math.round(yAxisScaleTo || yAxisScale),\n        yMinViewportTo !== undefined ? yMinViewportTo : yMinViewport,\n        yMaxViewportTo !== undefined ? yMaxViewportTo : yMaxViewport,\n        yAxisScaleFrom ? yAxisScaleProgress : 1,\n        colorKey,\n      );\n    }\n\n    if (yAxisScaleProgress > 0 && isYChanging) {\n      _drawYAxisScaled(\n        state,\n        projection,\n        Math.round(yAxisScaleFrom),\n        yMinViewportFrom !== undefined ? yMinViewportFrom : yMinViewport,\n        yMaxViewportFrom !== undefined ? yMaxViewportFrom : yMaxViewport,\n        1 - yAxisScaleProgress,\n        colorKey,\n      );\n    }\n\n    if (secondaryProjection) {\n      const { yAxisScaleSecond, yAxisScaleSecondFrom, yAxisScaleSecondTo, yAxisScaleSecondProgress = 0 } = state;\n      const secondaryColorKey = `dataset#${data.datasets[data.datasets.length - 1].key}`;\n      const isYChanging = yMinViewportSecondFrom !== undefined || yMaxViewportSecondFrom !== undefined;\n\n      _drawYAxisScaled(\n        state,\n        secondaryProjection,\n        Math.round(yAxisScaleSecondTo || yAxisScaleSecond),\n        yMinViewportSecondTo !== undefined ? yMinViewportSecondTo : yMinViewportSecond,\n        yMaxViewportSecondTo !== undefined ? yMaxViewportSecondTo : yMaxViewportSecond,\n        yAxisScaleSecondFrom ? yAxisScaleSecondProgress : 1,\n        secondaryColorKey,\n        true,\n      );\n\n      if (yAxisScaleSecondProgress > 0 && isYChanging) {\n        _drawYAxisScaled(\n          state,\n          secondaryProjection,\n          Math.round(yAxisScaleSecondFrom),\n          yMinViewportSecondFrom !== undefined ? yMinViewportSecondFrom : yMinViewportSecond,\n          yMaxViewportSecondFrom !== undefined ? yMaxViewportSecondFrom : yMaxViewportSecond,\n          1 - yAxisScaleSecondProgress,\n          secondaryColorKey,\n          true,\n        );\n      }\n    }\n  }\n\n  function _drawYAxisScaled(state, projection, scaleLevel, yMin, yMax, opacity = 1, colorKey = null, isSecondary = false) {\n    const step = yScaleLevelToStep(scaleLevel);\n    const firstVisibleValue = Math.ceil(yMin / step) * step;\n    const lastVisibleValue = Math.floor(yMax / step) * step;\n\n    context.font = AXES_FONT;\n    context.textAlign = isSecondary ? 'right' : 'left';\n    context.textBaseline = 'bottom';\n\n    context.lineWidth = 1;\n\n    context.beginPath();\n\n    for (let value = firstVisibleValue; value <= lastVisibleValue; value += step) {\n      const [, yPx] = toPixels(projection, 0, value);\n      const textOpacity = applyXEdgeOpacity(opacity, yPx);\n\n      context.fillStyle = colorKey\n        ? getCssColor(colors, colorKey, textOpacity)\n        : getCssColor(colors, 'y-axis-text', textOpacity);\n\n      if (!isSecondary) {\n        context.fillText(humanize(value), GUTTER, yPx - GUTTER / 2);\n      } else {\n        context.fillText(humanize(value), plotSize.width - GUTTER, yPx - GUTTER / 2);\n      }\n\n      if (isSecondary) {\n        context.strokeStyle = getCssColor(colors, colorKey, opacity);\n\n        context.moveTo(plotSize.width - GUTTER, yPx);\n        context.lineTo(plotSize.width - GUTTER * 2, yPx);\n      } else {\n        context.moveTo(GUTTER, yPx);\n        context.strokeStyle = getCssColor(colors, 'grid-lines', opacity);\n        context.lineTo(plotSize.width - GUTTER, yPx);\n      }\n    }\n\n    context.stroke();\n  }\n\n  function _drawYAxisPercents(projection) {\n    const percentValues = [0, 0.25, 0.50, 0.75, 1];\n    const [, height] = projection.getSize();\n\n    context.font = AXES_FONT;\n    context.textAlign = 'left';\n    context.textBaseline = 'bottom';\n    context.lineWidth = 1;\n\n    context.beginPath();\n\n    percentValues.forEach((value) => {\n      const yPx = height - height * value + PLOT_TOP_PADDING;\n\n      context.fillStyle = getCssColor(colors, 'y-axis-text', 1);\n      context.fillText(`${value * 100}%`, GUTTER, yPx - GUTTER / 4);\n\n      context.moveTo(GUTTER, yPx);\n      context.strokeStyle = getCssColor(colors, 'grid-lines', 1);\n      context.lineTo(plotSize.width - GUTTER, yPx);\n    });\n\n    context.stroke();\n  }\n\n  function _drawYAxisCurrency(projection, data) {\n    const formatValue = data.datasets[0].values.map(value => formatCryptoValue(value));\n\n    const total = formatValue.reduce((sum, value) => sum + value, 0);\n    const avg1 = total / formatValue.length;\n    const avg2 = total / (formatValue.length / 2);\n    const avg3 = total / (formatValue.length / 3);\n\n    const averageRate1 = avg1 * data.currencyRate;\n    const averageRate2 = avg2 * data.currencyRate;\n    const averageRate3 = avg3 * data.currencyRate;\n\n    const totalAvg = [0, avg1, avg2, avg3];\n    const totalRate = [0, averageRate1, averageRate2, averageRate3];\n\n    const [, height] = projection.getSize();\n\n    context.font = AXES_FONT;\n    context.textAlign = 'left';\n    context.textBaseline = 'bottom';\n    context.lineWidth = 1;\n\n    context.beginPath();\n\n    totalAvg.forEach((value, index) => {\n      const yPx = height - height * (value / Math.max(...formatValue)) + PLOT_TOP_PADDING;\n\n      context.fillStyle = getCssColor(colors, 'y-axis-text', 1);\n\n      context.fillText(`${value.toFixed(2)} TON`, GUTTER, yPx - GUTTER / 4);\n\n      context.textAlign = 'right';\n      context.fillText(`$${totalRate[index].toFixed(2)}`, plotSize.width - GUTTER, yPx - GUTTER / 4);\n\n      context.textAlign = 'left';\n\n      context.moveTo(GUTTER, yPx);\n      context.strokeStyle = getCssColor(colors, 'grid-lines', 1);\n      context.lineTo(plotSize.width - GUTTER, yPx);\n    });\n\n    context.stroke();\n  }\n\n  return { drawXAxis, drawYAxis };\n}\n","import { setupCanvas, clearCanvas } from './canvas';\nimport { preparePoints } from './preparePoints';\nimport { createProjection } from './Projection';\nimport { drawDatasets } from './drawDatasets';\nimport { captureEvents } from './captureEvents';\nimport {\n  DEFAULT_RANGE,\n  MINIMAP_HEIGHT,\n  MINIMAP_EAR_WIDTH,\n  MINIMAP_MARGIN,\n  MINIMAP_LINE_WIDTH,\n  MINIMAP_MAX_ANIMATED_DATASETS,\n  SIMPLIFIER_MINIMAP_FACTOR,\n} from './constants';\nimport { proxyMerge, throttleWithRaf } from './utils';\nimport { createElement } from './minifiers';\nimport { getSimplificationDelta } from './formulas';\n\nexport function createMinimap(container, data, colors, rangeCallback) {\n  let _element;\n  let _canvas;\n  let _context;\n  let _canvasSize;\n  let _ruler;\n  let _slider;\n\n  let _capturedOffset;\n  let _range = {};\n  let _state;\n\n  const _updateRulerOnRaf = throttleWithRaf(_updateRuler);\n\n  _setupLayout();\n  _updateRange(data.minimapRange || DEFAULT_RANGE);\n\n  function update(newState) {\n    const { begin, end } = newState;\n    if (!_capturedOffset) {\n      _updateRange({ begin, end }, true);\n    }\n\n    if (data.datasets.length >= MINIMAP_MAX_ANIMATED_DATASETS) {\n      newState = newState.static;\n    }\n\n    if (!_isStateChanged(newState)) {\n      return;\n    }\n\n    _state = proxyMerge(newState, { focusOn: null });\n    clearCanvas(_canvas, _context);\n\n    _drawDatasets(_state);\n  }\n\n  function toggle(shouldShow) {\n    _element.classList.toggle('lovely-chart--state-hidden', !shouldShow);\n\n    requestAnimationFrame(() => {\n      _element.classList.toggle('lovely-chart--state-transparent', !shouldShow);\n    });\n  }\n\n  function _setupLayout() {\n    _element = createElement();\n\n    _element.className = 'lovely-chart--minimap';\n    _element.style.height = `${MINIMAP_HEIGHT}px`;\n\n    _setupCanvas();\n    _setupRuler();\n\n    container.appendChild(_element);\n\n    _canvasSize = {\n      width: _canvas.offsetWidth,\n      height: _canvas.offsetHeight,\n    };\n  }\n\n  function _getSize() {\n    return {\n      width: container.offsetWidth - MINIMAP_MARGIN * 2,\n      height: MINIMAP_HEIGHT,\n    };\n  }\n\n  function _setupCanvas() {\n    const { canvas, context } = setupCanvas(_element, _getSize());\n\n    _canvas = canvas;\n    _context = context;\n  }\n\n  function _setupRuler() {\n    _ruler = createElement();\n    _ruler.className = 'lovely-chart--minimap-ruler';\n    _ruler.innerHTML =\n      '<div class=\"lovely-chart--minimap-mask\"></div>' +\n      '<div class=\"lovely-chart--minimap-slider\">' +\n      '<div class=\"lovely-chart--minimap-slider-handle\"><span class=\"lovely-chart--minimap-slider-handle-pin\"></span></div>' +\n      '<div class=\"lovely-chart--minimap-slider-inner\"></div>' +\n      '<div class=\"lovely-chart--minimap-slider-handle\"><span class=\"lovely-chart--minimap-slider-handle-pin\"></span></div>' +\n      '</div>' +\n      '<div class=\"lovely-chart--minimap-mask\"></div>';\n\n    _slider = _ruler.children[1];\n\n    captureEvents(\n      _slider.children[1],\n      {\n        onCapture: _onDragCapture,\n        onDrag: _onSliderDrag,\n        onRelease: _onDragRelease,\n        draggingCursor: 'grabbing',\n      },\n    );\n\n    captureEvents(\n      _slider.children[0],\n      {\n        onCapture: _onDragCapture,\n        onDrag: _onLeftEarDrag,\n        onRelease: _onDragRelease,\n        draggingCursor: 'ew-resize',\n      },\n    );\n\n    captureEvents(\n      _slider.children[2],\n      {\n        onCapture: _onDragCapture,\n        onDrag: _onRightEarDrag,\n        onRelease: _onDragRelease,\n        draggingCursor: 'ew-resize',\n      },\n    );\n\n    _element.appendChild(_ruler);\n  }\n\n  function _isStateChanged(newState) {\n    if (!_state) {\n      return true;\n    }\n\n    const { datasets } = data;\n\n    if (datasets.some(({ key }) => _state[`opacity#${key}`] !== newState[`opacity#${key}`])) {\n      return true;\n    }\n\n    if (_state.yMaxMinimap !== newState.yMaxMinimap) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function _drawDatasets(state = {}) {\n    const { datasets } = data;\n    const range = {\n      from: 0,\n      to: state.totalXWidth,\n    };\n    const boundsAndParams = {\n      begin: 0,\n      end: 1,\n      totalXWidth: state.totalXWidth,\n      yMin: state.yMinMinimap,\n      yMax: state.yMaxMinimap,\n      availableWidth: _canvasSize.width,\n      availableHeight: _canvasSize.height,\n      yPadding: 1,\n    };\n    const visibilities = datasets.map(({ key }) => _state[`opacity#${key}`]);\n    const points = preparePoints(data, datasets, range, visibilities, boundsAndParams, true);\n    const projection = createProjection(boundsAndParams);\n\n    let secondaryPoints = null;\n    let secondaryProjection = null;\n    if (data.hasSecondYAxis) {\n      const secondaryDataset = datasets.find((d) => d.hasOwnYAxis);\n      const bounds = { yMin: state.yMinMinimapSecond, yMax: state.yMaxMinimapSecond };\n      secondaryPoints = preparePoints(data, [secondaryDataset], range, visibilities, bounds)[0];\n      secondaryProjection = projection.copy(bounds);\n    }\n\n    const totalPoints = points.reduce((a, p) => a + p.length, 0);\n    const simplification = getSimplificationDelta(totalPoints) * SIMPLIFIER_MINIMAP_FACTOR;\n\n    drawDatasets(\n      _context, state, data,\n      range, points, projection, secondaryPoints, secondaryProjection,\n      MINIMAP_LINE_WIDTH, visibilities, colors, true, simplification,\n    );\n  }\n\n  function _onDragCapture(e) {\n    e.preventDefault();\n    _capturedOffset = e.target.offsetLeft;\n  }\n\n  function _onDragRelease() {\n    _capturedOffset = null;\n  }\n\n  function _onSliderDrag(moveEvent, captureEvent, { dragOffsetX }) {\n    const minX1 = 0;\n    const maxX1 = _canvasSize.width - _slider.offsetWidth;\n\n    const newX1 = Math.max(minX1, Math.min(_capturedOffset + dragOffsetX - MINIMAP_EAR_WIDTH, maxX1));\n    const newX2 = newX1 + _slider.offsetWidth;\n    const begin = newX1 / _canvasSize.width;\n    const end = newX2 / _canvasSize.width;\n\n    _updateRange({ begin, end });\n  }\n\n  function _onLeftEarDrag(moveEvent, captureEvent, { dragOffsetX }) {\n    const minX1 = 0;\n    const maxX1 = _slider.offsetLeft + _slider.offsetWidth - MINIMAP_EAR_WIDTH * 2;\n\n    const newX1 = Math.min(maxX1, Math.max(minX1, _capturedOffset + dragOffsetX));\n    const begin = newX1 / _canvasSize.width;\n\n    _updateRange({ begin });\n  }\n\n  function _onRightEarDrag(moveEvent, captureEvent, { dragOffsetX }) {\n    const minX2 = _slider.offsetLeft + MINIMAP_EAR_WIDTH * 2;\n    const maxX2 = _canvasSize.width;\n\n    const newX2 = Math.max(minX2, Math.min(_capturedOffset + MINIMAP_EAR_WIDTH + dragOffsetX, maxX2));\n    const end = newX2 / _canvasSize.width;\n\n    _updateRange({ end });\n  }\n\n  function _updateRange(range, isExternal) {\n    let nextRange = Object.assign({}, _range, range);\n\n    if (_state && _state.minimapDelta && !isExternal) {\n      nextRange = _adjustDiscreteRange(nextRange);\n    }\n\n    if (nextRange.begin === _range.begin && nextRange.end === _range.end) {\n      return;\n    }\n\n    _range = nextRange;\n    _updateRulerOnRaf();\n\n    if (!isExternal) {\n      rangeCallback(_range);\n    }\n  }\n\n  function _adjustDiscreteRange(nextRange) {\n    // TODO sometimes beginChange and endChange are different for slider drag because of pixels division\n    const begin = Math.round(nextRange.begin / _state.minimapDelta) * _state.minimapDelta;\n    const end = Math.round(nextRange.end / _state.minimapDelta) * _state.minimapDelta;\n\n    return { begin, end };\n  }\n\n  function _updateRuler() {\n    const { begin, end } = _range;\n\n    _ruler.children[0].style.width = `${begin * 100}%`;\n    _ruler.children[1].style.width = `${(end - begin) * 100}%`;\n    _ruler.children[2].style.width = `${(1 - end) * 100}%`;\n  }\n\n  return { update, toggle };\n}\n","import { createElement } from './minifiers';\nimport { captureEvents } from './captureEvents';\n\nexport function createTools(container, data, filterCallback) {\n  let _element;\n\n  _setupLayout();\n  _updateFilter();\n\n  function redraw() {\n    if (_element) {\n      const oldElement = _element;\n      oldElement.classList.add('lovely-chart--state-hidden');\n      setTimeout(() => {\n        oldElement.parentNode.removeChild(oldElement);\n      }, 500);\n    }\n\n    _setupLayout();\n    _element.classList.add('lovely-chart--state-transparent');\n    requestAnimationFrame(() => {\n      _element.classList.remove('lovely-chart--state-transparent');\n    });\n  }\n\n  function _setupLayout() {\n    _element = createElement();\n    _element.className = 'lovely-chart--tools';\n\n    if (data.datasets.length < 2) {\n      _element.className += ' lovely-chart--state-hidden';\n    }\n\n    data.datasets.forEach(({ key, name }) => {\n      const control = createElement('a');\n      control.href = '#';\n      control.dataset.key = key;\n      control.className = `lovely-chart--button lovely-chart--color-${data.colors[key].slice(1)} lovely-chart--state-checked`;\n      control.innerHTML = `<span class=\"lovely-chart--button-check\"></span><span class=\"lovely-chart--button-label\">${name}</span>`;\n\n      control.addEventListener('click', (e) => {\n        e.preventDefault();\n\n        if (!control.dataset.clickPrevented) {\n          _updateFilter(control);\n        }\n\n        delete control.dataset.clickPrevented;\n      });\n\n      captureEvents(control, {\n        onLongPress: () => {\n          control.dataset.clickPrevented = 'true';\n\n          _updateFilter(control, true);\n        },\n      });\n\n      _element.appendChild(control);\n    });\n\n    container.appendChild(_element);\n  }\n\n  function _updateFilter(button, isLongPress = false) {\n    const buttons = Array.from(_element.getElementsByTagName('a'));\n    const isSingleChecked = _element.querySelectorAll('.lovely-chart--state-checked').length === 1;\n\n    if (button) {\n      if (button.classList.contains('lovely-chart--state-checked') && isSingleChecked) {\n        if (isLongPress) {\n          buttons.forEach((b) => b.classList.add('lovely-chart--state-checked'));\n          button.classList.remove('lovely-chart--state-checked');\n        } else {\n          button.classList.remove('lovely-chart--state-shake');\n          requestAnimationFrame(() => {\n            button.classList.add('lovely-chart--state-shake');\n          });\n        }\n      } else if (isLongPress) {\n        buttons.forEach((b) => b.classList.remove('lovely-chart--state-checked'));\n        button.classList.add('lovely-chart--state-checked');\n      } else {\n        button.classList.toggle('lovely-chart--state-checked');\n      }\n    }\n\n    const filter = {};\n\n    buttons.forEach((input) => {\n      filter[input.dataset.key] = input.classList.contains('lovely-chart--state-checked');\n    });\n\n    filterCallback(filter);\n  }\n\n  return {\n    redraw,\n  };\n}\n","import { analyzeData } from './data';\nimport { getFullLabelDate } from './format';\nimport { ZOOM_RANGE_DELTA, ZOOM_RANGE_MIDDLE, ZOOM_TIMEOUT } from './constants';\nimport { createColors } from './skin';\n\nexport function createZoomer(data, overviewData, colors, stateManager, container, header, minimap, tooltip, tools) {\n  let _isZoomed = false;\n  let _stateBeforeZoomIn;\n  let _stateBeforeZoomOut;\n\n  function zoomIn(state, labelIndex) {\n    if (_isZoomed) {\n      return;\n    }\n\n    const label = data.xLabels[labelIndex];\n\n    _stateBeforeZoomIn = state;\n    header.toggleIsZooming(true);\n    tooltip.toggleLoading(true);\n    tooltip.toggleIsZoomed(true);\n    if (data.shouldZoomToPie) {\n      container.classList.add('lovely-chart--state-zoomed-in');\n      container.classList.add('lovely-chart--state-animating');\n    }\n\n    const { value } = label;\n    const dataPromise = data.shouldZoomToPie ? Promise.resolve(_generatePieData(labelIndex)) : data.onZoom(value);\n    dataPromise.then((newData) => _replaceData(newData, labelIndex, label));\n  }\n\n  function zoomOut(state) {\n    if (!_isZoomed) {\n      return;\n    }\n\n    _stateBeforeZoomOut = state;\n    header.toggleIsZooming(true);\n    tooltip.toggleLoading(true);\n    tooltip.toggleIsZoomed(false);\n    if (data.shouldZoomToPie) {\n      container.classList.remove('lovely-chart--state-zoomed-in');\n      container.classList.add('lovely-chart--state-animating');\n    }\n\n    const labelIndex = Math.round((state.labelFromIndex + state.labelToIndex) / 2);\n    _replaceData(overviewData, labelIndex);\n  }\n\n  function isZoomed() {\n    return _isZoomed;\n  }\n\n  function _replaceData(newRawData, labelIndex, zoomInLabel) {\n    if (!newRawData) {\n      tooltip.toggleLoading(false);\n      tooltip.toggleIsZoomed(false);\n      header.toggleIsZooming(false);\n\n      return;\n    }\n\n    tooltip.toggleLoading(false);\n\n    const labelWidth = 1 / data.xLabels.length;\n    const labelMiddle = labelIndex / (data.xLabels.length - 1);\n    const filter = {};\n    data.datasets.forEach(({ key }) => filter[key] = false);\n    const newData = analyzeData(newRawData, _isZoomed || data.shouldZoomToPie ? 'day' : 'hour');\n    const shouldZoomToLines = Object.keys(data.datasets).length !== Object.keys(newData.datasets).length;\n\n    stateManager.update({\n      range: {\n        begin: labelMiddle - labelWidth / 2,\n        end: labelMiddle + labelWidth / 2,\n      },\n      filter,\n    });\n\n    setTimeout(() => {\n      Object.assign(data, newData);\n\n      if (shouldZoomToLines && newRawData.colors) {\n        Object.assign(colors, createColors(newRawData.colors));\n      }\n\n      if (shouldZoomToLines) {\n        minimap.toggle(_isZoomed);\n        tools.redraw();\n        container.style.width = `${container.scrollWidth}px`;\n        container.style.height = `${container.scrollHeight}px`;\n      }\n\n      stateManager.update({\n        range: {\n          begin: ZOOM_RANGE_MIDDLE - ZOOM_RANGE_DELTA,\n          end: ZOOM_RANGE_MIDDLE + ZOOM_RANGE_DELTA,\n        },\n        focusOn: null,\n      }, true);\n\n      const daysCount = _isZoomed || data.shouldZoomToPie ? data.xLabels.length : data.xLabels.length / 24;\n      const halfDayWidth = (1 / daysCount) / 2;\n\n      let range;\n      let filter;\n\n      if (_isZoomed) {\n        range = {\n          begin: _stateBeforeZoomIn.begin,\n          end: _stateBeforeZoomIn.end,\n        };\n        filter = shouldZoomToLines ? _stateBeforeZoomIn.filter : _stateBeforeZoomOut.filter;\n      } else {\n        if (shouldZoomToLines) {\n          range = {\n            begin: 0,\n            end: 1,\n          };\n          filter = {};\n          data.datasets.forEach(({ key }) => filter[key] = true);\n        } else {\n          range = data.shouldZoomToPie ? {\n            begin: ZOOM_RANGE_MIDDLE - halfDayWidth,\n            end: ZOOM_RANGE_MIDDLE + halfDayWidth,\n          } : newData.minimapRange;\n          filter = _stateBeforeZoomIn.filter;\n        }\n      }\n\n      stateManager.update({\n        range,\n        filter,\n        minimapDelta: _isZoomed ? null : range.end - range.begin,\n      });\n\n      if (zoomInLabel) {\n        header.zoom(getFullLabelDate(zoomInLabel));\n      }\n\n      _isZoomed = !_isZoomed;\n      header.toggleIsZooming(false);\n    }, stateManager.hasAnimations() ? ZOOM_TIMEOUT : 0);\n\n    setTimeout(() => {\n      if (data.shouldZoomToPie) {\n        container.classList.remove('lovely-chart--state-animating');\n      }\n    }, stateManager.hasAnimations() ? 1000 : 0);\n  }\n\n  function _generatePieData(labelIndex) {\n    return Object.assign(\n      {},\n      overviewData,\n      {\n        type: 'pie',\n        labels: overviewData.labels.slice(labelIndex - 3, labelIndex + 4),\n        datasets: overviewData.datasets.map((dataset) => {\n          return {\n            ...dataset,\n            values: dataset.values.slice(labelIndex - 3, labelIndex + 4),\n          };\n        }),\n      },\n    );\n  }\n\n  return { zoomIn, zoomOut, isZoomed };\n}\n"],"names":["DPR","window","devicePixelRatio","DEFAULT_RANGE","begin","end","TRANSITION_DEFAULT_DURATION","LONG_PRESS_TIMEOUT","GUTTER","PLOT_HEIGHT","PLOT_TOP_PADDING","PLOT_LINE_WIDTH","PLOT_PIE_RADIUS_FACTOR","PLOT_PIE_SHIFT","PLOT_BARS_WIDTH_SHIFT","PIE_MINIMUM_VISIBLE_PERCENT","BALLOON_OFFSET","AXES_FONT","AXES_MAX_COLUMN_WIDTH","AXES_MAX_ROW_HEIGHT","X_AXIS_HEIGHT","X_AXIS_SHIFT_START","Y_AXIS_ZERO_BASED_THRESHOLD","MINIMAP_HEIGHT","MINIMAP_MARGIN","MINIMAP_LINE_WIDTH","MINIMAP_EAR_WIDTH","MINIMAP_MAX_ANIMATED_DATASETS","ZOOM_TIMEOUT","ZOOM_RANGE_DELTA","ZOOM_RANGE_MIDDLE","MONTHS","WEEK_DAYS","WEEK_DAYS_SHORT","MILISECONDS_IN_DAY","SPEED_TEST_INTERVAL","SPEED_TEST_FAST_FPS","SIMPLIFIER_MIN_POINTS","SIMPLIFIER_PLOT_FACTOR","SIMPLIFIER_MINIMAP_FACTOR","ANIMATE_PROPS","getMaxMin","array","length","max","min","i","value","mergeArrays","arrays","concat","apply","sumArrays","sums","n","l","j","proxyMerge","obj1","obj2","Proxy","get","obj","prop","undefined","throttle","fn","ms","isPending","args","shouldRunFirst","arguments","interval","_len","_args","Array","_key","setInterval","clearInterval","throttleWithRaf","waiting","_len2","_key2","requestAnimationFrame","SCALE_LEVELS","yScaleLevelToStep","scaleLevel","applyYEdgeOpacity","opacity","xPx","plotWidth","edgeOffset","Math","applyXEdgeOpacity","yPx","getPieRadius","projection","getSize","getSimplificationDelta","pointsLength","createStateManager","data","viewportSize","callback","_range","_filter","filter","datasets","forEach","_ref3","key","_buildDefaultFilter","_transitionConfig","transitionConfig","datasetVisibilities","map","_ref2","transition","duration","options","split","push","_buildTransitionConfig","_transitions","onTick","_nextFrame","_testStartedAt","_fps","_testingFps","_slowDetectedAt","_startedAsSlow","remove","isRunning","cancelAnimationFrame","Boolean","Object","keys","isFast","forceCheck","_tick","isSlow","Date","now","state","startedAt","from","to","progress","current","t","pow","includes","ceil","floor","add","getState","createTransitionManager","_runCallback","_runCallbackOnRaf","_state","static","update","range","focusOn","minimapDelta","noTransition","assign","prevState","totalXWidth","xLabels","labelFromIndex","labelToIndex","xAxisScale","step","log2","calculateXAxisScale","width","yRanges","isStacked","filteredValues","d","_ref7","values","yMaxMinimap","yMaxViewport","slice","yMinViewport","yMinMinimap","calculateYRangesStacked","secondaryYAxisDataset","hasSecondYAxis","filteredDatasets","calculateYRangesForGroup","yMinViewportSecond","yMaxViewportSecond","yMinMinimapSecond","yMaxMinimapSecond","calculateYRanges","yAxisScale","calculateYAxisScale","height","yAxisScaleSecond","yStep","yStepSecond","datasetsOpacity","_ref4","calculateState","_ref","currentTarget","hasAnimations","yMinMinimapReal","_ref5","yMax","yMin","viewportMaxMin","_ref6","yMinViewportReal","plotHeight","availableHeight","viewportLabelsCount","maxRows","neededStep","findIndex","createElement","tagName","document","addEventListener","element","event","cb","removeEventListener","toggleText","newText","className","inverse","container","parentNode","classList","newElement","innerHTML","selector","join","querySelectorAll","e","insertBefore","nextSibling","toggleElementIn","toggleElementOut","humanize","decimals","keepThreeDigits","toFixed","replace","formatInteger","String","formatCryptoValue","Number","getFullLabelDate","label","isShort","getLabelDate","displayWeekDay","displayYear","displayHours","date","weekDaysArray","string","getUTCDate","getUTCMonth","getUTCDay","getUTCFullYear","getUTCHours","getUTCMinutes","detectSkin","documentElement","contains","skin","COLORS","styleElement","type","appendChild","createTextNode","head","styleSheet","sheet","createColors","datasetColors","colors","baseClass","hexToChannels","addCssRule","getCssColor","r","g","b","a","buildCssColor","hexWithAlpha","hex","alpha","parseInt","parseFloat","rule","insertRule","cssRules","createProjection","params","availableWidth","xPadding","yPadding","effectiveWidth","xFactor","xOffsetPx","effectiveHeight","yFactor","yOffsetPx","findClosestLabelIndex","round","copy","overrides","cons","getCenter","getParams","toPixels","labelIndex","setupCanvas","canvas","style","context","getContext","scale","clearCanvas","clearRect","preparePoints","visibilities","bounds","pieToArea","isPie","datasetValues","reduce","sum","prepareSumsByX","points","visibleValue","stackOffset","stackValue","isPercentage","sumsByY","datasetPoints","getSumsByY","point","percent","preparePercentage","accum","prepareStacked","simplify","E1","MAXLIMIT","pointToSegmentDistanceSquare","p","v1","v2","dv","dvlen_1","vx","vy","indexes","fixedPoints","removed","worker","maximumDelta","len","distances","queue","subdivisionTree","tick","request","pop","result","start","record","currentLimit","usedDistance","usedIndex","vector","fixId","abs","vectorLength_1","segmentDistance","index","distance","left","parent","parentProperty","right","delta","precalculate","resultIndexes","delta2","markers","drawDatasets","secondaryPoints","secondaryProjection","lineWidth","pieToBar","simplification","hasOwnYAxis","color","datasetType","datasetProjection","yHeight","bottomLine","topLine","center","radius","pointerVector","x0","x1","beginPath","pixels","simplifierFn","x","y","lineTo","save","strokeStyle","globalAlpha","lineJoin","lineCap","stroke","restore","drawDatasetLine","fillStyle","yFrom","yTo","rectX","rectY","rectW","rectH","fillRect","drawDatasetBars","drawDatasetSteps","fill","drawDatasetArea","percentFactor","beginAngle","PI","endAngle","shift","angle","shiftAngle","directionX","cos","directionY","sin","shiftX","shiftY","moveTo","arc","font","getPieTextSize","textAlign","textBaseline","textShift","log","getPieTextShift","fillText","drawDatasetPie","drawDataset","isBars","isSteps","xCenter","yCenter","drawBarsMask","captureEvents","captureEvent","longPressTimeout","onCapture","onMove","onRelease","pageX","touches","draggingCursor","body","onLongPress","setTimeout","clearTimeout","onDrag","dragOffsetX","createTooltip","plotSize","onZoom","onFocus","_points","_projection","_secondaryPoints","_secondaryProjection","_element","_canvas","_context","_balloon","_offsetX","_offsetY","_clickedOnLabel","_isZoomed","_isZooming","_selectLabelOnRaf","_selectLabel","_throttledUpdateContent","_updateContent","_onMouseMove","target","pageOffset","getBoundingClientRect","clientX","clientY","top","_onDocumentMove","_clear","_onClick","isZoomable","oldLabelIndex","newLabelIndex","_getLabelIndex","_onBalloonClick","isExternal","_hideBalloon","getPointerVector","shouldShowBalloon","getValue","statistics","name","originalIndex","transform","meanLabel","leftOffset","offsetWidth","_getBalloonLeftOffset","tooltipFormatter","toString","match","text","_getTitle","_updateBalloon","isLines","isAreas","pointIndex","strokeColor","fillColor","_drawCircle","_drawCircles","_drawTail","_renderPercentageValue","dataSet","totalValue","percentageValue","percentageElement","querySelector","newPercentageTitle","prepend","title","titleContainer","children","display","currentTitle","_updateTitle","dataSetContainer","setAttribute","finalStatistics","offset","_isPieSectorSelected","statItem","currentDataSet","valueElement","isCurrency","_updateDataSet","newDataSet","totalText","_insertNewDataSet","newTotalText","_renderTotal","totalUsd","currencyRate","_renderCurrencyRate","_updateDataSets","atan2","sqrt","_setupCanvas","toggleLoading","isLoading","toggle","toggleIsZoomed","isZoomed","analyzeData","labelFormatter","minimapRange","hideCaption","zoomOutLabel","labels","cloneArray","prepareDatasets","totalYMin","Infinity","totalYMax","effectiveLabelFormatter","statsFormatDayHour","getDate","getMonth","statsFormatDay","statsFormatMin","statsFormatText","analyzed","shouldZoomToPie","create","originalData","_stateManager","_plot","_plotSize","_header","_axes","_minimap","_tooltip","_tools","_zoomer","_windowWidth","innerWidth","_data","_colors","_redrawDebounced","shouldRunLast","waitingTimeout","debounce","_setupComponents","_titleElement","_zoomOutElement","_captionElement","zoomOutCallback","setCaptionThrottled","setCaption","caption","_onZoomOut","zoom","toggleIsZooming","isZooming","createHeader","clientWidth","offsetHeight","_setupPlotCanvas","_onStateUpdate","_drawYAxisScaled","colorKey","isSecondary","firstVisibleValue","lastVisibleValue","textOpacity","drawXAxis","topOffset","xScaleLevelToStep","opacityFactor","shiftedI","drawYAxis","yAxisScaleFrom","yAxisScaleTo","yAxisScaleProgress","yMinViewportFrom","yMinViewportTo","yMaxViewportFrom","yMaxViewportTo","yMinViewportSecondFrom","yMinViewportSecondTo","yMaxViewportSecondFrom","yMaxViewportSecondTo","isYChanging","_drawYAxisPercents","formatValue","total","avg1","avg2","avg3","totalAvg","totalRate","_drawYAxisCurrency","yAxisScaleSecondFrom","yAxisScaleSecondTo","yAxisScaleSecondProgress","secondaryColorKey","createAxes","rangeCallback","_canvasSize","_ruler","_slider","_capturedOffset","_updateRulerOnRaf","_onDragCapture","preventDefault","offsetLeft","_onDragRelease","_updateRange","nextRange","_adjustDiscreteRange","moveEvent","maxX1","newX1","newX2","minX2","maxX2","newState","some","_isStateChanged","boundsAndParams","secondaryDataset","find","_drawDatasets","shouldShow","createMinimap","_onRangeChange","_onZoomIn","_onFocus","filterCallback","_setupLayout","control","href","dataset","clickPrevented","_updateFilter","button","isLongPress","buttons","getElementsByTagName","isSingleChecked","input","redraw","oldElement","removeChild","createTools","_onFilterChange","overviewData","stateManager","header","minimap","tooltip","tools","_stateBeforeZoomIn","_stateBeforeZoomOut","_replaceData","newRawData","zoomInLabel","labelWidth","labelMiddle","newData","shouldZoomToLines","scrollWidth","scrollHeight","halfDayWidth","zoomIn","Promise","resolve","_generatePieData","then","zoomOut","createZoomer","startIndex","endIndex","labelFrom","labelTo","_getCaption"],"sourceRoot":""}