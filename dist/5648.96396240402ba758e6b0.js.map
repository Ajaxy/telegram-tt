{"version":3,"file":"5648.96396240402ba758e6b0.js","mappings":"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","sources":["webpack://telegram-t/webpack/runtime/chunk loaded","webpack://telegram-t/webpack/runtime/create fake namespace object","webpack://telegram-t/webpack/runtime/startup chunk dependencies","webpack://telegram-t/./src/config.ts","webpack://telegram-t/./src/util/createPostMessageInterface.ts","webpack://telegram-t/./src/util/callbacks.ts","webpack://telegram-t/./src/lib/rlottie/rlottie.worker.ts","webpack://telegram-t/./src/lib/video-preview/requestPart.ts","webpack://telegram-t/./src/lib/video-preview/MP4Demuxer.ts","webpack://telegram-t/./src/util/generateIdFor.ts","webpack://telegram-t/./src/util/schedulers.ts","webpack://telegram-t/./src/lib/video-preview/polyfill/encoded-video-chunk.ts","webpack://telegram-t/./src/lib/video-preview/polyfill/encoded-audio-chunk.ts","webpack://telegram-t/./src/lib/video-preview/polyfill/video-frame.ts","webpack://telegram-t/./src/lib/video-preview/polyfill/libav.ts","webpack://telegram-t/./src/lib/video-preview/polyfill/misc.ts","webpack://telegram-t/./src/lib/video-preview/polyfill/video-decoder.ts","webpack://telegram-t/./src/lib/video-preview/polyfill/rendering.ts","webpack://telegram-t/./src/lib/video-preview/polyfill/config.ts","webpack://telegram-t/./src/lib/video-preview/video-preview.worker.ts","webpack://telegram-t/./src/lib/video-preview/polyfill/index.ts","webpack://telegram-t/./src/lib/rlottie/rlottie-wasm.js","webpack://telegram-t/./src/lib/rlottie/rlottie-wasm.js?3270","webpack://telegram-t/webpack/bootstrap","webpack://telegram-t/webpack/runtime/define property getters","webpack://telegram-t/webpack/runtime/ensure chunk","webpack://telegram-t/webpack/runtime/get javascript chunk filename","webpack://telegram-t/webpack/runtime/get mini-css chunk filename","webpack://telegram-t/webpack/runtime/global","webpack://telegram-t/webpack/runtime/hasOwnProperty shorthand","webpack://telegram-t/webpack/runtime/make namespace object","webpack://telegram-t/webpack/runtime/publicPath","webpack://telegram-t/webpack/runtime/importScripts chunk loading","webpack://telegram-t/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(5802),\n\t\t__webpack_require__.e(6835)\n\t]).then(next);\n};","import type { ApiLimitType } from './global/types';\n\nexport const APP_NAME = process.env.APP_NAME || 'Telegram Web A';\nexport const RELEASE_DATETIME = process.env.RELEASE_DATETIME;\n\nexport const PRODUCTION_HOSTNAME = 'web.telegram.org';\nexport const PRODUCTION_URL = 'https://web.telegram.org/a';\n\nexport const IS_MOCKED_CLIENT = process.env.APP_MOCKED_CLIENT === '1';\nexport const IS_TEST = process.env.APP_ENV === 'test';\nexport const IS_PERF = process.env.APP_ENV === 'perf';\nexport const IS_BETA = process.env.APP_ENV === 'staging';\nexport const IS_ELECTRON = process.env.IS_ELECTRON;\n\nexport const DEBUG = process.env.APP_ENV !== 'production';\nexport const DEBUG_MORE = false;\nexport const STRICTERDOM_ENABLED = DEBUG && !IS_ELECTRON;\n\nexport const BETA_CHANGELOG_URL = 'https://telegra.ph/WebA-Beta-03-20';\nexport const ELECTRON_HOST_URL = 'https://telegram-a-host';\n\nexport const DEBUG_ALERT_MSG = 'Shoot!\\nSomething went wrong, please see the error details in Dev Tools Console.';\nexport const DEBUG_GRAMJS = false;\n\nexport const PAGE_TITLE = process.env.APP_TITLE!;\nexport const INACTIVE_MARKER = '[Inactive]';\n\nexport const DEBUG_PAYMENT_SMART_GLOCAL = false;\n\nexport const SESSION_USER_KEY = 'user_auth';\nexport const LEGACY_SESSION_KEY = 'GramJs:sessionId';\nexport const PASSCODE_CACHE_NAME = 'tt-passcode';\n\nexport const GLOBAL_STATE_CACHE_DISABLED = false;\nexport const GLOBAL_STATE_CACHE_KEY = 'tt-global-state';\nexport const GLOBAL_STATE_CACHE_USER_LIST_LIMIT = 500;\nexport const GLOBAL_STATE_CACHE_CHAT_LIST_LIMIT = 200;\nexport const GLOBAL_STATE_CACHE_CHATS_WITH_MESSAGES_LIMIT = 30;\nexport const GLOBAL_STATE_CACHE_CUSTOM_EMOJI_LIMIT = 150;\n\nexport const MEDIA_CACHE_DISABLED = false;\nexport const MEDIA_CACHE_NAME = 'tt-media';\nexport const MEDIA_CACHE_NAME_AVATARS = 'tt-media-avatars';\nexport const MEDIA_PROGRESSIVE_CACHE_DISABLED = false;\nexport const MEDIA_PROGRESSIVE_CACHE_NAME = 'tt-media-progressive';\nexport const CUSTOM_EMOJI_PREVIEW_CACHE_DISABLED = false;\nexport const CUSTOM_EMOJI_PREVIEW_CACHE_NAME = 'tt-custom-emoji-preview';\nexport const MEDIA_CACHE_MAX_BYTES = 512 * 1024; // 512 KB\nexport const CUSTOM_BG_CACHE_NAME = 'tt-custom-bg';\nexport const LANG_CACHE_NAME = 'tt-lang-packs-v19';\nexport const ASSET_CACHE_NAME = 'tt-assets';\nexport const AUTODOWNLOAD_FILESIZE_MB_LIMITS = [1, 5, 10, 50, 100, 500];\nexport const DATA_BROADCAST_CHANNEL_NAME = 'tt-global';\nexport const ESTABLISH_BROADCAST_CHANNEL_NAME = 'tt-establish';\nexport const MULTITAB_LOCALSTORAGE_KEY = 'tt-multitab';\n\nexport const DOWNLOAD_WORKERS = 16;\nexport const UPLOAD_WORKERS = 16;\n\nconst isBigScreen = typeof window !== 'undefined' && window.innerHeight >= 900;\n\nexport const MIN_PASSWORD_LENGTH = 1;\n\nexport const MESSAGE_LIST_SLICE = isBigScreen ? 60 : 40;\nexport const MESSAGE_LIST_VIEWPORT_LIMIT = MESSAGE_LIST_SLICE * 2;\n\nexport const ARCHIVE_MINIMIZED_HEIGHT = 36;\nexport const CHAT_HEIGHT_PX = 72;\nexport const TOPIC_HEIGHT_PX = 65;\nexport const CHAT_LIST_SLICE = isBigScreen ? 30 : 25;\nexport const CHAT_LIST_LOAD_SLICE = 100;\nexport const SHARED_MEDIA_SLICE = 42;\nexport const MESSAGE_SEARCH_SLICE = 42;\nexport const GLOBAL_SEARCH_SLICE = 20;\nexport const GLOBAL_TOPIC_SEARCH_SLICE = 5;\nexport const MEMBERS_SLICE = 30;\nexport const MEMBERS_LOAD_SLICE = 200;\nexport const PINNED_MESSAGES_LIMIT = 50;\nexport const BLOCKED_LIST_LIMIT = 100;\nexport const PROFILE_PHOTOS_LIMIT = 40;\nexport const PROFILE_SENSITIVE_AREA = 500;\nexport const TOPIC_LIST_SENSITIVE_AREA = 600;\nexport const COMMON_CHATS_LIMIT = 100;\nexport const GROUP_CALL_PARTICIPANTS_LIMIT = 100;\n\n// As in Telegram for Android\n// https://github.com/DrKLO/Telegram/blob/51e9947527/TMessagesProj/src/main/java/org/telegram/messenger/MediaDataController.java#L7799\nexport const TOP_REACTIONS_LIMIT = 100;\n\n// As in Telegram for Android\n// https://github.com/DrKLO/Telegram/blob/51e9947527/TMessagesProj/src/main/java/org/telegram/messenger/MediaDataController.java#L7781\nexport const RECENT_REACTIONS_LIMIT = 50;\nexport const REACTION_LIST_LIMIT = 100;\nexport const REACTION_UNREAD_SLICE = 100;\nexport const MENTION_UNREAD_SLICE = 100;\nexport const TOPICS_SLICE = 20;\nexport const TOPICS_SLICE_SECOND_LOAD = 500;\n\nexport const TOP_CHAT_MESSAGES_PRELOAD_LIMIT = 20;\n\nexport const SPONSORED_MESSAGE_CACHE_MS = 300000; // 5 min\n\nexport const DEFAULT_VOLUME = 1;\nexport const DEFAULT_PLAYBACK_RATE = 1;\nexport const PLAYBACK_RATE_FOR_AUDIO_MIN_DURATION = 20 * 60; // 20 min\n\nexport const ANIMATION_LEVEL_CUSTOM = -1;\nexport const ANIMATION_LEVEL_MIN = 0;\nexport const ANIMATION_LEVEL_MED = 1;\nexport const ANIMATION_LEVEL_MAX = 2;\nexport const ANIMATION_LEVEL_DEFAULT = ANIMATION_LEVEL_MAX;\n\nexport const DEFAULT_MESSAGE_TEXT_SIZE_PX = 16;\nexport const IOS_DEFAULT_MESSAGE_TEXT_SIZE_PX = 17;\nexport const MACOS_DEFAULT_MESSAGE_TEXT_SIZE_PX = 15;\n\nexport const DRAFT_DEBOUNCE = 10000; // 10s\nexport const SEND_MESSAGE_ACTION_INTERVAL = 3000; // 3s\n// 10000s from https://corefork.telegram.org/api/url-authorization#automatic-authorization\nexport const APP_CONFIG_REFETCH_INTERVAL = 10000 * 1000;\n\nexport const EDITABLE_INPUT_ID = 'editable-message-text';\nexport const EDITABLE_INPUT_MODAL_ID = 'editable-message-text-modal';\n// eslint-disable-next-line max-len\nexport const EDITABLE_INPUT_CSS_SELECTOR = `.messages-layout .Transition_slide-active #${EDITABLE_INPUT_ID}, .messages-layout .Transition > .Transition_slide-to #${EDITABLE_INPUT_ID}`;\nexport const EDITABLE_INPUT_MODAL_CSS_SELECTOR = `#${EDITABLE_INPUT_MODAL_ID}`;\n\nexport const CUSTOM_APPENDIX_ATTRIBUTE = 'data-has-custom-appendix';\nexport const MESSAGE_CONTENT_CLASS_NAME = 'message-content';\nexport const MESSAGE_CONTENT_SELECTOR = '.message-content';\n\n// Screen width where Pinned Message / Audio Player in the Middle Header can be safely displayed\nexport const SAFE_SCREEN_WIDTH_FOR_STATIC_RIGHT_COLUMN = 1440; // px\n// Screen width where Pinned Message / Audio Player in the Middle Header shouldn't collapse with ChatInfo\nexport const SAFE_SCREEN_WIDTH_FOR_CHAT_INFO = 1150; // px\n\nexport const MIN_SCREEN_WIDTH_FOR_STATIC_RIGHT_COLUMN = 1275; // px\nexport const MIN_SCREEN_WIDTH_FOR_STATIC_LEFT_COLUMN = 925; // px\nexport const MAX_SCREEN_WIDTH_FOR_EXPAND_PINNED_MESSAGES = 1340; // px\nexport const MOBILE_SCREEN_MAX_WIDTH = 600; // px\nexport const MOBILE_SCREEN_LANDSCAPE_MAX_WIDTH = 950; // px\nexport const MOBILE_SCREEN_LANDSCAPE_MAX_HEIGHT = 450; // px\n\nexport const MAX_INT_32 = 2 ** 31 - 1;\nexport const TMP_CHAT_ID = '0';\n\nexport const ANIMATION_END_DELAY = 100;\n\nexport const FAST_SMOOTH_MIN_DURATION = 300;\nexport const FAST_SMOOTH_MAX_DURATION = 600;\nexport const FAST_SMOOTH_MAX_DISTANCE = 750;\nexport const FAST_SMOOTH_SHORT_TRANSITION_MAX_DISTANCE = 300; // px\n\n// Average duration of message sending animation\nexport const API_UPDATE_THROTTLE = Math.round((FAST_SMOOTH_MIN_DURATION + FAST_SMOOTH_MAX_DURATION) / 2);\nexport const API_THROTTLE_RESET_UPDATES = new Set([\n  'newMessage', 'newScheduledMessage', 'deleteMessages', 'deleteScheduledMessages', 'deleteHistory',\n]);\n\nexport const LOCK_SCREEN_ANIMATION_DURATION_MS = 200;\n\nexport const STICKER_SIZE_INLINE_DESKTOP_FACTOR = 13;\nexport const STICKER_SIZE_INLINE_MOBILE_FACTOR = 11;\nexport const STICKER_SIZE_AUTH = 160;\nexport const STICKER_SIZE_AUTH_MOBILE = 120;\nexport const STICKER_SIZE_PICKER = 72;\nexport const EMOJI_SIZE_PICKER = 36;\nexport const COMPOSER_EMOJI_SIZE_PICKER = 32;\nexport const STICKER_SIZE_GENERAL_SETTINGS = 48;\nexport const STICKER_SIZE_PICKER_HEADER = 32;\nexport const STICKER_PICKER_MAX_SHARED_COVERS = 20;\nexport const STICKER_SIZE_SEARCH = 72;\nexport const STICKER_SIZE_MODAL = 72;\nexport const EMOJI_SIZE_MODAL = 36;\nexport const STICKER_SIZE_TWO_FA = 160;\nexport const STICKER_SIZE_PASSCODE = 160;\nexport const STICKER_SIZE_DISCUSSION_GROUPS = 140;\nexport const STICKER_SIZE_FOLDER_SETTINGS = 100;\nexport const STICKER_SIZE_INLINE_BOT_RESULT = 100;\nexport const STICKER_SIZE_JOIN_REQUESTS = 140;\nexport const STICKER_SIZE_INVITES = 140;\nexport const RECENT_STICKERS_LIMIT = 20;\nexport const RECENT_STATUS_LIMIT = 20;\nexport const EMOJI_STATUS_LOOP_LIMIT = 2;\nexport const EMOJI_SIZES = 7;\nexport const TOP_SYMBOL_SET_ID = 'top';\nexport const POPULAR_SYMBOL_SET_ID = 'popular';\nexport const RECENT_SYMBOL_SET_ID = 'recent';\nexport const FAVORITE_SYMBOL_SET_ID = 'favorite';\nexport const CHAT_STICKER_SET_ID = 'chatStickers';\nexport const PREMIUM_STICKER_SET_ID = 'premium';\nexport const DEFAULT_TOPIC_ICON_STICKER_ID = 'topic-default-icon';\nexport const DEFAULT_STATUS_ICON_ID = 'status-default-icon';\nexport const EMOJI_IMG_REGEX = /<img[^>]+alt=\"([^\"]+)\"(?![^>]*data-document-id)[^>]*>/gm;\n\nexport const BASE_EMOJI_KEYWORD_LANG = 'en';\n\nexport const MENU_TRANSITION_DURATION = 200;\nexport const SLIDE_TRANSITION_DURATION = 450;\n\nexport const VIDEO_MOV_TYPE = 'video/quicktime';\nexport const VIDEO_WEBM_TYPE = 'video/webm';\n\nexport const GIF_MIME_TYPE = 'image/gif';\n\nexport const SUPPORTED_IMAGE_CONTENT_TYPES = new Set([\n  'image/png', 'image/jpeg', GIF_MIME_TYPE,\n]);\n\nexport const SUPPORTED_VIDEO_CONTENT_TYPES = new Set([\n  'video/mp4', // video/quicktime added dynamically in environment.ts\n]);\n\nexport const SUPPORTED_AUDIO_CONTENT_TYPES = new Set([\n  'audio/mp3',\n  'audio/ogg',\n  'audio/wav',\n  'audio/mpeg',\n  'audio/flac',\n  'audio/aac',\n  'audio/m4a',\n  'audio/mp4',\n  'audio/x-m4a',\n]);\n\nexport const CONTENT_TYPES_WITH_PREVIEW = new Set([\n  ...SUPPORTED_IMAGE_CONTENT_TYPES,\n  ...SUPPORTED_VIDEO_CONTENT_TYPES,\n]);\n\nexport const CONTENT_NOT_SUPPORTED = 'The message is not supported on this version of Telegram.';\n\n// Taken from https://github.com/telegramdesktop/tdesktop/blob/41d9a9fcbd0c809c60ddbd9350791b1436aff7d9/Telegram/SourceFiles/ui/boxes/choose_language_box.cpp#L28\nexport const SUPPORTED_TRANSLATION_LANGUAGES = [\n  // Official\n  'en', 'ar', 'be', 'ca', 'zh', 'nl', 'fr', 'de', 'id',\n  'it', 'ja', 'ko', 'pl', 'pt', 'ru', 'es', 'uk',\n  // Unofficial\n  'af', 'sq', 'am', 'hy', 'az', 'eu', 'bn', 'bs', 'bg',\n  'ceb', 'zh-CN', 'zh-TW', 'co', 'hr', 'cs', 'da', 'eo',\n  'et', 'fi', 'fy', 'gl', 'ka', 'el', 'gu', 'ht', 'ha',\n  'haw', 'he', 'iw', 'hi', 'hmn', 'hu', 'is', 'ig', 'ga',\n  'jv', 'kn', 'kk', 'km', 'rw', 'ku', 'ky', 'lo', 'la',\n  'lv', 'lt', 'lb', 'mk', 'mg', 'ms', 'ml', 'mt', 'mi',\n  'mr', 'mn', 'my', 'ne', 'no', 'ny', 'or', 'ps', 'fa',\n  'pa', 'ro', 'sm', 'gd', 'sr', 'st', 'sn', 'sd', 'si',\n  'sk', 'sl', 'so', 'su', 'sw', 'sv', 'tl', 'tg', 'ta',\n  'tt', 'te', 'th', 'tr', 'tk', 'ur', 'ug', 'uz', 'vi',\n  'cy', 'xh', 'yi', 'yo', 'zu',\n];\n\n// eslint-disable-next-line max-len\nexport const RE_LINK_TEMPLATE = '((ftp|https?):\\\\/\\\\/)?((www\\\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\\\.[a-zA-Z0-9()]{1,63})\\\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)';\nexport const RE_MENTION_TEMPLATE = '(@[\\\\w\\\\d_-]+)';\nexport const RE_TG_LINK = /^tg:(\\/\\/)?/i;\nexport const RE_TME_LINK = /^(https?:\\/\\/)?([-a-zA-Z0-9@:%_+~#=]{1,32}\\.)?t\\.me/i;\nexport const RE_TELEGRAM_LINK = /^(https?:\\/\\/)?telegram\\.org\\//i;\nexport const TME_LINK_PREFIX = 'https://t.me/';\nexport const USERNAME_PURCHASE_ERROR = 'USERNAME_PURCHASE_AVAILABLE';\nexport const PURCHASE_USERNAME = 'auction';\nexport const TME_WEB_DOMAINS = new Set(['t.me', 'web.t.me', 'a.t.me', 'k.t.me', 'z.t.me']);\nexport const WEB_APP_PLATFORM = 'weba';\n\n// eslint-disable-next-line max-len\nexport const COUNTRIES_WITH_12H_TIME_FORMAT = new Set(['AU', 'BD', 'CA', 'CO', 'EG', 'HN', 'IE', 'IN', 'JO', 'MX', 'MY', 'NI', 'NZ', 'PH', 'PK', 'SA', 'SV', 'US']);\n\nexport const API_CHAT_TYPES = ['bots', 'channels', 'chats', 'users'] as const;\n\n// MTProto constants\nexport const SERVICE_NOTIFICATIONS_USER_ID = '777000';\nexport const REPLIES_USER_ID = '1271266957'; // TODO For Test connection ID must be equal to 708513\nexport const RESTRICTED_EMOJI_SET_ID = '7173162320003080';\nexport const DEFAULT_GIF_SEARCH_BOT_USERNAME = 'gif';\nexport const ALL_FOLDER_ID = 0;\nexport const ARCHIVED_FOLDER_ID = 1;\nexport const DELETED_COMMENTS_CHANNEL_ID = '-777';\nexport const MAX_MEDIA_FILES_FOR_ALBUM = 10;\nexport const MAX_ACTIVE_PINNED_CHATS = 5;\nexport const SCHEDULED_WHEN_ONLINE = 0x7FFFFFFE;\nexport const DEFAULT_LANG_CODE = 'en';\nexport const DEFAULT_LANG_PACK = 'android';\nexport const LANG_PACKS = ['android', 'ios', 'tdesktop', 'macos'] as const;\nexport const FEEDBACK_URL = 'https://bugs.telegram.org/?tag_ids=41&sort=time';\nexport const GENERAL_TOPIC_ID = 1;\n\nexport const LIGHT_THEME_BG_COLOR = '#99BA92';\nexport const DARK_THEME_BG_COLOR = '#0F0F0F';\nexport const DEFAULT_PATTERN_COLOR = '#4A8E3A8C';\nexport const DARK_THEME_PATTERN_COLOR = '#0A0A0A8C';\nexport const MAX_UPLOAD_FILEPART_SIZE = 524288;\n\n// Group calls\nexport const GROUP_CALL_VOLUME_MULTIPLIER = 100;\nexport const GROUP_CALL_DEFAULT_VOLUME = 100 * GROUP_CALL_VOLUME_MULTIPLIER;\nexport const GROUP_CALL_THUMB_VIDEO_DISABLED = true;\n\nexport const DEFAULT_LIMITS: Record<ApiLimitType, readonly [number, number]> = {\n  uploadMaxFileparts: [4000, 8000],\n  stickersFaved: [5, 10],\n  savedGifs: [200, 400],\n  dialogFiltersChats: [100, 200],\n  dialogFilters: [10, 20],\n  dialogFolderPinned: [5, 10],\n  captionLength: [1024, 2048],\n  channels: [500, 1000],\n  channelsPublic: [10, 20],\n  aboutLength: [70, 140],\n  chatlistInvites: [3, 100],\n  chatlistJoined: [2, 20],\n};\n","import type {\n  CancellableCallback, OriginMessageEvent, OriginMessageData, WorkerMessageData, ApiUpdate,\n} from './PostMessageConnector';\n\nimport { DEBUG } from '../config';\nimport { createCallbackManager } from './callbacks';\n\ndeclare const self: WorkerGlobalScope;\n\nconst callbackState = new Map<string, CancellableCallback>();\n\ntype ApiConfig =\n  ((name: string, ...args: any[]) => any | [any, ArrayBuffer[]])\n  | Record<string, Function>;\ntype SendToOrigin = (data: WorkerMessageData, transferables?: Transferable[]) => void;\n\nconst messageHandlers = createCallbackManager();\nonmessage = messageHandlers.runCallbacks;\n\nexport function createWorkerInterface(api: ApiConfig, channel?: string) {\n  function sendToOrigin(data: WorkerMessageData, transferables?: Transferable[]) {\n    data.channel = channel;\n\n    if (transferables) {\n      postMessage(data, transferables);\n    } else {\n      postMessage(data);\n    }\n  }\n\n  handleErrors(sendToOrigin);\n\n  messageHandlers.addCallback((message: OriginMessageEvent) => {\n    if (message.data?.channel === channel) {\n      onMessage(api, message.data, sendToOrigin);\n    }\n  });\n}\n\nasync function onMessage(\n  api: ApiConfig,\n  data: OriginMessageData,\n  sendToOrigin: SendToOrigin,\n  onUpdate?: (update: ApiUpdate) => void,\n) {\n  if (!onUpdate) {\n    onUpdate = (update: ApiUpdate) => {\n      sendToOrigin({\n        type: 'update',\n        update,\n      });\n    };\n  }\n\n  switch (data.type) {\n    case 'init': {\n      const { args } = data;\n      const promise = typeof api === 'function'\n        ? api('init', onUpdate, ...args)\n        : api.init?.(onUpdate, ...args);\n      await promise;\n\n      break;\n    }\n    case 'callMethod': {\n      const {\n        messageId, name, args, withCallback,\n      } = data;\n\n      try {\n        if (typeof api !== 'function' && !api[name]) return;\n\n        if (messageId && withCallback) {\n          const callback = (...callbackArgs: any[]) => {\n            const lastArg = callbackArgs[callbackArgs.length - 1];\n\n            sendToOrigin({\n              type: 'methodCallback',\n              messageId,\n              callbackArgs,\n            }, isTransferable(lastArg) ? [lastArg] : undefined);\n          };\n\n          callbackState.set(messageId, callback);\n\n          args.push(callback as never);\n        }\n\n        const response = typeof api === 'function'\n          ? await api(name, ...args)\n          : await api[name](...args);\n        const { arrayBuffer } = (typeof response === 'object' && 'arrayBuffer' in response && response) || {};\n        if (messageId) {\n          sendToOrigin(\n            {\n              type: 'methodResponse',\n              messageId,\n              response,\n            },\n            arrayBuffer ? [arrayBuffer] : undefined,\n          );\n        }\n      } catch (error: any) {\n        if (DEBUG) {\n          // eslint-disable-next-line no-console\n          console.error(error);\n        }\n\n        if (messageId) {\n          sendToOrigin({\n            type: 'methodResponse',\n            messageId,\n            error: { message: error.message },\n          });\n        }\n      }\n\n      if (messageId) {\n        callbackState.delete(messageId);\n      }\n\n      break;\n    }\n    case 'cancelProgress': {\n      const callback = callbackState.get(data.messageId);\n      if (callback) {\n        callback.isCanceled = true;\n      }\n\n      break;\n    }\n  }\n}\n\nfunction isTransferable(obj: any) {\n  return obj instanceof ArrayBuffer || obj instanceof ImageBitmap;\n}\n\nfunction handleErrors(sendToOrigin: SendToOrigin) {\n  self.onerror = (e) => {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    sendToOrigin({ type: 'unhandledError', error: { message: e.error.message || 'Uncaught exception in worker' } });\n  };\n\n  self.addEventListener('unhandledrejection', (e) => {\n    // eslint-disable-next-line no-console\n    console.error(e);\n    sendToOrigin({ type: 'unhandledError', error: { message: e.reason.message || 'Uncaught rejection in worker' } });\n  });\n}\n","export function createCallbackManager<T extends AnyToVoidFunction = AnyToVoidFunction>() {\n  const callbacks = new Set<T>();\n\n  function addCallback(cb: T) {\n    callbacks.add(cb);\n\n    return () => {\n      removeCallback(cb);\n    };\n  }\n\n  function removeCallback(cb: T) {\n    callbacks.delete(cb);\n  }\n\n  function runCallbacks(...args: Parameters<T>) {\n    callbacks.forEach((callback) => {\n      callback(...args);\n    });\n  }\n\n  function hasCallbacks() {\n    return Boolean(callbacks.size);\n  }\n\n  return {\n    runCallbacks,\n    addCallback,\n    removeCallback,\n    hasCallbacks,\n  };\n}\n\nexport type CallbackManager<T extends AnyToVoidFunction = AnyToVoidFunction>\n  = ReturnType<typeof createCallbackManager<T>>;\n","import { inflate } from 'pako/dist/pako_inflate';\nimport { createWorkerInterface } from '../../util/createPostMessageInterface';\nimport type { CancellableCallback } from '../../util/PostMessageConnector';\n\nimport 'script-loader!./rlottie-wasm';\n\ndeclare const Module: any;\n\ndeclare function allocate(...args: any[]): string;\n\ndeclare function intArrayFromString(str: String): string;\n\nlet rLottieApi: Record<string, Function>;\nconst rLottieApiPromise = new Promise<void>((resolve) => {\n  Module.onRuntimeInitialized = () => {\n    rLottieApi = {\n      init: Module.cwrap('lottie_init', '', []),\n      destroy: Module.cwrap('lottie_destroy', '', ['number']),\n      resize: Module.cwrap('lottie_resize', '', ['number', 'number', 'number']),\n      buffer: Module.cwrap('lottie_buffer', 'number', ['number']),\n      render: Module.cwrap('lottie_render', '', ['number', 'number']),\n      loadFromData: Module.cwrap('lottie_load_from_data', 'number', ['number', 'number']),\n    };\n\n    resolve();\n  };\n});\n\nconst HIGH_PRIORITY_MAX_FPS = 60;\nconst LOW_PRIORITY_MAX_FPS = 30;\nconst DESTROY_REPEAT_DELAY = 1000;\n\nconst renderers = new Map<string, {\n  imgSize: number;\n  reduceFactor: number;\n  handle: any;\n  imageData: ImageData;\n  customColor?: [number, number, number];\n}>();\n\nasync function init(\n  key: string,\n  tgsUrl: string,\n  imgSize: number,\n  isLowPriority: boolean,\n  customColor: [number, number, number] | undefined,\n  onInit: CancellableCallback,\n) {\n  if (!rLottieApi) {\n    await rLottieApiPromise;\n  }\n\n  const json = await extractJson(tgsUrl);\n  const stringOnWasmHeap = allocate(intArrayFromString(json), 'i8', 0);\n  const handle = rLottieApi.init();\n  const framesCount = rLottieApi.loadFromData(handle, stringOnWasmHeap);\n  rLottieApi.resize(handle, imgSize, imgSize);\n\n  const imageData = new ImageData(imgSize, imgSize);\n\n  const { reduceFactor, msPerFrame, reducedFramesCount } = calcParams(json, isLowPriority, framesCount);\n\n  renderers.set(key, {\n    imgSize, reduceFactor, handle, imageData, customColor,\n  });\n\n  onInit(reduceFactor, msPerFrame, reducedFramesCount);\n}\n\nasync function changeData(\n  key: string,\n  tgsUrl: string,\n  isLowPriority: boolean,\n  onInit: CancellableCallback,\n) {\n  if (!rLottieApi) {\n    await rLottieApiPromise;\n  }\n\n  const json = await extractJson(tgsUrl);\n  const stringOnWasmHeap = allocate(intArrayFromString(json), 'i8', 0);\n  const { handle } = renderers.get(key)!;\n  const framesCount = rLottieApi.loadFromData(handle, stringOnWasmHeap);\n\n  const { reduceFactor, msPerFrame, reducedFramesCount } = calcParams(json, isLowPriority, framesCount);\n\n  onInit(reduceFactor, msPerFrame, reducedFramesCount);\n}\n\nasync function extractJson(tgsUrl: string) {\n  const response = await fetch(tgsUrl);\n  const contentType = response.headers.get('Content-Type');\n\n  // Support deprecated JSON format cached locally\n  if (contentType?.startsWith('text/')) {\n    return response.text();\n  }\n\n  const arrayBuffer = await response.arrayBuffer();\n  return inflate(arrayBuffer, { to: 'string' });\n}\n\nfunction calcParams(json: string, isLowPriority: boolean, framesCount: number) {\n  const animationData = JSON.parse(json);\n  const maxFps = isLowPriority ? LOW_PRIORITY_MAX_FPS : HIGH_PRIORITY_MAX_FPS;\n  const sourceFps = animationData.fr || maxFps;\n  const reduceFactor = sourceFps % maxFps === 0 ? sourceFps / maxFps : 1;\n\n  return {\n    reduceFactor,\n    msPerFrame: 1000 / (sourceFps / reduceFactor),\n    reducedFramesCount: Math.ceil(framesCount / reduceFactor),\n  };\n}\n\nasync function renderFrames(\n  key: string, frameIndex: number, onProgress: CancellableCallback,\n) {\n  if (!rLottieApi) {\n    await rLottieApiPromise;\n  }\n\n  const {\n    imgSize, reduceFactor, handle, imageData, customColor,\n  } = renderers.get(key)!;\n\n  const realIndex = frameIndex * reduceFactor;\n\n  rLottieApi.render(handle, realIndex);\n  const bufferPointer = rLottieApi.buffer(handle);\n  const data = Module.HEAPU8.subarray(bufferPointer, bufferPointer + (imgSize * imgSize * 4));\n\n  if (customColor) {\n    const arr = new Uint8ClampedArray(data);\n    applyColor(arr, customColor);\n    imageData.data.set(arr);\n  } else {\n    imageData.data.set(data);\n  }\n\n  const imageBitmap = await createImageBitmap(imageData);\n\n  onProgress(frameIndex, imageBitmap);\n}\n\nfunction applyColor(arr: Uint8ClampedArray, color: [number, number, number]) {\n  for (let i = 0; i < arr.length; i += 4) {\n    arr[i] = color[0];\n    arr[i + 1] = color[1];\n    arr[i + 2] = color[2];\n  }\n}\n\nfunction destroy(key: string, isRepeated = false) {\n  try {\n    const renderer = renderers.get(key)!;\n    rLottieApi.destroy(renderer.handle);\n    renderers.delete(key);\n  } catch (err) {\n    // `destroy` sometimes can be called before the initialization is finished\n    if (!isRepeated) {\n      setTimeout(() => destroy(key, true), DESTROY_REPEAT_DELAY);\n    }\n  }\n}\n\nconst api = {\n  'rlottie:init': init,\n  'rlottie:changeData': changeData,\n  'rlottie:renderFrames': renderFrames,\n  'rlottie:destroy': destroy,\n};\n\ncreateWorkerInterface(api);\n\nexport type RLottieApi = typeof api;\n","import generateIdFor from '../../util/generateIdFor';\nimport { pause } from '../../util/schedulers';\n\ndeclare const self: WorkerGlobalScope;\n\ntype RequestStates = {\n  resolve: (response: ArrayBuffer) => void;\n  reject: () => void;\n};\n\ntype RequestPartParams = { url: string; start: number; end: number };\n\nconst PART_TIMEOUT = 30000;\n\nconst requestStates = new Map<string, RequestStates>();\n\nexport function requestPart(params: RequestPartParams): Promise<ArrayBuffer | undefined> {\n  const messageId = generateIdFor(requestStates);\n  const requestState = {} as RequestStates;\n\n  let isResolved = false;\n  const promise = Promise.race([\n    pause(PART_TIMEOUT).then(() => (isResolved ? undefined : Promise.reject(new Error('ERROR_PART_TIMEOUT')))),\n    new Promise<ArrayBuffer>((resolve, reject) => {\n      Object.assign(requestState, { resolve, reject });\n    }),\n  ]);\n\n  requestStates.set(messageId, requestState);\n\n  promise\n    .catch(() => undefined)\n    .finally(() => {\n      requestStates.delete(messageId);\n      isResolved = true;\n    });\n\n  const message = {\n    type: 'requestPart',\n    messageId,\n    params,\n  };\n\n  postMessage(message);\n\n  return promise;\n}\n\nself.addEventListener('message', (e) => {\n  const { type, messageId, result } = (e as any).data as {\n    type: string;\n    messageId: string;\n    result: ArrayBuffer;\n  };\n\n  if (type === 'partResponse') {\n    const requestState = requestStates.get(messageId);\n    if (requestState) {\n      requestState.resolve(result);\n    }\n  }\n});\n","import type { MP4ArrayBuffer, MP4VideoTrack, MP4Info } from 'mp4box';\nimport MP4Box, { DataStream } from 'mp4box';\nimport { requestPart } from './requestPart';\n\nconst META_PART_SIZE = 128 * 1024;\nconst MIN_PART_SIZE = 1024;\nenum Status {\n  loading = 'loading',\n  ready = 'ready',\n  closed = 'closed',\n}\n\nexport type MP4DecoderConfig = {\n  codec: string;\n  codedHeight: number;\n  codedWidth: number;\n  description: Uint8Array;\n};\n\ntype MP4DemuxerConfig = {\n  stepOffset: number;\n  stepMultiplier: number;\n  isPolyfill: boolean;\n  maxFrames: number;\n  onConfig: (config: any) => void;\n  onChunk: (chunk: any) => void;\n};\n\nexport class MP4Demuxer {\n  private readonly url: string;\n\n  private file: MP4Box.MP4File;\n\n  private status = Status.loading;\n\n  private readonly stepOffset: number;\n\n  private readonly stepMultiplier: number;\n\n  private readonly maxFrames: number;\n\n  private readonly isPolyfill: boolean;\n\n  private decodedSamples = new Set<string>();\n\n  private lastSample = 0;\n\n  private readonly onConfig: (config: MP4DecoderConfig) => void;\n\n  private readonly onChunk: (chunk: any) => void;\n\n  constructor(url: string, {\n    onConfig,\n    onChunk,\n    stepOffset,\n    stepMultiplier,\n    isPolyfill,\n    maxFrames,\n  }: MP4DemuxerConfig) {\n    this.url = url;\n    this.stepOffset = stepOffset;\n    this.stepMultiplier = stepMultiplier;\n    this.maxFrames = maxFrames;\n    this.isPolyfill = isPolyfill;\n    this.onConfig = onConfig;\n    this.onChunk = onChunk;\n\n    this.file = MP4Box.createFile();\n    this.file.onError = (e) => {\n      // eslint-disable-next-line no-console\n      console.error(e);\n    };\n    this.file.onReady = this.onReady.bind(this);\n    this.file.onSamples = this.onSamples.bind(this);\n\n    void this.loadMetadata();\n  }\n\n  private async loadMetadata() {\n    let offset: number | undefined = 0;\n    while (offset !== undefined) {\n      try {\n        offset = await this.requestPart(offset, META_PART_SIZE);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.error(e);\n      }\n      if (this.status === Status.ready) break;\n    }\n  }\n\n  private async loadNextFrames(step: number, duration: number, partSize: number) {\n    let tick = step * this.stepOffset;\n    let lastSample = 0;\n    let rap = this.file.seek(tick, true);\n    while (this.status !== Status.closed) {\n      try {\n        await this.requestPart(rap.offset, partSize);\n        if (tick > duration) break;\n        if (this.lastSample > 1 && lastSample < this.lastSample) {\n          tick += step * this.stepMultiplier;\n          lastSample = this.lastSample;\n        }\n        rap = this.file.seek(tick, true);\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.error(e);\n      }\n    }\n    this.file.flush();\n  }\n\n  private async requestPart(offset: number, partSize: number, useRap = true) {\n    const reminder = (offset % MIN_PART_SIZE);\n    const start = offset - reminder;\n    const end = start + partSize - 1;\n    let arrayBuffer = await requestPart({ url: this.url, start, end }) as MP4ArrayBuffer;\n    if (!arrayBuffer) {\n      return undefined;\n    }\n    if (reminder) {\n      arrayBuffer = arrayBuffer.slice(reminder) as MP4ArrayBuffer;\n    }\n    arrayBuffer.fileStart = offset;\n    const nextOffset = this.file.appendBuffer(arrayBuffer);\n    if (!useRap) return offset + arrayBuffer.byteLength;\n    return nextOffset;\n  }\n\n  private description(track: MP4VideoTrack) {\n    const t = this.file.getTrackById(track.id);\n    for (const entry of t.mdia.minf.stbl.stsd.entries) {\n      if (entry.avcC || entry.hvcC || entry.av1C) {\n        const stream = new DataStream(undefined, 0, DataStream.BIG_ENDIAN);\n        if (entry.avcC) {\n          entry.avcC.write(stream);\n        } else if (entry.hvcC) {\n          entry.hvcC.write(stream);\n        } else if (entry.av1C) {\n          entry.av1C.write(stream);\n        }\n        return new Uint8Array(stream.buffer, 8); // Remove the box header.\n      }\n    }\n    throw new Error('avcC, hvcC ro av1C not found');\n  }\n\n  private onReady(info: MP4Info) {\n    const track = info.videoTracks[0];\n\n    let codec = track.codec;\n    if (codec.startsWith('avc1')) {\n      // Somehow this is the only avc1 codec that works.\n      codec = 'avc1.4d001f';\n    }\n\n    // Generate and emit an appropriate VideoDecoderConfig.\n    this.onConfig({\n      codec,\n      codedHeight: track.video.height,\n      codedWidth: track.video.width,\n      description: this.description(track),\n    });\n\n    const duration = info.duration / info.timescale;\n\n    // If we set a part size too small, the onSamples callback is not called.\n    // If we use polyfill, we need to set a smaller part size to avoid decoding multiple frames.\n    const partSizeDivider = this.isPolyfill ? 24 : 12;\n    const partSize = roundPartSize(track.bitrate / partSizeDivider);\n    const step = calculateStep(duration, this.maxFrames);\n\n    // Start demuxing.\n    this.file.setExtractionOptions(track.id, undefined, { nbSamples: 1 });\n    this.file.start();\n\n    this.status = Status.ready;\n\n    // // Load frames\n    void this.loadNextFrames(step, duration, partSize);\n  }\n\n  private onSamples(trackId: number, ref: any, samples: any) {\n    if (this.status !== Status.ready) return;\n    // Generate and emit an EncodedVideoChunk for each demuxed sample.\n    for (const sample of samples) {\n      const time = sample.cts / sample.timescale;\n      const type = sample.is_sync ? 'key' : 'delta';\n      const id = `${type}${sample.number}`;\n\n      // Skip already decoded samples.\n      if (this.decodedSamples.has(id)) continue;\n\n      // @ts-ignore\n      this.onChunk(new EncodedVideoChunk({\n        type,\n        timestamp: (1e6 * time),\n        duration: (1e6 * sample.duration) / sample.timescale,\n        data: sample.data,\n      }));\n\n      this.decodedSamples.add(id);\n      this.lastSample = parseInt(sample.number, 10);\n\n      if (sample.is_sync) {\n        this.file.releaseUsedSamples(trackId, sample.number);\n      }\n    }\n  }\n\n  close() {\n    this.file.flush();\n    this.file.stop();\n    this.status = Status.closed;\n  }\n}\n\nfunction roundPartSize(size: number) {\n  return size + MIN_PART_SIZE - (size % MIN_PART_SIZE);\n}\n\nfunction calculateStep(duration: number, max: number): number {\n  return Math.round((duration + max) / max);\n}\n","export default function generateIdFor(store: AnyLiteral, withAutoUpdate = false) {\n  let id;\n\n  do {\n    id = String(Math.random()).replace('0.', 'id');\n  } while (store[id]);\n\n  if (withAutoUpdate) {\n    store[id] = true;\n  }\n\n  return id;\n}\n","export type Scheduler = typeof requestAnimationFrame | typeof onTickEnd;\n\nexport function debounce<F extends AnyToVoidFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n  shouldRunLast = true,\n) {\n  let waitingTimeout: number | undefined;\n\n  return (...args: Parameters<F>) => {\n    if (waitingTimeout) {\n      clearTimeout(waitingTimeout);\n      waitingTimeout = undefined;\n    } else if (shouldRunFirst) {\n      fn(...args);\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    waitingTimeout = self.setTimeout(() => {\n      if (shouldRunLast) {\n        fn(...args);\n      }\n\n      waitingTimeout = undefined;\n    }, ms);\n  };\n}\n\nexport function throttle<F extends AnyToVoidFunction>(\n  fn: F,\n  ms: number,\n  shouldRunFirst = true,\n) {\n  let interval: number | undefined;\n  let isPending: boolean;\n  let args: Parameters<F>;\n\n  return (..._args: Parameters<F>) => {\n    isPending = true;\n    args = _args;\n\n    if (!interval) {\n      if (shouldRunFirst) {\n        isPending = false;\n        fn(...args);\n      }\n\n      // eslint-disable-next-line no-restricted-globals\n      interval = self.setInterval(() => {\n        if (!isPending) {\n          // eslint-disable-next-line no-restricted-globals\n          self.clearInterval(interval!);\n          interval = undefined;\n          return;\n        }\n\n        isPending = false;\n        fn(...args);\n      }, ms);\n    }\n  };\n}\n\nexport function throttleWithTickEnd<F extends AnyToVoidFunction>(fn: F) {\n  return throttleWith(onTickEnd, fn);\n}\n\nexport function throttleWith<F extends AnyToVoidFunction>(schedulerFn: Scheduler, fn: F) {\n  let waiting = false;\n  let args: Parameters<F>;\n\n  return (..._args: Parameters<F>) => {\n    args = _args;\n\n    if (!waiting) {\n      waiting = true;\n\n      schedulerFn(() => {\n        waiting = false;\n        fn(...args);\n      });\n    }\n  };\n}\n\nexport function onIdle(cb: NoneToVoidFunction, timeout?: number) {\n  // eslint-disable-next-line no-restricted-globals\n  if (self.requestIdleCallback) {\n    // eslint-disable-next-line no-restricted-globals\n    self.requestIdleCallback(cb, { timeout });\n  } else {\n    onTickEnd(cb);\n  }\n}\n\nexport const pause = (ms: number) => new Promise<void>((resolve) => {\n  setTimeout(() => resolve(), ms);\n});\n\nexport function rafPromise() {\n  return new Promise<void>((resolve) => {\n    fastRaf(resolve);\n  });\n}\n\nconst FAST_RAF_TIMEOUT_FALLBACK_MS = 300;\n\nlet fastRafCallbacks: Set<NoneToVoidFunction> | undefined;\nlet fastRafFallbackCallbacks: Set<NoneToVoidFunction> | undefined;\nlet fastRafFallbackTimeout: number | undefined;\n\n// May result in an immediate execution if called from another RAF callback which was scheduled\n// (and therefore is executed) earlier than RAF callback scheduled by `fastRaf`\nexport function fastRaf(callback: NoneToVoidFunction, withTimeoutFallback = false) {\n  if (!fastRafCallbacks) {\n    fastRafCallbacks = new Set([callback]);\n\n    requestAnimationFrame(() => {\n      const currentCallbacks = fastRafCallbacks!;\n\n      fastRafCallbacks = undefined;\n      fastRafFallbackCallbacks = undefined;\n\n      if (fastRafFallbackTimeout) {\n        clearTimeout(fastRafFallbackTimeout);\n        fastRafFallbackTimeout = undefined;\n      }\n\n      currentCallbacks.forEach((cb) => cb());\n    });\n  } else {\n    fastRafCallbacks.add(callback);\n  }\n\n  if (withTimeoutFallback) {\n    if (!fastRafFallbackCallbacks) {\n      fastRafFallbackCallbacks = new Set([callback]);\n    } else {\n      fastRafFallbackCallbacks.add(callback);\n    }\n\n    if (!fastRafFallbackTimeout) {\n      fastRafFallbackTimeout = window.setTimeout(() => {\n        const currentTimeoutCallbacks = fastRafFallbackCallbacks!;\n\n        if (fastRafCallbacks) {\n          currentTimeoutCallbacks.forEach(fastRafCallbacks.delete, fastRafCallbacks);\n        }\n        fastRafFallbackCallbacks = undefined;\n\n        if (fastRafFallbackTimeout) {\n          clearTimeout(fastRafFallbackTimeout);\n          fastRafFallbackTimeout = undefined;\n        }\n\n        currentTimeoutCallbacks.forEach((cb) => cb());\n      }, FAST_RAF_TIMEOUT_FALLBACK_MS);\n    }\n  }\n}\n\nlet onTickEndCallbacks: NoneToVoidFunction[] | undefined;\n\nexport function onTickEnd(callback: NoneToVoidFunction) {\n  if (!onTickEndCallbacks) {\n    onTickEndCallbacks = [callback];\n\n    Promise.resolve().then(() => {\n      const currentCallbacks = onTickEndCallbacks!;\n      onTickEndCallbacks = undefined;\n      currentCallbacks.forEach((cb) => cb());\n    });\n  } else {\n    onTickEndCallbacks.push(callback);\n  }\n}\n\nlet beforeUnloadCallbacks: NoneToVoidFunction[] | undefined;\n\nexport function onBeforeUnload(callback: NoneToVoidFunction, isLast = false) {\n  if (!beforeUnloadCallbacks) {\n    beforeUnloadCallbacks = [];\n    // eslint-disable-next-line no-restricted-globals\n    self.addEventListener('beforeunload', () => {\n      beforeUnloadCallbacks!.forEach((cb) => cb());\n    });\n  }\n\n  if (isLast) {\n    beforeUnloadCallbacks.push(callback);\n  } else {\n    beforeUnloadCallbacks.unshift(callback);\n  }\n\n  return () => {\n    beforeUnloadCallbacks = beforeUnloadCallbacks!.filter((cb) => cb !== callback);\n  };\n}\n","/*\n * This file is part of the libav.js WebCodecs Polyfill implementation. The\n * interface implemented is derived from the W3C standard. No attribution is\n * required when using this library.\n *\n * Copyright (c) 2021 Yahweasel\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nimport * as eac from './encoded-audio-chunk';\n\nexport type EncodedVideoChunk = eac.EncodedAudioChunk;\nexport const EncodedVideoChunk = eac.EncodedAudioChunk;\nexport type EncodedVideoChunkInit = eac.EncodedAudioChunkInit;\nexport type EncodedVideoChunkType = eac.EncodedAudioChunkType;\n","/*\n * This file is part of the libav.js WebCodecs Polyfill implementation. The\n * interface implemented is derived from the W3C standard. No attribution is\n * required when using this library.\n *\n * Copyright (c) 2021 Yahweasel\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nexport class EncodedAudioChunk {\n  constructor(init: EncodedAudioChunkInit) {\n    this.type = init.type;\n    this.timestamp = init.timestamp;\n    this.duration = init.duration || 0;\n    const data = (this._data = new Uint8Array(\n      (<any>init.data).buffer || init.data,\n      (<any>init.data).byteOffset || 0\n    ));\n    this.byteLength = data.byteLength;\n  }\n\n  readonly type: EncodedAudioChunkType;\n\n  readonly timestamp: number; // microseconds\n\n  readonly duration?: number; // microseconds\n\n  readonly byteLength: number;\n\n  private _data: Uint8Array;\n\n  // Internal\n  _libavGetData() {\n    return this._data;\n  }\n\n  copyTo(destination: BufferSource) {\n    new Uint8Array(\n      (<any>destination).buffer || destination,\n      (<any>destination).byteOffset || 0\n    ).set(this._data);\n  }\n}\n\nexport interface EncodedAudioChunkInit {\n  type: EncodedAudioChunkType;\n  timestamp: number; // microseconds\n  duration?: number; // microseconds\n  data: BufferSource;\n}\n\nexport type EncodedAudioChunkType = 'key' | 'delta';\n","// @ts-nocheck\n\n/*\n * This file is part of the libav.js WebCodecs Polyfill implementation. The\n * interface implemented is derived from the W3C standard. No attribution is\n * required when using this library.\n *\n * Copyright (c) 2021 Yahweasel\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n// A canvas element used to convert CanvasImageSources to buffers\nlet offscreenCanvas: HTMLCanvasElement = null;\n\nexport class VideoFrame {\n  constructor(data: CanvasImageSource | BufferSource, init: VideoFrameInit | VideoFrameBufferInit) {\n    if (data instanceof ArrayBuffer || (<any>data).buffer instanceof ArrayBuffer) {\n      this._constructBuffer(<BufferSource>data, <VideoFrameBufferInit>init);\n    } else {\n      this._constructCanvas(<CanvasImageSource>data, <VideoFrameInit>init);\n    }\n  }\n\n  private _constructCanvas(image: any, init: VideoFrameInit) {\n    if (offscreenCanvas === null) {\n      offscreenCanvas = document.createElement('canvas');\n      offscreenCanvas.style.display = 'none';\n      document.body.appendChild(offscreenCanvas);\n    }\n\n    // Convert it to a buffer\n\n    // Get the width and height\n    let width = 0;\n    let height = 0;\n    if (image.naturalWidth) {\n      width = image.naturalWidth;\n      height = image.naturalHeight;\n    } else if (image.videoWidth) {\n      width = image.videoWidth;\n      height = image.videoHeight;\n    } else if (image.width) {\n      width = image.width;\n      height = image.height;\n    }\n    if (!width || !height) {\n      throw new DOMException('Could not determine dimensions', 'InvalidStateError');\n    }\n\n    // Draw it\n    offscreenCanvas.width = width;\n    offscreenCanvas.height = height;\n    const ctx = offscreenCanvas.getContext('2d');\n    ctx.clearRect(0, 0, width, height);\n    ctx.drawImage(image, 0, 0);\n    this._constructBuffer(ctx.getImageData(0, 0, width, height).data, {\n      format: 'RGBA',\n      codedWidth: width,\n      codedHeight: height,\n      timestamp: init.timestamp,\n      duration: init.duration || 0,\n      layout: [\n        {\n          offset: 0,\n          stride: width * 4\n        }\n      ],\n      displayWidth: init.displayWidth || width,\n      displayHeight: init.displayHeight || height\n    });\n  }\n\n  private _constructBuffer(data: BufferSource, init: VideoFrameBufferInit) {\n    const format = (this.format = init.format);\n    const width = (this.codedWidth = init.codedWidth);\n    const height = (this.codedHeight = init.codedHeight);\n    this.visibleRect = new DOMRect(0, 0, width, height);\n\n    const dWidth = (this.displayWidth = init.displayWidth || init.codedWidth);\n    const dHeight = (this.displayHeight = init.displayHeight || init.codedHeight);\n\n    // Account for non-square pixels\n    if (dWidth !== width || dHeight !== height) {\n      // Dubious (but correct) SAR calculation\n      this._nonSquarePixels = true;\n      this._sar_num = dWidth * height;\n      this._sar_den = dHeight * width;\n    } else {\n      this._nonSquarePixels = false;\n    }\n\n    this.timestamp = init.timestamp;\n    if (init.duration) {\n      this.duration = init.duration;\n    }\n\n    if (init.layout) {\n      this._layout = init.layout; // FIXME: Make sure it's the right size\n    } else {\n      const numPlanes_ = numPlanes(format);\n      const layout: PlaneLayout[] = [];\n      let offset = 0;\n      for (let i = 0; i < numPlanes_; i++) {\n        const sampleWidth = horizontalSubSamplingFactor(format, i);\n        const sampleHeight = verticalSubSamplingFactor(format, i);\n        const stride = ~~(width / sampleWidth);\n        layout.push({\n          offset,\n          stride\n        });\n        offset += stride * ~~(height / sampleHeight);\n      }\n      this._layout = layout;\n    }\n\n    this._data = new Uint8Array((<any>data).buffer || data, (<any>data).byteOffset || 0);\n  }\n\n  /* NOTE: These should all be readonly, but the constructor style above\n   * doesn't work with that */\n  format: VideoPixelFormat;\n\n  codedWidth: number;\n\n  codedHeight: number;\n\n  codedRect: DOMRectReadOnly;\n\n  visibleRect: DOMRectReadOnly;\n\n  displayWidth: number;\n\n  displayHeight: number;\n\n  duration: number; // microseconds\n\n  timestamp: number; // microseconds\n\n  colorSpace: VideoColorSpace;\n\n  private _layout: PlaneLayout[];\n\n  private _data: Uint8Array;\n\n  /**\n   * (Internal) Does this use non-square pixels?\n   */\n  _nonSquarePixels: boolean;\n\n  /**\n   * (Internal) If non-square pixels, the SAR (sample/pixel aspect ratio)\n   */\n  _sar_num: number;\n\n  _sar_den: number;\n\n  // Internal\n  _libavGetData() {\n    return this._data;\n  }\n\n  allocationSize(options: VideoFrameCopyToOptions = {}): number {\n    // 1. If [[Detached]] is true, throw an InvalidStateError DOMException.\n    if (this._data === null) {\n      throw new DOMException('Detached', 'InvalidStateError');\n    }\n\n    // 2. If [[format]] is null, throw a NotSupportedError DOMException.\n    if (this.format === null) {\n      throw new DOMException('Not supported', 'NotSupportedError');\n    }\n\n    /* 3. Let combinedLayout be the result of running the Parse\n     * VideoFrameCopyToOptions algorithm with options. */\n    // 4. If combinedLayout is an exception, throw combinedLayout.\n    const combinedLayout = this._parseVideoFrameCopyToOptions(options);\n\n    // 5. Return combinedLayouts allocationSize.\n    return combinedLayout.allocationSize;\n  }\n\n  private _parseVideoFrameCopyToOptions(options: VideoFrameCopyToOptions) {\n    /* 1. Let defaultRect be the result of performing the getter steps for\n     * visibleRect. */\n    const defaultRect = this.visibleRect;\n\n    // 2. Let overrideRect be undefined.\n    // 3. If options.rect exists, assign its value to overrideRect.\n    const overrideRect: DOMRectReadOnly = options.rect\n      ? new DOMRect(options.rect.x, options.rect.y, options.rect.width, options.rect.height)\n      : null;\n\n    /* 4. Let parsedRect be the result of running the Parse Visible Rect\n     * algorithm with defaultRect, overrideRect, [[coded width]], [[coded\n     * height]], and [[format]]. */\n    // 5. If parsedRect is an exception, return parsedRect.\n    const parsedRect = this._parseVisibleRect(defaultRect, overrideRect);\n\n    // 6. Let optLayout be undefined.\n    // 7. If options.layout exists, assign its value to optLayout.\n    const optLayout = options.layout || null;\n\n    /* 8. Let combinedLayout be the result of running the Compute Layout\n     * and Allocation Size algorithm with parsedRect, [[format]], and\n     * optLayout. */\n    const combinedLayout = this._computeLayoutAndAllocationSize(parsedRect, optLayout);\n\n    // 9. Return combinedLayout.\n    return combinedLayout;\n  }\n\n  private _parseVisibleRect(defaultRect: DOMRectReadOnly, overrideRect: DOMRectReadOnly) {\n    // 1. Let sourceRect be defaultRect\n    let sourceRect = defaultRect;\n\n    // 2. If overrideRect is not undefined:\n    if (overrideRect) {\n      /* 1. If either of overrideRect.width or height is 0, return a\n       * TypeError. */\n      if (overrideRect.width === 0 || overrideRect.height === 0) {\n        throw new TypeError('Invalid rectangle');\n      }\n\n      /* 2. If the sum of overrideRect.x and overrideRect.width is\n       * greater than [[coded width]], return a TypeError. */\n      if (overrideRect.x + overrideRect.width > this.codedWidth) {\n        throw new TypeError('Invalid rectangle');\n      }\n\n      /* 3. If the sum of overrideRect.y and overrideRect.height is\n       * greater than [[coded height]], return a TypeError. */\n      if (overrideRect.y + overrideRect.height > this.codedHeight) {\n        throw new TypeError('Invalid rectangle');\n      }\n\n      // 4. Assign overrideRect to sourceRect.\n      sourceRect = overrideRect;\n    }\n\n    /* 3. Let validAlignment be the result of running the Verify Rect\n     * Sample Alignment algorithm with format and sourceRect. */\n    const validAlignment = this._verifyRectSampleAlignment(sourceRect);\n\n    // 4. If validAlignment is false, throw a TypeError.\n    if (!validAlignment) {\n      throw new TypeError('Invalid alignment');\n    }\n\n    // 5. Return sourceRect.\n    return sourceRect;\n  }\n\n  private _computeLayoutAndAllocationSize(parsedRect: DOMRectReadOnly, layout: PlaneLayout[]) {\n    // 1. Let numPlanes be the number of planes as defined by format.\n    const numPlanes_ = numPlanes(this.format);\n\n    /* 2. If layout is not undefined and its length does not equal\n     * numPlanes, throw a TypeError. */\n    if (layout && layout.length !== numPlanes_) {\n      throw new TypeError('Invalid layout');\n    }\n\n    // 3. Let minAllocationSize be 0.\n    let minAllocationSize = 0;\n\n    // 4. Let computedLayouts be a new list.\n    const computedLayouts: ComputedPlaneLayout[] = [];\n\n    // 5. Let endOffsets be a new list.\n    const endOffsets = [];\n\n    // 6. Let planeIndex be 0.\n    let planeIndex = 0;\n\n    // 7. While planeIndex < numPlanes:\n    while (planeIndex < numPlanes_) {\n      /* 1. Let plane be the Plane identified by planeIndex as defined by\n       * format. */\n\n      // 2. Let sampleBytes be the number of bytes per sample for plane.\n      const sampleBytes_ = sampleBytes(this.format, planeIndex);\n\n      /* 3. Let sampleWidth be the horizontal sub-sampling factor of each\n       * subsample for plane. */\n      const sampleWidth = horizontalSubSamplingFactor(this.format, planeIndex);\n\n      /* 4. Let sampleHeight be the vertical sub-sampling factor of each\n       * subsample for plane. */\n      const sampleHeight = verticalSubSamplingFactor(this.format, planeIndex);\n\n      /* 5. Let sampleWidthBytes be the product of multiplying\n       * sampleWidth by sampleBytes. */\n      const sampleWidthBytes = sampleWidth * sampleBytes_;\n\n      // 6. Let computedLayout be a new computed plane layout.\n      const computedLayout: ComputedPlaneLayout = {\n        destinationOffset: 0,\n        destinationStride: 0,\n\n        /* 7. Set computedLayouts sourceTop to the result of the\n         * integer division of truncated parsedRect.y by sampleHeight. */\n        sourceTop: ~~(parsedRect.y / sampleHeight),\n\n        /* 8. Set computedLayouts sourceHeight to the result of the\n         * integer division of truncated parsedRect.height by\n         * sampleHeight */\n        sourceHeight: ~~(parsedRect.height / sampleHeight),\n\n        /* 9. Set computedLayouts sourceLeftBytes to the result of the\n         * integer division of truncated parsedRect.x by\n         * sampleWidthBytes. */\n        sourceLeftBytes: ~~(parsedRect.x / sampleWidthBytes),\n\n        /* 10. Set computedLayouts sourceWidthBytes to the result of\n         * the integer division of truncated parsedRect.width by\n         * sampleWidthBytes. */\n        sourceWidthBytes: ~~(parsedRect.width / sampleWidthBytes)\n      };\n\n      // 11. If layout is not undefined:\n      if (layout) {\n        /* 1. Let planeLayout be the PlaneLayout in layout at position\n         * planeIndex. */\n        const planeLayout = layout[planeIndex];\n\n        /* 2. If planeLayout.stride is less than computedLayouts\n         * sourceWidthBytes, return a TypeError. */\n        if (planeLayout.stride < computedLayout.sourceWidthBytes) {\n          throw new TypeError('Invalid stride');\n        }\n\n        /* 3. Assign planeLayout.offset to computedLayouts\n         * destinationOffset. */\n        computedLayout.destinationOffset = planeLayout.offset;\n\n        /* 4. Assign planeLayout.stride to computedLayouts\n         * destinationStride. */\n        computedLayout.destinationStride = planeLayout.stride;\n\n        // 12. Otherwise:\n      } else {\n        /* 1. Assign minAllocationSize to computedLayouts\n         * destinationOffset. */\n        computedLayout.destinationOffset = minAllocationSize;\n\n        /* 2. Assign computedLayouts sourceWidthBytes to\n         * computedLayouts destinationStride. */\n        computedLayout.destinationStride = computedLayout.sourceWidthBytes;\n      }\n\n      /* 13. Let planeSize be the product of multiplying computedLayouts\n       * destinationStride and sourceHeight. */\n      const planeSize = computedLayout.destinationStride * computedLayout.sourceHeight;\n\n      /* 14. Let planeEnd be the sum of planeSize and computedLayouts\n       * destinationOffset. */\n      const planeEnd = planeSize + computedLayout.destinationOffset;\n\n      /* 15. If planeSize or planeEnd is greater than maximum range of\n       * unsigned long, return a TypeError. */\n      if (planeSize >= 0x100000000 || planeEnd >= 0x100000000) {\n        throw new TypeError('Plane too large');\n      }\n\n      // 16. Append planeEnd to endOffsets.\n      endOffsets.push(planeEnd);\n\n      /* 17. Assign the maximum of minAllocationSize and planeEnd to\n       * minAllocationSize. */\n      if (planeEnd > minAllocationSize) {\n        minAllocationSize = planeEnd;\n      }\n\n      // 18. Let earlierPlaneIndex be 0.\n      let earlierPlaneIndex = 0;\n\n      // 19. While earlierPlaneIndex is less than planeIndex.\n      while (earlierPlaneIndex < planeIndex) {\n        // 1. Let earlierLayout be computedLayouts[earlierPlaneIndex].\n        const earlierLayout = computedLayouts[earlierPlaneIndex];\n\n        /* 2. If endOffsets[planeIndex] is less than or equal to\n         * earlierLayouts destinationOffset or if\n         * endOffsets[earlierPlaneIndex] is less than or equal to\n         * computedLayouts destinationOffset, continue. */\n        if (\n          planeEnd <= earlierLayout.destinationOffset ||\n          endOffsets[earlierPlaneIndex] <= computedLayout.destinationOffset\n        ) {\n          // 3. Otherwise, return a TypeError.\n        } else {\n          throw new TypeError('Invalid plane layout');\n        }\n\n        // 4. Increment earlierPlaneIndex by 1.\n        earlierPlaneIndex++;\n      }\n\n      // 20. Append computedLayout to computedLayouts.\n      computedLayouts.push(computedLayout);\n\n      // 21. Increment planeIndex by 1.\n      planeIndex++;\n    }\n\n    /* 8. Let combinedLayout be a new combined buffer layout, initialized\n     * as follows: */\n    const combinedLayout = {\n      // 1. Assign computedLayouts to computedLayouts.\n      computedLayouts,\n\n      // 2. Assign minAllocationSize to allocationSize.\n      allocationSize: minAllocationSize\n    };\n\n    // 9. Return combinedLayout.\n    return combinedLayout;\n  }\n\n  private _verifyRectSampleAlignment(rect: DOMRectReadOnly) {\n    // 1. If format is null, return true.\n    if (!this.format) {\n      return true;\n    }\n\n    // 2. Let planeIndex be 0.\n    let planeIndex = 0;\n\n    // 3. Let numPlanes be the number of planes as defined by format.\n    const numPlanes_ = numPlanes(this.format);\n\n    // 4. While planeIndex is less than numPlanes:\n    while (planeIndex < numPlanes_) {\n      /* 1. Let plane be the Plane identified by planeIndex as defined by\n       * format. */\n\n      /* 2. Let sampleWidth be the horizontal sub-sampling factor of each\n       * subsample for plane. */\n      const sampleWidth = horizontalSubSamplingFactor(this.format, planeIndex);\n\n      /* 3. Let sampleHeight be the vertical sub-sampling factor of each\n       * subsample for plane. */\n      const sampleHeight = verticalSubSamplingFactor(this.format, planeIndex);\n\n      /* 4. If rect.x and rect.width are not both multiples of\n       * sampleWidth, return false. */\n      const xw = rect.x / sampleWidth;\n      if (xw !== ~~xw) {\n        return false;\n      }\n      const ww = rect.width / sampleWidth;\n      if (ww !== ~~ww) {\n        return false;\n      }\n\n      /* 5. If rect.y and rect.height are not both multiples of\n       * sampleHeight, return false. */\n      const yh = rect.y / sampleHeight;\n      if (yh !== ~~yh) {\n        return false;\n      }\n      const hh = rect.height / sampleHeight;\n      if (hh !== ~~hh) {\n        return false;\n      }\n\n      // 6. Increment planeIndex by 1.\n      planeIndex++;\n    }\n\n    // 5. Return true.\n    return true;\n  }\n\n  async copyTo(\n    destination: BufferSource,\n    options: VideoFrameCopyToOptions = {}\n  ): Promise<PlaneLayout[]> {\n    const destBuf = new Uint8Array(\n      (<any>destination).buffer || destination,\n      (<any>destination).byteOffset || 0\n    );\n\n    // 1. If [[Detached]] is true, throw an InvalidStateError DOMException.\n    if (this._data === null) {\n      throw new DOMException('Detached', 'InvalidStateError');\n    }\n\n    // 2. If [[format]] is null, throw a NotSupportedError DOMException.\n    if (!this.format) {\n      throw new DOMException('No format', 'NotSupportedError');\n    }\n\n    /* 3. Let combinedLayout be the result of running the Parse\n     * VideoFrameCopyToOptions algorithm with options. */\n    /* 4. If combinedLayout is an exception, return a promise rejected with\n     * combinedLayout. */\n    const combinedLayout = this._parseVideoFrameCopyToOptions(options);\n\n    /* 5. If destination.byteLength is less than combinedLayouts\n     * allocationSize, return a promise rejected with a TypeError. */\n    if (destination.byteLength < combinedLayout.allocationSize) {\n      throw new TypeError('Insufficient space');\n    }\n\n    // 6. Let p be a new Promise.\n    /* 7. Let copyStepsQueue be the result of starting a new parallel\n     * queue. */\n    // 8. Enqueue the following steps to copyStepsQueue:\n    // NOTE: This is an async function anyway, so we can just do these.\n    const ret: PlaneLayout[] = [];\n\n    /* 1. Let resource be the media resource referenced by [[resource\n     * reference]]. */\n\n    // 2. Let numPlanes be the number of planes as defined by [[format]].\n    const numPlanes_ = numPlanes(this.format);\n\n    // 3. Let planeIndex be 0.\n    let planeIndex = 0;\n\n    // 4. While planeIndex is less than combinedLayouts numPlanes:\n    while (planeIndex < combinedLayout.computedLayouts.length) {\n      /* 1. Let sourceStride be the stride of the plane in resource as\n       * identified by planeIndex. */\n      const sourceStride = this._layout[planeIndex].stride;\n\n      /* 2. Let computedLayout be the computed plane layout in\n       * combinedLayouts computedLayouts at the position of planeIndex */\n      const computedLayout = combinedLayout.computedLayouts[planeIndex];\n\n      /* 3. Let sourceOffset be the product of multiplying\n       * computedLayouts sourceTop by sourceStride */\n      let sourceOffset = computedLayout.sourceTop * sourceStride;\n\n      // 4. Add computedLayouts sourceLeftBytes to sourceOffset.\n      sourceOffset += computedLayout.sourceLeftBytes;\n\n      // 5. Let destinationOffset be computedLayouts destinationOffset.\n      let destinationOffset = computedLayout.destinationOffset;\n\n      // 6. Let rowBytes be computedLayouts sourceWidthBytes.\n      const rowBytes = computedLayout.sourceWidthBytes;\n\n      // 7. Let row be 0.\n      let row = 0;\n\n      // 8. While row is less than computedLayouts sourceHeight:\n      while (row < computedLayout.sourceHeight) {\n        /* 1. Copy rowBytes bytes from resource starting at\n         * sourceOffset to destination starting at destinationOffset. */\n        destBuf.set(this._data.subarray(sourceOffset, sourceOffset + rowBytes), destinationOffset);\n\n        // 2. Increment sourceOffset by sourceStride.\n        sourceOffset += sourceStride;\n\n        /* 3. Increment destinationOffset by computedLayouts\n         * destinationStride. */\n        destinationOffset += computedLayout.destinationStride;\n\n        // 4. Increment row by 1.\n        row++;\n      }\n\n      // 9. Increment planeIndex by 1.\n      planeIndex++;\n      ret.push({\n        offset: computedLayout.destinationOffset,\n        stride: computedLayout.destinationStride\n      });\n    }\n\n    // 5. Queue a task on the control thread event loop to resolve p.\n    // 6. Return p.\n    return ret;\n  }\n\n  clone(): VideoFrame {\n    return new VideoFrame(this._data, {\n      format: this.format,\n      codedWidth: this.codedWidth,\n      codedHeight: this.codedHeight,\n      timestamp: this.timestamp,\n      duration: this.duration,\n      layout: this._layout\n    });\n  }\n\n  close(): void {\n    this._data = null;\n  }\n}\n\nexport interface VideoFrameInit {\n  duration?: number; // microseconds\n  timestamp: number; // microseconds\n  // FIXME: AlphaOption alpha = \"keep\";\n\n  // Default matches image. May be used to efficiently crop. Will trigger\n  // new computation of displayWidth and displayHeight using images pixel\n  // aspect ratio unless an explicit displayWidth and displayHeight are given.\n  visibleRect?: DOMRectInit;\n\n  // Default matches image unless visibleRect is provided.\n  displayWidth?: number;\n  displayHeight?: number;\n}\n\nexport interface VideoFrameBufferInit {\n  format: VideoPixelFormat;\n  codedWidth: number;\n  codedHeight: number;\n  timestamp: number; // microseconds\n  duration?: number; // microseconds\n\n  // Default layout is tightly-packed.\n  layout?: PlaneLayout[];\n\n  // Default visible rect is coded size positioned at (0,0)\n  visibleRect?: DOMRectInit;\n\n  // Default display dimensions match visibleRect.\n  displayWidth?: number;\n  displayHeight?: number;\n\n  // FIXME: Not used\n  colorSpace?: VideoColorSpaceInit;\n}\n\nexport type VideoPixelFormat =\n  // 4:2:0 Y, U, V\n  | 'I420'\n  // 4:2:0 Y, U, V, A\n  | 'I420A'\n  // 4:2:2 Y, U, V\n  | 'I422'\n  // 4:4:4 Y, U, V\n  | 'I444'\n  // 4:2:0 Y, UV\n  | 'NV12'\n  // 32bpp RGBA\n  | 'RGBA'\n  // 32bpp RGBX (opaque)\n  | 'RGBX'\n  // 32bpp BGRA\n  | 'BGRA'\n  // 32bpp BGRX (opaque)\n  | 'BGRX';\n\n/**\n * Number of planes in the given format.\n * @param format  The format\n */\nexport function numPlanes(format: VideoPixelFormat) {\n  switch (format) {\n    case 'I420':\n    case 'I422':\n    case 'I444':\n      return 3;\n\n    case 'I420A':\n      return 4;\n\n    case 'NV12':\n      return 2;\n\n    case 'RGBA':\n    case 'RGBX':\n    case 'BGRA':\n    case 'BGRX':\n      return 1;\n\n    default:\n      throw new DOMException('Unsupported video pixel format', 'NotSupportedError');\n  }\n}\n\n/**\n * Number of bytes per sample in the given format and plane.\n * @param format  The format\n * @param planeIndex  The plane index\n */\nexport function sampleBytes(format: VideoPixelFormat, planeIndex: number) {\n  switch (format) {\n    case 'I420':\n    case 'I420A':\n    case 'I422':\n    case 'I444':\n      return 1;\n\n    case 'NV12':\n      if (planeIndex === 1) {\n        return 2;\n      } else {\n        return 1;\n      }\n\n    case 'RGBA':\n    case 'RGBX':\n    case 'BGRA':\n    case 'BGRX':\n      return 4;\n\n    default:\n      throw new DOMException('Unsupported video pixel format', 'NotSupportedError');\n  }\n}\n\n/**\n * Horizontal sub-sampling factor for the given format and plane.\n * @param format  The format\n * @param planeIndex  The plane index\n */\nexport function horizontalSubSamplingFactor(format: VideoPixelFormat, planeIndex: number) {\n  // First plane (often luma) is always full\n  if (planeIndex === 0) {\n    return 1;\n  }\n\n  switch (format) {\n    case 'I420':\n    case 'I422':\n      return 2;\n\n    case 'I420A':\n      if (planeIndex === 3) {\n        return 1;\n      } else {\n        return 2;\n      }\n\n    case 'I444':\n      return 1;\n\n    case 'NV12':\n      return 2;\n\n    case 'RGBA':\n    case 'RGBX':\n    case 'BGRA':\n    case 'BGRX':\n      return 1;\n\n    default:\n      throw new DOMException('Unsupported video pixel format', 'NotSupportedError');\n  }\n}\n\n/**\n * Vertical sub-sampling factor for the given format and plane.\n * @param format  The format\n * @param planeIndex  The plane index\n */\nexport function verticalSubSamplingFactor(format: VideoPixelFormat, planeIndex: number) {\n  // First plane (often luma) is always full\n  if (planeIndex === 0) {\n    return 1;\n  }\n\n  switch (format) {\n    case 'I420':\n      return 2;\n\n    case 'I420A':\n      if (planeIndex === 3) {\n        return 1;\n      } else {\n        return 2;\n      }\n\n    case 'I422':\n    case 'I444':\n      return 1;\n\n    case 'NV12':\n      return 2;\n\n    case 'RGBA':\n    case 'RGBX':\n    case 'BGRA':\n    case 'BGRX':\n      return 1;\n\n    default:\n      throw new DOMException('Unsupported video pixel format', 'NotSupportedError');\n  }\n}\n\n/**\n * NOTE: Color space is not actually supported\n */\nexport type VideoColorSpace = any;\nexport type VideoColorSpaceInit = any;\n\nexport interface PlaneLayout {\n  offset: number;\n  stride: number;\n}\n\nexport interface VideoFrameCopyToOptions {\n  rect?: DOMRectInit;\n  layout?: PlaneLayout[];\n}\n\ninterface ComputedPlaneLayout {\n  destinationOffset: number;\n  destinationStride: number;\n  sourceTop: number;\n  sourceHeight: number;\n  sourceLeftBytes: number;\n  sourceWidthBytes: number;\n}\n","// @ts-nocheck\n\n/*\n * This file is part of the libav.js WebCodecs Polyfill implementation. The\n * interface implemented is derived from the W3C standard. No attribution is\n * required when using this library.\n *\n * Copyright (c) 2021 Yahweasel\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nimport type * as LibAVJS from '../libav.types';\n\ndeclare let LibAV: LibAVJS.LibAVWrapper;\n\n// Currently available libav instances\nconst libavs: LibAVJS.LibAV[] = [];\n\n// Options required to create a LibAV instance\nlet libavOptions: any = {};\n\n/**\n * Supported decoders.\n */\nexport let decoders: string[] = null;\n\n/**\n * libav.js-specific codec request, used to bypass the codec registry and use\n * anything your implementation of libav.js supports.\n */\nexport interface LibAVJSCodec {\n  codec: string;\n  ctx?: LibAVJS.AVCodecContextProps;\n  options?: Record<string, string>;\n}\n\n/**\n * Set the libav loading options.\n */\nexport function setLibAVOptions(to: any) {\n  libavOptions = to;\n}\n\n/**\n * Get a libav instance.\n */\nexport async function get(): Promise<LibAVJS.LibAV> {\n  if (libavs.length) {\n    return libavs.shift();\n  }\n  return LibAV.LibAV(libavOptions);\n}\n\n/**\n * Free a libav instance for later reuse.\n */\nexport function free(libav: LibAVJS.LibAV) {\n  libavs.push(libav);\n}\n\n/**\n * Get the list of encoders/decoders supported by libav (which are also\n * supported by this polyfill)\n */\nasync function codecs(): Promise<string[]> {\n  const libav = await get();\n  const ret: string[] = [];\n\n  for (const [avname, codec] of [\n    ['libaom-av1', 'av01'],\n    ['h264', 'avc1'],\n    ['hevc', 'hvc1'],\n  ]) {\n    if (await libav.avcodec_find_decoder_by_name(avname)) {\n      ret.push(codec);\n    }\n  }\n\n  free(libav);\n  return ret;\n}\n\n/**\n * Load the lists of supported decoders and encoders.\n */\nexport async function load() {\n  decoders = await codecs();\n}\n\n/**\n * Convert a decoder from the codec registry (or libav.js-specific parameters)\n * to libav.js. Returns null if unsupported.\n */\nexport function decoder(codec: string | { libavjs: LibAVJSCodec }): LibAVJSCodec {\n  if (typeof codec === 'string') {\n    codec = codec.replace(/\\..*/, '');\n\n    let outCodec: string = codec;\n    switch (codec) {\n      // Video\n      case 'av01':\n        outCodec = 'libaom-av1';\n        break;\n      case 'avc1':\n        outCodec = 'h264';\n        break;\n\n      case 'hvc1':\n        outCodec = 'hevc';\n        break;\n\n      // Unrecognized\n      default:\n        return null;\n    }\n\n    // Check whether we actually support this codec\n    if (!(decoders.indexOf(codec) >= 0)) {\n      return null;\n    }\n\n    return { codec: outCodec };\n  } else {\n    return codec.libavjs;\n  }\n}\n","/*\n * This file is part of the libav.js WebCodecs Polyfill implementation. The\n * interface implemented is derived from the W3C standard. No attribution is\n * required when using this library.\n *\n * Copyright (c) 2021 Yahweasel\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nexport type CodecState = 'unconfigured' | 'configured' | 'closed';\n\nexport type WebCodecsErrorCallback = (error: DOMException) => void;\n\n/**\n * Clone this configuration. Just copies over the supported/recognized fields.\n */\nexport function cloneConfig(config: any, fields: string[]): any {\n  const ret: any = {};\n  for (const field of fields) {\n    if (field in config) {\n      ret[field] = config[field];\n    }\n  }\n  return ret;\n}\n","// @ts-nocheck\n\n/*\n * This file is part of the libav.js WebCodecs Polyfill implementation. The\n * interface implemented is derived from the W3C standard. No attribution is\n * required when using this library.\n *\n * Copyright (c) 2021 Yahweasel\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nimport type * as LibAVJS from '../libav.types';\nimport type * as evc from './encoded-video-chunk';\nimport * as libavs from './libav';\nimport * as misc from './misc';\nimport * as vf from './video-frame';\n\nexport class VideoDecoder {\n  constructor(init: VideoDecoderInit) {\n    this._output = init.output;\n    this._error = init.error;\n\n    this.state = 'unconfigured';\n    this.decodeQueueSize = 0;\n\n    this._p = Promise.all([]);\n    this._libav = null;\n    this._codec = this._c = this._pkt = this._frame = 0;\n  }\n\n  /* NOTE: These should technically be readonly, but I'm implementing them as\n   * plain fields, so they're writable */\n  state: misc.CodecState;\n\n  decodeQueueSize: number;\n\n  private _output: VideoFrameOutputCallback;\n\n  private _error: misc.WebCodecsErrorCallback;\n\n  // Event queue\n  private _p: Promise<unknown>;\n\n  // LibAV state\n  private _libav: LibAVJS.LibAV;\n\n  private _codec: number;\n\n  private _c: number;\n\n  private _pkt: number;\n\n  private _frame: number;\n\n  configure(config: VideoDecoderConfig): void {\n    const self = this;\n\n    // 1. If config is not a valid VideoDecoderConfig, throw a TypeError.\n    // NOTE: We don't support sophisticated codec string parsing (yet)\n\n    // 2. If [[state]] is closed, throw an InvalidStateError DOMException.\n    if (this.state === 'closed') {\n      throw new DOMException('Decoder is closed', 'InvalidStateError');\n    }\n\n    // Free any internal state\n    if (this._libav) {\n      this._p = this._p.then(() => this._free());\n    }\n\n    // 3. Set [[state]] to \"configured\".\n    this.state = 'configured';\n\n    // 4. Set [[key chunk required]] to true.\n    // NOTE: Not implemented\n\n    // 5. Queue a control message to configure the decoder with config.\n    this._p = this._p\n      .then(async () => {\n        /* 1. Let supported be the result of running the Check\n         * Configuration Support algorithm with config. */\n        const supported = libavs.decoder(config.codec);\n\n        /* 2. If supported is true, assign [[codec implementation]] with an\n         * implementation supporting config. */\n        if (supported) {\n          const libav = (self._libav = await libavs.get());\n\n          const ptr = await libav.malloc(config.description.length);\n          await libav.copyin_u8(ptr, config.description);\n          const parm = await libav.calloc(1, 1024);\n          await libav.AVCodecParameters_extradata_s(parm, ptr);\n          await libav.AVCodecParameters_extradata_size_s(parm, config.description.length);\n          // Initialize\n          [self._codec, self._c, self._pkt, self._frame] = await libav.ff_init_decoder(\n            supported.codec,\n            parm,\n          );\n          await libav.AVCodecContext_time_base_s(self._c, 1, 1000);\n          await libav.free(ptr);\n          await libav.free(parm);\n        } else {\n          /* 3. Otherwise, run the Close VideoDecoder algorithm with\n           * NotSupportedError DOMException. */\n          self._closeVideoDecoder(new DOMException('Unsupported codec', 'NotSupportedError'));\n        }\n      })\n      .catch(this._error);\n  }\n\n  // Our own algorithm, close libav\n  private async _free() {\n    if (this._c) {\n      await this._libav.ff_free_decoder(this._c, this._pkt, this._frame);\n      this._codec = this._c = this._pkt = this._frame = 0;\n    }\n    if (this._libav) {\n      libavs.free(this._libav);\n      this._libav = null;\n    }\n  }\n\n  private _closeVideoDecoder(exception: DOMException) {\n    // 1. Run the Reset VideoDecoder algorithm with exception.\n    this._resetVideoDecoder(exception);\n\n    // 2. Set [[state]] to \"closed\".\n    this.state = 'closed';\n\n    /* 3. Clear [[codec implementation]] and release associated system\n     * resources. */\n    this._p = this._p.then(() => this._free());\n\n    /* 4. If exception is not an AbortError DOMException, queue a task on\n     * the control thread event loop to invoke the [[error callback]] with\n     * exception. */\n    if (exception.name !== 'AbortError') {\n      this._p = this._p.then(() => {\n        this._error(exception);\n      });\n    }\n  }\n\n  private _resetVideoDecoder(exception: DOMException) {\n    // 1. If [[state]] is \"closed\", throw an InvalidStateError.\n    if (this.state === 'closed') {\n      throw new DOMException('Decoder closed', 'InvalidStateError');\n    }\n\n    // 2. Set [[state]] to \"unconfigured\".\n    this.state = 'unconfigured';\n\n    // ... really, we're just going to free it now\n    this._p = this._p.then(() => this._free());\n  }\n\n  decode(chunk: evc.EncodedVideoChunk): void {\n    const self = this;\n\n    // 1. If [[state]] is not \"configured\", throw an InvalidStateError.\n    if (this.state !== 'configured') {\n      throw new DOMException('Unconfigured', 'InvalidStateError');\n    }\n\n    // 2. If [[key chunk required]] is true:\n    //    1. If chunk.[[type]] is not key, throw a DataError.\n    /*    2. Implementers SHOULD inspect the chunks [[internal data]] to\n     *    verify that it is truly a key chunk. If a mismatch is detected,\n     *    throw a DataError. */\n    //    3. Otherwise, assign false to [[key chunk required]].\n\n    // 3. Increment [[decodeQueueSize]].\n    this.decodeQueueSize++;\n\n    // 4. Queue a control message to decode the chunk.\n    this._p = this._p\n      .then(async () => {\n        const libav = self._libav;\n        const c = self._c;\n        const pkt = self._pkt;\n        const frame = self._frame;\n\n        let decodedOutputs: LibAVJS.Frame[] = null;\n\n        // 1. Attempt to use [[codec implementation]] to decode the chunk.\n        try {\n          // Convert to a libav packet\n          const ptsFull = Math.floor(chunk.timestamp / 1000);\n          const pts = ptsFull % 0x100000000;\n          const ptshi = ~~(ptsFull / 0x100000000);\n          const packet: LibAVJS.Packet = {\n            data: chunk._libavGetData(),\n            pts,\n            ptshi,\n            dts: pts,\n            dtshi: ptshi,\n          };\n          if (chunk.duration) {\n            packet.duration = Math.floor(chunk.duration / 1000);\n            packet.durationhi = 0;\n          }\n\n          decodedOutputs = await libav.ff_decode_multi(c, pkt, frame, [packet]);\n\n          /* 2. If decoding results in an error, queue a task on the control\n           * thread event loop to run the Close VideoDecoder algorithm with\n           * EncodingError. */\n        } catch (ex) {\n          // console.log('Error decoding', ex);\n          self._p = self._p.then(() => {\n            self._closeVideoDecoder(ex);\n          });\n        }\n\n        /* 3. Queue a task on the control thread event loop to decrement\n         * [[decodeQueueSize]]. */\n        self.decodeQueueSize--;\n\n        /* 4. Let decoded outputs be a list of decoded audio data outputs\n         * emitted by [[codec implementation]]. */\n        /* 5. If decoded outputs is not empty, queue a task on the control\n         * thread event loop to run the Output VideoData algorithm with\n         * decoded outputs. */\n        if (decodedOutputs) {\n          self._outputVideoFrames(decodedOutputs);\n        }\n      })\n      .catch(this._error);\n  }\n\n  private _outputVideoFrames(frames: LibAVJS.Frame[]) {\n    const libav = this._libav;\n\n    for (const frame of frames) {\n      // 1. format\n      let format: vf.VideoPixelFormat;\n      switch (frame.format) {\n        case libav.AV_PIX_FMT_YUV420P:\n          format = 'I420';\n          break;\n\n        case libav.AV_PIX_FMT_YUVA420P:\n          format = 'I420A';\n          break;\n\n        case libav.AV_PIX_FMT_YUV422P:\n          format = 'I422';\n          break;\n\n        case libav.AV_PIX_FMT_YUV444P:\n          format = 'I444';\n          break;\n\n        case libav.AV_PIX_FMT_NV12:\n          format = 'NV12';\n          break;\n\n        case libav.AV_PIX_FMT_RGBA:\n          format = 'RGBA';\n          break;\n\n        case libav.AV_PIX_FMT_BGRA:\n          format = 'BGRA';\n          break;\n\n        default:\n          throw new DOMException('Unsupported libav format!', 'EncodingError');\n      }\n\n      // 2. width and height\n      const codedWidth = frame.width;\n      const codedHeight = frame.height;\n\n      // Check for non-square pixels\n      let displayWidth = codedWidth;\n      let displayHeight = codedHeight;\n      if (frame.sample_aspect_ratio[0]) {\n        const sar = frame.sample_aspect_ratio;\n        if (sar[0] > sar[1]) {\n          displayWidth = ~~((codedWidth * sar[0]) / sar[1]);\n        } else {\n          displayHeight = ~~((codedHeight * sar[1]) / sar[0]);\n        }\n      }\n\n      // 3. timestamp\n      const timestamp = (frame.ptshi * 0x100000000 + frame.pts) * 1000;\n\n      // 4. data\n      let raw: Uint8Array;\n      {\n        let size = 0;\n        const planes = vf.numPlanes(format);\n        const sbs = [];\n        const hssfs = [];\n        const vssfs = [];\n        for (let i = 0; i < planes; i++) {\n          sbs.push(vf.sampleBytes(format, i));\n          hssfs.push(vf.horizontalSubSamplingFactor(format, i));\n          vssfs.push(vf.verticalSubSamplingFactor(format, i));\n        }\n        for (let i = 0; i < planes; i++) {\n          size += frame.width * frame.height * sbs[i] / hssfs[i]\n            / vssfs[i];\n        }\n        raw = new Uint8Array(size);\n        let off = 0;\n        for (let i = 0; i < planes; i++) {\n          const fd = frame.data[i];\n          for (let j = 0; j < frame.height / vssfs[i]; j++) {\n            const part = fd[j].subarray(0, frame.width / hssfs[i]);\n            raw.set(part, off);\n            off += part.length;\n          }\n        }\n      }\n\n      const data = new vf.VideoFrame(raw, {\n        format,\n        codedWidth,\n        codedHeight,\n        displayWidth,\n        displayHeight,\n        timestamp,\n      });\n\n      this._output(data);\n    }\n  }\n\n  flush(): Promise<void> {\n    const self = this;\n\n    const ret = this._p.then(async () => {\n      if (!self._c) {\n        return;\n      }\n\n      // Make sure any last data is flushed\n      const libav = self._libav;\n      const c = self._c;\n      const pkt = self._pkt;\n      const frame = self._frame;\n\n      let decodedOutputs: LibAVJS.Frame[] = null;\n\n      try {\n        decodedOutputs = await libav.ff_decode_multi(c, pkt, frame, [], true);\n      } catch (ex) {\n        self._p = self._p.then(() => {\n          self._closeVideoDecoder(ex);\n        });\n      }\n\n      if (decodedOutputs) {\n        self._outputVideoFrames(decodedOutputs);\n      }\n    });\n    this._p = ret;\n    return ret;\n  }\n\n  reset(): void {\n    this._resetVideoDecoder(new DOMException('Reset', 'AbortError'));\n  }\n\n  close(): void {\n    this._closeVideoDecoder(new DOMException('Close', 'AbortError'));\n  }\n\n  static async isConfigSupported(config: VideoDecoderConfig): Promise<VideoDecoderSupport> {\n    const dec = libavs.decoder(config.codec);\n    let supported = false;\n    if (dec) {\n      const libav = await libavs.get();\n      try {\n        const [, c, pkt, frame] = await libav.ff_init_decoder(dec.codec);\n        await libav.ff_free_decoder(c, pkt, frame);\n        supported = true;\n      } catch (ex) {}\n      await libavs.free(libav);\n    }\n\n    return {\n      supported,\n      config: misc.cloneConfig(config, ['codec', 'codedWidth', 'codedHeight']),\n    };\n  }\n}\n\nexport interface VideoDecoderInit {\n  output: VideoFrameOutputCallback;\n  error: misc.WebCodecsErrorCallback;\n}\n\nexport type VideoFrameOutputCallback = (output: vf.VideoFrame) => void;\n\nexport interface VideoDecoderConfig {\n  codec: string | { libavjs: libavs.LibAVJSCodec };\n  description: Uint8Array;\n  codedWidth?: number;\n  codedHeight?: number;\n  displayAspectWidth?: number;\n  displayAspectHeight?: number;\n  colorSpace?: vf.VideoColorSpaceInit;\n  hardwareAcceleration?: string; // Ignored\n  optimizeForLatency?: boolean;\n}\n\nexport interface VideoDecoderSupport {\n  supported: boolean;\n  config: VideoDecoderConfig;\n}\n","// @ts-nocheck\n\n/*\n * This file is part of the libav.js WebCodecs Polyfill implementation. The\n * interface implemented is derived from the W3C standard. No attribution is\n * required when using this library.\n *\n * Copyright (c) 2021 Yahweasel\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nimport type * as LibAVJS from '../libav.types';\nimport * as vf from './video-frame';\n\ndeclare let LibAV: LibAVJS.LibAVWrapper;\n\n/* A non-threaded libav.js instance for scaling. This is an any because the\n * type definitions only expose the async versions, but this API requires the\n * _sync methods. */\nlet scalerSync: any = null;\n\n// A synchronous libav.js instance for scaling.\nlet scalerAsync: LibAVJS.LibAV = null;\n\n// The original drawImage\nconst origDrawImage: any = null;\n\n// The original createImageBitmap\nlet origCreateImageBitmap: any = null;\n\n/**\n * Load rendering capability.\n * @param libavOptions  Options to use while loading libav, only asynchronous\n * @param polyfill  Set to polyfill CanvasRenderingContext2D.drawImage\n */\nexport async function load(libavOptions: any, polyfill: boolean) {\n  // Get our scalers\n  scalerSync = await LibAV.LibAV({ noworker: true });\n  scalerAsync = await LibAV.LibAV(libavOptions);\n\n  // Polyfill createImageBitmap\n  origCreateImageBitmap = global.createImageBitmap;\n  if (polyfill) {\n    (<any>global).createImageBitmap = createImageBitmap;\n  }\n}\n\n/**\n * Create an ImageBitmap from this drawable, asynchronously. NOTE:\n * Sub-rectangles are not implemented for VideoFrames, so only options is\n * available, and there, only scaling is available.\n * @param image  VideoFrame (or anything else) to draw\n * @param options  Other options\n */\nexport function createImageBitmap(\n  image: vf.VideoFrame,\n  opts: {\n    resizeWidth?: number;\n    resizeHeight?: number;\n  } = {},\n): Promise<ImageBitmap> {\n  if (!(image instanceof vf.VideoFrame)) {\n    // Just use the original\n    return origCreateImageBitmap.apply(global, arguments);\n  }\n\n  // Convert the format to libav.js\n  let format: number = scalerAsync.AV_PIX_FMT_RGBA;\n  switch (image.format) {\n    case 'I420':\n      format = scalerAsync.AV_PIX_FMT_YUV420P;\n      break;\n\n    case 'I420A':\n      format = scalerAsync.AV_PIX_FMT_YUVA420P;\n      break;\n\n    case 'I422':\n      format = scalerAsync.AV_PIX_FMT_YUV422P;\n      break;\n\n    case 'I444':\n      format = scalerAsync.AV_PIX_FMT_YUV444P;\n      break;\n\n    case 'NV12':\n      format = scalerAsync.AV_PIX_FMT_NV12;\n      break;\n\n    case 'RGBA':\n    case 'RGBX':\n      format = scalerAsync.AV_PIX_FMT_RGBA;\n      break;\n\n    case 'BGRA':\n    case 'BGRX':\n      format = scalerAsync.AV_PIX_FMT_BGRA;\n      break;\n  }\n\n  // Normalize arguments\n  const dWidth = typeof opts.resizeWidth === 'number' ? opts.resizeWidth : image.displayWidth;\n  const dHeight = typeof opts.resizeHeight === 'number' ? opts.resizeHeight : image.displayHeight;\n\n  // Convert the frame\n  const frameData = new ImageData(dWidth, dHeight);\n\n  return (async () => {\n    const [sctx, inFrame, outFrame] = await Promise.all([\n      scalerAsync.sws_getContext(\n        image.codedWidth,\n        image.codedHeight,\n        format,\n        dWidth,\n        dHeight,\n        scalerAsync.AV_PIX_FMT_RGBA,\n        2,\n        0,\n        0,\n        0,\n      ),\n      scalerAsync.av_frame_alloc(),\n      scalerAsync.av_frame_alloc(),\n    ]);\n\n    // Convert the data (FIXME: duplication)\n    const rawU8 = image._libavGetData();\n    let rawIdx = 0;\n    const raw: Uint8Array[][] = [];\n    const planes = vf.numPlanes(image.format);\n    for (let p = 0; p < planes; p++) {\n      const plane: Uint8Array[] = [];\n      raw.push(plane);\n      const sb = vf.sampleBytes(image.format, p);\n      const hssf = vf.horizontalSubSamplingFactor(image.format, p);\n      const vssf = vf.verticalSubSamplingFactor(image.format, p);\n      const w = ~~((image.codedWidth * sb) / hssf);\n      const h = ~~(image.codedHeight / vssf);\n      for (let y = 0; y < h; y++) {\n        plane.push(rawU8.subarray(rawIdx, rawIdx + w));\n        rawIdx += w;\n      }\n    }\n\n    const [, , frame] = await Promise.all([\n      // Copy it in\n      scalerAsync.ff_copyin_frame(inFrame, {\n        data: raw,\n        format,\n        width: image.codedWidth,\n        height: image.codedHeight,\n      }),\n\n      // Rescale\n      scalerAsync.sws_scale_frame(sctx, outFrame, inFrame),\n\n      // Get the data back out again\n      scalerAsync.ff_copyout_frame(outFrame),\n\n      // And clean up\n      scalerAsync.av_frame_free_js(outFrame),\n      scalerAsync.av_frame_free_js(inFrame),\n      scalerAsync.sws_freeContext(sctx),\n    ]);\n\n    // Transfer all the data\n    let idx = 0;\n    for (let i = 0; i < frame.data.length; i++) {\n      const plane = frame.data[i];\n      for (let y = 0; y < plane.length; y++) {\n        const row = plane[y];\n        frameData.data.set(row, idx);\n        idx += row.length;\n      }\n    }\n\n    // And make the ImageBitmap\n    return await origCreateImageBitmap(frameData);\n  })();\n}\n","/*\n * This file is part of the libav.js WebCodecs Polyfill implementation. The\n * interface implemented is derived from the W3C standard. No attribution is\n * required when using this library.\n *\n * Copyright (c) 2021 Yahweasel\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nimport type * as eac from './encoded-audio-chunk';\nimport * as evc from './encoded-video-chunk';\nimport * as vf from './video-frame';\nimport * as vdec from './video-decoder';\n\n/**\n * A VideoDecoder environment.\n */\nexport interface VideoDecoderEnvironment {\n  VideoDecoder: typeof vdec.VideoDecoder;\n  EncodedVideoChunk: typeof evc.EncodedVideoChunk;\n  VideoFrame: typeof vf.VideoFrame;\n}\n\n/**\n * Error thrown to indicate a configuration is unsupported.\n */\nexport class UnsupportedException extends Error {\n  constructor() {\n    super('The requested configuration is not supported');\n  }\n}\n\n/**\n * Get an VideoDecoder environment that supports this configuration. Throws an\n * UnsupportedException if no environment supports the configuration.\n * @param config  Video decoder configuration\n */\nexport async function getVideoDecoder(\n  config: vdec.VideoDecoderConfig,\n): Promise<VideoDecoderEnvironment> {\n  try {\n    if (\n      typeof (<any>global).VideoDecoder !== 'undefined'\n      && (await (<any>global).VideoDecoder.isConfigSupported(config)).supported\n    ) {\n      return {\n        VideoDecoder: (<any>global).VideoDecoder,\n        EncodedVideoChunk: (<any>global).EncodedVideoChunk,\n        VideoFrame: (<any>global).VideoFrame,\n      };\n    }\n  } catch (ex) {}\n\n  if ((await vdec.VideoDecoder.isConfigSupported(config)).supported) {\n    return {\n      VideoDecoder: vdec.VideoDecoder,\n      EncodedVideoChunk: evc.EncodedVideoChunk,\n      VideoFrame: vf.VideoFrame,\n    };\n  }\n\n  throw new UnsupportedException();\n}\n","import { createWorkerInterface } from '../../util/createPostMessageInterface';\nimport type { CancellableCallback } from '../../util/PostMessageConnector';\nimport { MP4Demuxer } from './MP4Demuxer';\nimport * as LibAVWebCodecs from './polyfill';\n\nlet decoder: any;\nlet demuxer: any;\nlet onDestroy: VoidFunction | undefined;\n\nlet isLoaded = false;\n\nasync function init(\n  url: string,\n  maxFrames: number,\n  workerIndex: number,\n  workersTotal: number,\n  onFrame: CancellableCallback,\n) {\n  const hasWebCodecs = 'VideoDecoder' in globalThis;\n  if (!hasWebCodecs) {\n    await loadLibAV();\n  }\n\n  const decodedFrames = new Set<number>();\n\n  // @ts-ignore\n  decoder = new VideoDecoder({\n    async output(frame: any) {\n      const time = frame.timestamp / 1e6;\n      const seconds = Math.floor(time);\n      // Only render whole second frames\n      if (!decodedFrames.has(seconds)) {\n        const bitmap = await createImageBitmap(frame);\n        decodedFrames.add(seconds);\n        onFrame(seconds, bitmap);\n      }\n      frame.close();\n    },\n    error(e: any) {\n      // eslint-disable-next-line no-console\n      console.error('[Video Preview] error', e);\n    },\n  });\n\n  demuxer = new MP4Demuxer(url, {\n    stepOffset: workerIndex,\n    stepMultiplier: workersTotal,\n    isPolyfill: !hasWebCodecs,\n    maxFrames,\n    onConfig(config) {\n      decoder?.configure(config);\n    },\n    onChunk(chunk) {\n      if (decoder?.state !== 'configured') return;\n      decoder?.decode(chunk);\n    },\n  });\n\n  return new Promise<void>((resolve) => {\n    onDestroy = resolve;\n  });\n}\n\nfunction destroy() {\n  try {\n    decoder?.close();\n    demuxer?.close();\n  } catch {\n    // Ignore\n  }\n  decoder = undefined;\n  demuxer = undefined;\n  onDestroy?.();\n}\n\nasync function loadLibAV() {\n  if (isLoaded) return;\n  // @ts-ignore\n  await import('script-loader!./libav-3.10.5.1.2-webcodecs');\n  await LibAVWebCodecs.load({\n    polyfill: true,\n    libavOptions: { noworker: true, nosimd: true },\n  });\n  isLoaded = true;\n}\n\nconst api = {\n  'video-preview:init': init,\n  'video-preview:destroy': destroy,\n};\n\ncreateWorkerInterface(api);\n\nexport type VideoPreviewApi = typeof api;\n","// @ts-nocheck\n\n/*\n * This file is part of the libav.js WebCodecs Polyfill implementation. The\n * interface implemented is derived from the W3C standard. No attribution is\n * required when using this library.\n *\n * Copyright (c) 2021 Yahweasel\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nimport type * as LibAVJS from '../libav.types';\nimport * as eac from './encoded-audio-chunk';\n\nimport * as evc from './encoded-video-chunk';\nimport * as vf from './video-frame';\nimport * as vdec from './video-decoder';\n\nimport * as rendering from './rendering';\n\nimport * as config from './config';\nimport * as libav from './libav';\nimport type * as misc from './misc';\n\ndeclare let LibAV: LibAVJS.LibAVWrapper;\n\n/**\n * Load LibAV-WebCodecs-Polyfill.\n */\nexport async function load(\n  options: {\n    polyfill?: boolean;\n    libavOptions?: any;\n  } = {},\n) {\n  // Set up libavOptions\n  const libavOptions: any = {};\n  if (options.libavOptions) {\n    Object.assign(libavOptions, options.libavOptions);\n  }\n\n  // And load the libav handler\n  libav.setLibAVOptions(libavOptions);\n  await libav.load();\n\n  if (options.polyfill) {\n    globalThis.VideoDecoder = vdec.VideoDecoder;\n    globalThis.VideoFrame = vf.VideoFrame;\n    globalThis.EncodedVideoChunk = evc.EncodedVideoChunk;\n  }\n\n  await rendering.load(libavOptions, !!options.polyfill);\n}\n\n// EncodedVideoChunk\nexport type EncodedVideoChunk = evc.EncodedVideoChunk;\nexport const EncodedVideoChunk = evc.EncodedVideoChunk;\nexport type EncodedVideoChunkInit = evc.EncodedVideoChunkInit;\n\n// VideoFrame\nexport type VideoFrame = vf.VideoFrame;\nexport const VideoFrame = vf.VideoFrame;\nexport type VideoFrameInit = vf.VideoFrameInit;\nexport type VideoFrameBufferInit = vf.VideoFrameBufferInit;\nexport type VideoPixelFormat = vf.VideoPixelFormat;\nexport type PlaneLayout = vf.PlaneLayout;\nexport type VideoFrameCopyToOptions = vf.VideoFrameCopyToOptions;\n\n// VideoDecoder\nexport type VideoDecoder = vdec.VideoDecoder;\nexport const VideoDecoder = vdec.VideoDecoder;\nexport type VideoDecoderInit = vdec.VideoDecoderInit;\nexport type VideoFrameOutputCallback = vdec.VideoFrameOutputCallback;\nexport type VideoDecoderConfig = vdec.VideoDecoderConfig;\nexport type VideoDecoderSupport = vdec.VideoDecoderSupport;\n\n// Rendering\nexport const createImageBitmap = rendering.createImageBitmap;\n\n// Misc\nexport type CodecState = misc.CodecState;\nexport type WebCodecsErrorcallback = misc.WebCodecsErrorCallback;\n\n// Configurations/environments\nexport type AudioDecoderEnvironment = config.AudioDecoderEnvironment;\nexport type VideoDecoderEnvironment = config.VideoDecoderEnvironment;\nexport type UnsupportedException = config.UnsupportedException;\nexport const UnsupportedException = config.UnsupportedException;\nexport const getVideoDecoder = config.getVideoDecoder;\n","module.exports = \"var Module = typeof Module !== \\\"undefined\\\" ? Module : {};\\nvar moduleOverrides = {};\\nvar key;\\nfor (key in Module) {\\n  if (Module.hasOwnProperty(key)) {\\n    moduleOverrides[key] = Module[key];\\n  }\\n}\\nvar arguments_ = [];\\nvar thisProgram = \\\"./this.program\\\";\\nvar quit_ = function (status, toThrow) {\\n  throw toThrow;\\n};\\nvar ENVIRONMENT_IS_WEB = false;\\nvar ENVIRONMENT_IS_WORKER = false;\\nvar ENVIRONMENT_IS_NODE = false;\\nvar ENVIRONMENT_IS_SHELL = false;\\nENVIRONMENT_IS_WEB = typeof window === \\\"object\\\";\\nENVIRONMENT_IS_WORKER = typeof importScripts === \\\"function\\\";\\nENVIRONMENT_IS_NODE = typeof process === \\\"object\\\" && typeof process.versions === \\\"object\\\" && typeof process.versions.node === \\\"string\\\";\\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\\nvar scriptDirectory = \\\"\\\";\\nfunction locateFile(path) {\\n  if (Module[\\\"locateFile\\\"]) {\\n    return Module[\\\"locateFile\\\"](path, scriptDirectory);\\n  }\\n  return scriptDirectory + path;\\n}\\nvar read_, readAsync, readBinary, setWindowTitle;\\nvar nodeFS;\\nvar nodePath;\\nif (ENVIRONMENT_IS_NODE) {\\n  if (ENVIRONMENT_IS_WORKER) {\\n    scriptDirectory = require(\\\"path\\\").dirname(scriptDirectory) + \\\"/\\\";\\n  } else {\\n    scriptDirectory = __dirname + \\\"/\\\";\\n  }\\n  read_ = function shell_read(filename, binary) {\\n    if (!nodeFS) nodeFS = require(\\\"fs\\\");\\n    if (!nodePath) nodePath = require(\\\"path\\\");\\n    filename = nodePath[\\\"normalize\\\"](filename);\\n    return nodeFS[\\\"readFileSync\\\"](filename, binary ? null : \\\"utf8\\\");\\n  };\\n  readBinary = function readBinary(filename) {\\n    var ret = read_(filename, true);\\n    if (!ret.buffer) {\\n      ret = new Uint8Array(ret);\\n    }\\n    assert(ret.buffer);\\n    return ret;\\n  };\\n  if (process[\\\"argv\\\"].length > 1) {\\n    thisProgram = process[\\\"argv\\\"][1].replace(/\\\\\\\\/g, \\\"/\\\");\\n  }\\n  arguments_ = process[\\\"argv\\\"].slice(2);\\n  if (typeof module !== \\\"undefined\\\") {\\n    module[\\\"exports\\\"] = Module;\\n  }\\n  process[\\\"on\\\"](\\\"uncaughtException\\\", function (ex) {\\n    if (!(ex instanceof ExitStatus)) {\\n      throw ex;\\n    }\\n  });\\n  process[\\\"on\\\"](\\\"unhandledRejection\\\", abort);\\n  quit_ = function (status) {\\n    process[\\\"exit\\\"](status);\\n  };\\n  Module[\\\"inspect\\\"] = function () {\\n    return \\\"[Emscripten Module object]\\\";\\n  };\\n} else if (ENVIRONMENT_IS_SHELL) {\\n  if (typeof read != \\\"undefined\\\") {\\n    read_ = function shell_read(f) {\\n      return read(f);\\n    };\\n  }\\n  readBinary = function readBinary(f) {\\n    var data;\\n    if (typeof readbuffer === \\\"function\\\") {\\n      return new Uint8Array(readbuffer(f));\\n    }\\n    data = read(f, \\\"binary\\\");\\n    assert(typeof data === \\\"object\\\");\\n    return data;\\n  };\\n  if (typeof scriptArgs != \\\"undefined\\\") {\\n    arguments_ = scriptArgs;\\n  } else if (typeof arguments != \\\"undefined\\\") {\\n    arguments_ = arguments;\\n  }\\n  if (typeof quit === \\\"function\\\") {\\n    quit_ = function (status) {\\n      quit(status);\\n    };\\n  }\\n  if (typeof print !== \\\"undefined\\\") {\\n    if (typeof console === \\\"undefined\\\") console = {};\\n    console.log = print;\\n    console.warn = console.error = typeof printErr !== \\\"undefined\\\" ? printErr : print;\\n  }\\n} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\\n  if (ENVIRONMENT_IS_WORKER) {\\n    scriptDirectory = self.location.href;\\n  } else if (document.currentScript) {\\n    scriptDirectory = document.currentScript.src;\\n  }\\n  if (scriptDirectory.indexOf(\\\"blob:\\\") !== 0) {\\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\\\"/\\\") + 1);\\n  } else {\\n    scriptDirectory = \\\"\\\";\\n  }\\n  {\\n    read_ = function shell_read(url) {\\n      var xhr = new XMLHttpRequest();\\n      xhr.open(\\\"GET\\\", url, false);\\n      xhr.send(null);\\n      return xhr.responseText;\\n    };\\n    if (ENVIRONMENT_IS_WORKER) {\\n      readBinary = function readBinary(url) {\\n        var xhr = new XMLHttpRequest();\\n        xhr.open(\\\"GET\\\", url, false);\\n        xhr.responseType = \\\"arraybuffer\\\";\\n        xhr.send(null);\\n        return new Uint8Array(xhr.response);\\n      };\\n    }\\n    readAsync = function readAsync(url, onload, onerror) {\\n      var xhr = new XMLHttpRequest();\\n      xhr.open(\\\"GET\\\", url, true);\\n      xhr.responseType = \\\"arraybuffer\\\";\\n      xhr.onload = function xhr_onload() {\\n        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\\n          onload(xhr.response);\\n          return;\\n        }\\n        onerror();\\n      };\\n      xhr.onerror = onerror;\\n      xhr.send(null);\\n    };\\n  }\\n  setWindowTitle = function (title) {\\n    document.title = title;\\n  };\\n} else {}\\nvar out = Module[\\\"print\\\"] || console.log.bind(console);\\nvar err = Module[\\\"printErr\\\"] || console.warn.bind(console);\\nfor (key in moduleOverrides) {\\n  if (moduleOverrides.hasOwnProperty(key)) {\\n    Module[key] = moduleOverrides[key];\\n  }\\n}\\nmoduleOverrides = null;\\nif (Module[\\\"arguments\\\"]) arguments_ = Module[\\\"arguments\\\"];\\nif (Module[\\\"thisProgram\\\"]) thisProgram = Module[\\\"thisProgram\\\"];\\nif (Module[\\\"quit\\\"]) quit_ = Module[\\\"quit\\\"];\\nfunction dynamicAlloc(size) {\\n  var ret = HEAP32[DYNAMICTOP_PTR >> 2];\\n  var end = ret + size + 15 & -16;\\n  HEAP32[DYNAMICTOP_PTR >> 2] = end;\\n  return ret;\\n}\\nfunction getNativeTypeSize(type) {\\n  switch (type) {\\n    case \\\"i1\\\":\\n    case \\\"i8\\\":\\n      return 1;\\n    case \\\"i16\\\":\\n      return 2;\\n    case \\\"i32\\\":\\n      return 4;\\n    case \\\"i64\\\":\\n      return 8;\\n    case \\\"float\\\":\\n      return 4;\\n    case \\\"double\\\":\\n      return 8;\\n    default:\\n      {\\n        if (type[type.length - 1] === \\\"*\\\") {\\n          return 4;\\n        } else if (type[0] === \\\"i\\\") {\\n          var bits = Number(type.substr(1));\\n          assert(bits % 8 === 0, \\\"getNativeTypeSize invalid bits \\\" + bits + \\\", type \\\" + type);\\n          return bits / 8;\\n        } else {\\n          return 0;\\n        }\\n      }\\n  }\\n}\\nvar tempRet0 = 0;\\nvar setTempRet0 = function (value) {\\n  tempRet0 = value;\\n};\\nvar getTempRet0 = function () {\\n  return tempRet0;\\n};\\nvar wasmBinary;\\nif (Module[\\\"wasmBinary\\\"]) wasmBinary = Module[\\\"wasmBinary\\\"];\\nvar noExitRuntime;\\nif (Module[\\\"noExitRuntime\\\"]) noExitRuntime = Module[\\\"noExitRuntime\\\"];\\nif (typeof WebAssembly !== \\\"object\\\") {\\n  err(\\\"no native wasm support detected\\\");\\n}\\nfunction setValue(ptr, value, type, noSafe) {\\n  type = type || \\\"i8\\\";\\n  if (type.charAt(type.length - 1) === \\\"*\\\") type = \\\"i32\\\";\\n  switch (type) {\\n    case \\\"i1\\\":\\n      HEAP8[ptr >> 0] = value;\\n      break;\\n    case \\\"i8\\\":\\n      HEAP8[ptr >> 0] = value;\\n      break;\\n    case \\\"i16\\\":\\n      HEAP16[ptr >> 1] = value;\\n      break;\\n    case \\\"i32\\\":\\n      HEAP32[ptr >> 2] = value;\\n      break;\\n    case \\\"i64\\\":\\n      tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\\n      break;\\n    case \\\"float\\\":\\n      HEAPF32[ptr >> 2] = value;\\n      break;\\n    case \\\"double\\\":\\n      HEAPF64[ptr >> 3] = value;\\n      break;\\n    default:\\n      abort(\\\"invalid type for setValue: \\\" + type);\\n  }\\n}\\nvar wasmMemory;\\nvar wasmTable = new WebAssembly.Table({\\n  \\\"initial\\\": 522,\\n  \\\"maximum\\\": 522 + 0,\\n  \\\"element\\\": \\\"anyfunc\\\"\\n});\\nvar ABORT = false;\\nvar EXITSTATUS = 0;\\nfunction assert(condition, text) {\\n  if (!condition) {\\n    abort(\\\"Assertion failed: \\\" + text);\\n  }\\n}\\nfunction getCFunc(ident) {\\n  var func = Module[\\\"_\\\" + ident];\\n  assert(func, \\\"Cannot call unknown function \\\" + ident + \\\", make sure it is exported\\\");\\n  return func;\\n}\\nfunction ccall(ident, returnType, argTypes, args, opts) {\\n  var toC = {\\n    \\\"string\\\": function (str) {\\n      var ret = 0;\\n      if (str !== null && str !== undefined && str !== 0) {\\n        var len = (str.length << 2) + 1;\\n        ret = stackAlloc(len);\\n        stringToUTF8(str, ret, len);\\n      }\\n      return ret;\\n    },\\n    \\\"array\\\": function (arr) {\\n      var ret = stackAlloc(arr.length);\\n      writeArrayToMemory(arr, ret);\\n      return ret;\\n    }\\n  };\\n  function convertReturnValue(ret) {\\n    if (returnType === \\\"string\\\") return UTF8ToString(ret);\\n    if (returnType === \\\"boolean\\\") return Boolean(ret);\\n    return ret;\\n  }\\n  var func = getCFunc(ident);\\n  var cArgs = [];\\n  var stack = 0;\\n  if (args) {\\n    for (var i = 0; i < args.length; i++) {\\n      var converter = toC[argTypes[i]];\\n      if (converter) {\\n        if (stack === 0) stack = stackSave();\\n        cArgs[i] = converter(args[i]);\\n      } else {\\n        cArgs[i] = args[i];\\n      }\\n    }\\n  }\\n  var ret = func.apply(null, cArgs);\\n  ret = convertReturnValue(ret);\\n  if (stack !== 0) stackRestore(stack);\\n  return ret;\\n}\\nfunction cwrap(ident, returnType, argTypes, opts) {\\n  argTypes = argTypes || [];\\n  var numericArgs = argTypes.every(function (type) {\\n    return type === \\\"number\\\";\\n  });\\n  var numericRet = returnType !== \\\"string\\\";\\n  if (numericRet && numericArgs && !opts) {\\n    return getCFunc(ident);\\n  }\\n  return function () {\\n    return ccall(ident, returnType, argTypes, arguments, opts);\\n  };\\n}\\nvar ALLOC_NONE = 3;\\nfunction allocate(slab, types, allocator, ptr) {\\n  var zeroinit, size;\\n  if (typeof slab === \\\"number\\\") {\\n    zeroinit = true;\\n    size = slab;\\n  } else {\\n    zeroinit = false;\\n    size = slab.length;\\n  }\\n  var singleType = typeof types === \\\"string\\\" ? types : null;\\n  var ret;\\n  if (allocator == ALLOC_NONE) {\\n    ret = ptr;\\n  } else {\\n    ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\\n  }\\n  if (zeroinit) {\\n    var stop;\\n    ptr = ret;\\n    assert((ret & 3) == 0);\\n    stop = ret + (size & ~3);\\n    for (; ptr < stop; ptr += 4) {\\n      HEAP32[ptr >> 2] = 0;\\n    }\\n    stop = ret + size;\\n    while (ptr < stop) {\\n      HEAP8[ptr++ >> 0] = 0;\\n    }\\n    return ret;\\n  }\\n  if (singleType === \\\"i8\\\") {\\n    if (slab.subarray || slab.slice) {\\n      HEAPU8.set(slab, ret);\\n    } else {\\n      HEAPU8.set(new Uint8Array(slab), ret);\\n    }\\n    return ret;\\n  }\\n  var i = 0,\\n    type,\\n    typeSize,\\n    previousType;\\n  while (i < size) {\\n    var curr = slab[i];\\n    type = singleType || types[i];\\n    if (type === 0) {\\n      i++;\\n      continue;\\n    }\\n    if (type == \\\"i64\\\") type = \\\"i32\\\";\\n    setValue(ret + i, curr, type);\\n    if (previousType !== type) {\\n      typeSize = getNativeTypeSize(type);\\n      previousType = type;\\n    }\\n    i += typeSize;\\n  }\\n  return ret;\\n}\\nvar UTF8Decoder = typeof TextDecoder !== \\\"undefined\\\" ? new TextDecoder(\\\"utf8\\\") : undefined;\\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\\n  var endIdx = idx + maxBytesToRead;\\n  var endPtr = idx;\\n  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\\n  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\\n    return UTF8Decoder.decode(heap.subarray(idx, endPtr));\\n  } else {\\n    var str = \\\"\\\";\\n    while (idx < endPtr) {\\n      var u0 = heap[idx++];\\n      if (!(u0 & 128)) {\\n        str += String.fromCharCode(u0);\\n        continue;\\n      }\\n      var u1 = heap[idx++] & 63;\\n      if ((u0 & 224) == 192) {\\n        str += String.fromCharCode((u0 & 31) << 6 | u1);\\n        continue;\\n      }\\n      var u2 = heap[idx++] & 63;\\n      if ((u0 & 240) == 224) {\\n        u0 = (u0 & 15) << 12 | u1 << 6 | u2;\\n      } else {\\n        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\\n      }\\n      if (u0 < 65536) {\\n        str += String.fromCharCode(u0);\\n      } else {\\n        var ch = u0 - 65536;\\n        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\\n      }\\n    }\\n  }\\n  return str;\\n}\\nfunction UTF8ToString(ptr, maxBytesToRead) {\\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \\\"\\\";\\n}\\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\\n  if (!(maxBytesToWrite > 0)) return 0;\\n  var startIdx = outIdx;\\n  var endIdx = outIdx + maxBytesToWrite - 1;\\n  for (var i = 0; i < str.length; ++i) {\\n    var u = str.charCodeAt(i);\\n    if (u >= 55296 && u <= 57343) {\\n      var u1 = str.charCodeAt(++i);\\n      u = 65536 + ((u & 1023) << 10) | u1 & 1023;\\n    }\\n    if (u <= 127) {\\n      if (outIdx >= endIdx) break;\\n      heap[outIdx++] = u;\\n    } else if (u <= 2047) {\\n      if (outIdx + 1 >= endIdx) break;\\n      heap[outIdx++] = 192 | u >> 6;\\n      heap[outIdx++] = 128 | u & 63;\\n    } else if (u <= 65535) {\\n      if (outIdx + 2 >= endIdx) break;\\n      heap[outIdx++] = 224 | u >> 12;\\n      heap[outIdx++] = 128 | u >> 6 & 63;\\n      heap[outIdx++] = 128 | u & 63;\\n    } else {\\n      if (outIdx + 3 >= endIdx) break;\\n      heap[outIdx++] = 240 | u >> 18;\\n      heap[outIdx++] = 128 | u >> 12 & 63;\\n      heap[outIdx++] = 128 | u >> 6 & 63;\\n      heap[outIdx++] = 128 | u & 63;\\n    }\\n  }\\n  heap[outIdx] = 0;\\n  return outIdx - startIdx;\\n}\\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\\n  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\\n}\\nfunction lengthBytesUTF8(str) {\\n  var len = 0;\\n  for (var i = 0; i < str.length; ++i) {\\n    var u = str.charCodeAt(i);\\n    if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\\n    if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;\\n  }\\n  return len;\\n}\\nfunction writeArrayToMemory(array, buffer) {\\n  HEAP8.set(array, buffer);\\n}\\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\\n  for (var i = 0; i < str.length; ++i) {\\n    HEAP8[buffer++ >> 0] = str.charCodeAt(i);\\n  }\\n  if (!dontAddNull) HEAP8[buffer >> 0] = 0;\\n}\\nvar WASM_PAGE_SIZE = 65536;\\nfunction alignUp(x, multiple) {\\n  if (x % multiple > 0) {\\n    x += multiple - x % multiple;\\n  }\\n  return x;\\n}\\nvar buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\\nfunction updateGlobalBufferAndViews(buf) {\\n  buffer = buf;\\n  Module[\\\"HEAP8\\\"] = HEAP8 = new Int8Array(buf);\\n  Module[\\\"HEAP16\\\"] = HEAP16 = new Int16Array(buf);\\n  Module[\\\"HEAP32\\\"] = HEAP32 = new Int32Array(buf);\\n  Module[\\\"HEAPU8\\\"] = HEAPU8 = new Uint8Array(buf);\\n  Module[\\\"HEAPU16\\\"] = HEAPU16 = new Uint16Array(buf);\\n  Module[\\\"HEAPU32\\\"] = HEAPU32 = new Uint32Array(buf);\\n  Module[\\\"HEAPF32\\\"] = HEAPF32 = new Float32Array(buf);\\n  Module[\\\"HEAPF64\\\"] = HEAPF64 = new Float64Array(buf);\\n}\\nvar DYNAMIC_BASE = 5275232,\\n  DYNAMICTOP_PTR = 32192;\\nvar INITIAL_INITIAL_MEMORY = Module[\\\"INITIAL_MEMORY\\\"] || 16777216;\\nif (Module[\\\"wasmMemory\\\"]) {\\n  wasmMemory = Module[\\\"wasmMemory\\\"];\\n} else {\\n  wasmMemory = new WebAssembly.Memory({\\n    \\\"initial\\\": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE,\\n    \\\"maximum\\\": 2147483648 / WASM_PAGE_SIZE\\n  });\\n}\\nif (wasmMemory) {\\n  buffer = wasmMemory.buffer;\\n}\\nINITIAL_INITIAL_MEMORY = buffer.byteLength;\\nupdateGlobalBufferAndViews(buffer);\\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\\nfunction callRuntimeCallbacks(callbacks) {\\n  while (callbacks.length > 0) {\\n    var callback = callbacks.shift();\\n    if (typeof callback == \\\"function\\\") {\\n      callback(Module);\\n      continue;\\n    }\\n    var func = callback.func;\\n    if (typeof func === \\\"number\\\") {\\n      if (callback.arg === undefined) {\\n        Module[\\\"dynCall_v\\\"](func);\\n      } else {\\n        Module[\\\"dynCall_vi\\\"](func, callback.arg);\\n      }\\n    } else {\\n      func(callback.arg === undefined ? null : callback.arg);\\n    }\\n  }\\n}\\nvar __ATPRERUN__ = [];\\nvar __ATINIT__ = [];\\nvar __ATMAIN__ = [];\\nvar __ATPOSTRUN__ = [];\\nvar runtimeInitialized = false;\\nfunction preRun() {\\n  if (Module[\\\"preRun\\\"]) {\\n    if (typeof Module[\\\"preRun\\\"] == \\\"function\\\") Module[\\\"preRun\\\"] = [Module[\\\"preRun\\\"]];\\n    while (Module[\\\"preRun\\\"].length) {\\n      addOnPreRun(Module[\\\"preRun\\\"].shift());\\n    }\\n  }\\n  callRuntimeCallbacks(__ATPRERUN__);\\n}\\nfunction initRuntime() {\\n  runtimeInitialized = true;\\n  if (!Module[\\\"noFSInit\\\"] && !FS.init.initialized) FS.init();\\n  TTY.init();\\n  callRuntimeCallbacks(__ATINIT__);\\n}\\nfunction preMain() {\\n  FS.ignorePermissions = false;\\n  callRuntimeCallbacks(__ATMAIN__);\\n}\\nfunction postRun() {\\n  if (Module[\\\"postRun\\\"]) {\\n    if (typeof Module[\\\"postRun\\\"] == \\\"function\\\") Module[\\\"postRun\\\"] = [Module[\\\"postRun\\\"]];\\n    while (Module[\\\"postRun\\\"].length) {\\n      addOnPostRun(Module[\\\"postRun\\\"].shift());\\n    }\\n  }\\n  callRuntimeCallbacks(__ATPOSTRUN__);\\n}\\nfunction addOnPreRun(cb) {\\n  __ATPRERUN__.unshift(cb);\\n}\\nfunction addOnPostRun(cb) {\\n  __ATPOSTRUN__.unshift(cb);\\n}\\nvar Math_abs = Math.abs;\\nvar Math_ceil = Math.ceil;\\nvar Math_floor = Math.floor;\\nvar Math_min = Math.min;\\nvar runDependencies = 0;\\nvar runDependencyWatcher = null;\\nvar dependenciesFulfilled = null;\\nfunction getUniqueRunDependency(id) {\\n  return id;\\n}\\nfunction addRunDependency(id) {\\n  runDependencies++;\\n  if (Module[\\\"monitorRunDependencies\\\"]) {\\n    Module[\\\"monitorRunDependencies\\\"](runDependencies);\\n  }\\n}\\nfunction removeRunDependency(id) {\\n  runDependencies--;\\n  if (Module[\\\"monitorRunDependencies\\\"]) {\\n    Module[\\\"monitorRunDependencies\\\"](runDependencies);\\n  }\\n  if (runDependencies == 0) {\\n    if (runDependencyWatcher !== null) {\\n      clearInterval(runDependencyWatcher);\\n      runDependencyWatcher = null;\\n    }\\n    if (dependenciesFulfilled) {\\n      var callback = dependenciesFulfilled;\\n      dependenciesFulfilled = null;\\n      callback();\\n    }\\n  }\\n}\\nModule[\\\"preloadedImages\\\"] = {};\\nModule[\\\"preloadedAudios\\\"] = {};\\nfunction abort(what) {\\n  if (Module[\\\"onAbort\\\"]) {\\n    Module[\\\"onAbort\\\"](what);\\n  }\\n  what += \\\"\\\";\\n  out(what);\\n  err(what);\\n  ABORT = true;\\n  EXITSTATUS = 1;\\n  what = \\\"abort(\\\" + what + \\\"). Build with -s ASSERTIONS=1 for more info.\\\";\\n  throw new WebAssembly.RuntimeError(what);\\n}\\nfunction hasPrefix(str, prefix) {\\n  return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;\\n}\\nvar dataURIPrefix = \\\"data:application/octet-stream;base64,\\\";\\nfunction isDataURI(filename) {\\n  return hasPrefix(filename, dataURIPrefix);\\n}\\nvar fileURIPrefix = \\\"file://\\\";\\nfunction isFileURI(filename) {\\n  return hasPrefix(filename, fileURIPrefix);\\n}\\nvar wasmBinaryFile = \\\"rlottie-wasm.wasm\\\";\\nif (!isDataURI(wasmBinaryFile)) {\\n  wasmBinaryFile = locateFile(wasmBinaryFile);\\n}\\nfunction getBinary() {\\n  try {\\n    if (wasmBinary) {\\n      return new Uint8Array(wasmBinary);\\n    }\\n    if (readBinary) {\\n      return readBinary(wasmBinaryFile);\\n    } else {\\n      throw \\\"both async and sync fetching of the wasm failed\\\";\\n    }\\n  } catch (err) {\\n    abort(err);\\n  }\\n}\\nfunction getBinaryPromise() {\\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === \\\"function\\\" && !isFileURI(wasmBinaryFile)) {\\n    return fetch(wasmBinaryFile, {\\n      credentials: \\\"same-origin\\\"\\n    }).then(function (response) {\\n      if (!response[\\\"ok\\\"]) {\\n        throw \\\"failed to load wasm binary file at '\\\" + wasmBinaryFile + \\\"'\\\";\\n      }\\n      return response[\\\"arrayBuffer\\\"]();\\n    }).catch(function () {\\n      return getBinary();\\n    });\\n  }\\n  return new Promise(function (resolve, reject) {\\n    resolve(getBinary());\\n  });\\n}\\nfunction createWasm() {\\n  var info = {\\n    \\\"a\\\": asmLibraryArg\\n  };\\n  function receiveInstance(instance, module) {\\n    var exports = instance.exports;\\n    Module[\\\"asm\\\"] = exports;\\n    removeRunDependency(\\\"wasm-instantiate\\\");\\n  }\\n  addRunDependency(\\\"wasm-instantiate\\\");\\n  function receiveInstantiatedSource(output) {\\n    receiveInstance(output[\\\"instance\\\"]);\\n  }\\n  function instantiateArrayBuffer(receiver) {\\n    return getBinaryPromise().then(function (binary) {\\n      return WebAssembly.instantiate(binary, info);\\n    }).then(receiver, function (reason) {\\n      err(\\\"failed to asynchronously prepare wasm: \\\" + reason);\\n      abort(reason);\\n    });\\n  }\\n  function instantiateAsync() {\\n    if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \\\"function\\\" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === \\\"function\\\") {\\n      fetch(wasmBinaryFile, {\\n        credentials: \\\"same-origin\\\"\\n      }).then(function (response) {\\n        var result = WebAssembly.instantiateStreaming(response, info);\\n        return result.then(receiveInstantiatedSource, function (reason) {\\n          err(\\\"wasm streaming compile failed: \\\" + reason);\\n          err(\\\"falling back to ArrayBuffer instantiation\\\");\\n          instantiateArrayBuffer(receiveInstantiatedSource);\\n        });\\n      });\\n    } else {\\n      return instantiateArrayBuffer(receiveInstantiatedSource);\\n    }\\n  }\\n  if (Module[\\\"instantiateWasm\\\"]) {\\n    try {\\n      var exports = Module[\\\"instantiateWasm\\\"](info, receiveInstance);\\n      return exports;\\n    } catch (e) {\\n      err(\\\"Module.instantiateWasm callback failed with error: \\\" + e);\\n      return false;\\n    }\\n  }\\n  instantiateAsync();\\n  return {};\\n}\\nvar tempDouble;\\nvar tempI64;\\n__ATINIT__.push({\\n  func: function () {\\n    ___wasm_call_ctors();\\n  }\\n});\\nfunction demangle(func) {\\n  return func;\\n}\\nfunction demangleAll(text) {\\n  var regex = /\\\\b_Z[\\\\w\\\\d_]+/g;\\n  return text.replace(regex, function (x) {\\n    var y = demangle(x);\\n    return x === y ? x : y + \\\" [\\\" + x + \\\"]\\\";\\n  });\\n}\\nfunction jsStackTrace() {\\n  var err = new Error();\\n  if (!err.stack) {\\n    try {\\n      throw new Error();\\n    } catch (e) {\\n      err = e;\\n    }\\n    if (!err.stack) {\\n      return \\\"(no stack trace available)\\\";\\n    }\\n  }\\n  return err.stack.toString();\\n}\\nfunction stackTrace() {\\n  var js = jsStackTrace();\\n  if (Module[\\\"extraStackTrace\\\"]) js += \\\"\\\\n\\\" + Module[\\\"extraStackTrace\\\"]();\\n  return demangleAll(js);\\n}\\nfunction __ZN7VRegionC1ERK5VRect() {\\n  err(\\\"missing function: _ZN7VRegionC1ERK5VRect\\\");\\n  abort(-1);\\n}\\nfunction __ZN7VRegionD1Ev() {\\n  err(\\\"missing function: _ZN7VRegionD1Ev\\\");\\n  abort(-1);\\n}\\nfunction __ZN7VRegionpLERK5VRect() {\\n  err(\\\"missing function: _ZN7VRegionpLERK5VRect\\\");\\n  abort(-1);\\n}\\nfunction __ZNK7VRegion12boundingRectEv() {\\n  err(\\\"missing function: _ZNK7VRegion12boundingRectEv\\\");\\n  abort(-1);\\n}\\nfunction ___assert_fail(condition, filename, line, func) {\\n  abort(\\\"Assertion failed: \\\" + UTF8ToString(condition) + \\\", at: \\\" + [filename ? UTF8ToString(filename) : \\\"unknown filename\\\", line, func ? UTF8ToString(func) : \\\"unknown function\\\"]);\\n}\\nfunction setErrNo(value) {\\n  HEAP32[___errno_location() >> 2] = value;\\n  return value;\\n}\\nfunction ___map_file(pathname, size) {\\n  setErrNo(63);\\n  return -1;\\n}\\nvar PATH = {\\n  splitPath: function (filename) {\\n    var splitPathRe = /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;\\n    return splitPathRe.exec(filename).slice(1);\\n  },\\n  normalizeArray: function (parts, allowAboveRoot) {\\n    var up = 0;\\n    for (var i = parts.length - 1; i >= 0; i--) {\\n      var last = parts[i];\\n      if (last === \\\".\\\") {\\n        parts.splice(i, 1);\\n      } else if (last === \\\"..\\\") {\\n        parts.splice(i, 1);\\n        up++;\\n      } else if (up) {\\n        parts.splice(i, 1);\\n        up--;\\n      }\\n    }\\n    if (allowAboveRoot) {\\n      for (; up; up--) {\\n        parts.unshift(\\\"..\\\");\\n      }\\n    }\\n    return parts;\\n  },\\n  normalize: function (path) {\\n    var isAbsolute = path.charAt(0) === \\\"/\\\",\\n      trailingSlash = path.substr(-1) === \\\"/\\\";\\n    path = PATH.normalizeArray(path.split(\\\"/\\\").filter(function (p) {\\n      return !!p;\\n    }), !isAbsolute).join(\\\"/\\\");\\n    if (!path && !isAbsolute) {\\n      path = \\\".\\\";\\n    }\\n    if (path && trailingSlash) {\\n      path += \\\"/\\\";\\n    }\\n    return (isAbsolute ? \\\"/\\\" : \\\"\\\") + path;\\n  },\\n  dirname: function (path) {\\n    var result = PATH.splitPath(path),\\n      root = result[0],\\n      dir = result[1];\\n    if (!root && !dir) {\\n      return \\\".\\\";\\n    }\\n    if (dir) {\\n      dir = dir.substr(0, dir.length - 1);\\n    }\\n    return root + dir;\\n  },\\n  basename: function (path) {\\n    if (path === \\\"/\\\") return \\\"/\\\";\\n    var lastSlash = path.lastIndexOf(\\\"/\\\");\\n    if (lastSlash === -1) return path;\\n    return path.substr(lastSlash + 1);\\n  },\\n  extname: function (path) {\\n    return PATH.splitPath(path)[3];\\n  },\\n  join: function () {\\n    var paths = Array.prototype.slice.call(arguments, 0);\\n    return PATH.normalize(paths.join(\\\"/\\\"));\\n  },\\n  join2: function (l, r) {\\n    return PATH.normalize(l + \\\"/\\\" + r);\\n  }\\n};\\nvar PATH_FS = {\\n  resolve: function () {\\n    var resolvedPath = \\\"\\\",\\n      resolvedAbsolute = false;\\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n      var path = i >= 0 ? arguments[i] : FS.cwd();\\n      if (typeof path !== \\\"string\\\") {\\n        throw new TypeError(\\\"Arguments to path.resolve must be strings\\\");\\n      } else if (!path) {\\n        return \\\"\\\";\\n      }\\n      resolvedPath = path + \\\"/\\\" + resolvedPath;\\n      resolvedAbsolute = path.charAt(0) === \\\"/\\\";\\n    }\\n    resolvedPath = PATH.normalizeArray(resolvedPath.split(\\\"/\\\").filter(function (p) {\\n      return !!p;\\n    }), !resolvedAbsolute).join(\\\"/\\\");\\n    return (resolvedAbsolute ? \\\"/\\\" : \\\"\\\") + resolvedPath || \\\".\\\";\\n  },\\n  relative: function (from, to) {\\n    from = PATH_FS.resolve(from).substr(1);\\n    to = PATH_FS.resolve(to).substr(1);\\n    function trim(arr) {\\n      var start = 0;\\n      for (; start < arr.length; start++) {\\n        if (arr[start] !== \\\"\\\") break;\\n      }\\n      var end = arr.length - 1;\\n      for (; end >= 0; end--) {\\n        if (arr[end] !== \\\"\\\") break;\\n      }\\n      if (start > end) return [];\\n      return arr.slice(start, end - start + 1);\\n    }\\n    var fromParts = trim(from.split(\\\"/\\\"));\\n    var toParts = trim(to.split(\\\"/\\\"));\\n    var length = Math.min(fromParts.length, toParts.length);\\n    var samePartsLength = length;\\n    for (var i = 0; i < length; i++) {\\n      if (fromParts[i] !== toParts[i]) {\\n        samePartsLength = i;\\n        break;\\n      }\\n    }\\n    var outputParts = [];\\n    for (var i = samePartsLength; i < fromParts.length; i++) {\\n      outputParts.push(\\\"..\\\");\\n    }\\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n    return outputParts.join(\\\"/\\\");\\n  }\\n};\\nvar TTY = {\\n  ttys: [],\\n  init: function () {},\\n  shutdown: function () {},\\n  register: function (dev, ops) {\\n    TTY.ttys[dev] = {\\n      input: [],\\n      output: [],\\n      ops: ops\\n    };\\n    FS.registerDevice(dev, TTY.stream_ops);\\n  },\\n  stream_ops: {\\n    open: function (stream) {\\n      var tty = TTY.ttys[stream.node.rdev];\\n      if (!tty) {\\n        throw new FS.ErrnoError(43);\\n      }\\n      stream.tty = tty;\\n      stream.seekable = false;\\n    },\\n    close: function (stream) {\\n      stream.tty.ops.flush(stream.tty);\\n    },\\n    flush: function (stream) {\\n      stream.tty.ops.flush(stream.tty);\\n    },\\n    read: function (stream, buffer, offset, length, pos) {\\n      if (!stream.tty || !stream.tty.ops.get_char) {\\n        throw new FS.ErrnoError(60);\\n      }\\n      var bytesRead = 0;\\n      for (var i = 0; i < length; i++) {\\n        var result;\\n        try {\\n          result = stream.tty.ops.get_char(stream.tty);\\n        } catch (e) {\\n          throw new FS.ErrnoError(29);\\n        }\\n        if (result === undefined && bytesRead === 0) {\\n          throw new FS.ErrnoError(6);\\n        }\\n        if (result === null || result === undefined) break;\\n        bytesRead++;\\n        buffer[offset + i] = result;\\n      }\\n      if (bytesRead) {\\n        stream.node.timestamp = Date.now();\\n      }\\n      return bytesRead;\\n    },\\n    write: function (stream, buffer, offset, length, pos) {\\n      if (!stream.tty || !stream.tty.ops.put_char) {\\n        throw new FS.ErrnoError(60);\\n      }\\n      try {\\n        for (var i = 0; i < length; i++) {\\n          stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\\n        }\\n      } catch (e) {\\n        throw new FS.ErrnoError(29);\\n      }\\n      if (length) {\\n        stream.node.timestamp = Date.now();\\n      }\\n      return i;\\n    }\\n  },\\n  default_tty_ops: {\\n    get_char: function (tty) {\\n      if (!tty.input.length) {\\n        var result = null;\\n        if (ENVIRONMENT_IS_NODE) {\\n          var BUFSIZE = 256;\\n          var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);\\n          var bytesRead = 0;\\n          try {\\n            bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);\\n          } catch (e) {\\n            if (e.toString().indexOf(\\\"EOF\\\") != -1) bytesRead = 0;else throw e;\\n          }\\n          if (bytesRead > 0) {\\n            result = buf.slice(0, bytesRead).toString(\\\"utf-8\\\");\\n          } else {\\n            result = null;\\n          }\\n        } else if (typeof window != \\\"undefined\\\" && typeof window.prompt == \\\"function\\\") {\\n          result = window.prompt(\\\"Input: \\\");\\n          if (result !== null) {\\n            result += \\\"\\\\n\\\";\\n          }\\n        } else if (typeof readline == \\\"function\\\") {\\n          result = readline();\\n          if (result !== null) {\\n            result += \\\"\\\\n\\\";\\n          }\\n        }\\n        if (!result) {\\n          return null;\\n        }\\n        tty.input = intArrayFromString(result, true);\\n      }\\n      return tty.input.shift();\\n    },\\n    put_char: function (tty, val) {\\n      if (val === null || val === 10) {\\n        out(UTF8ArrayToString(tty.output, 0));\\n        tty.output = [];\\n      } else {\\n        if (val != 0) tty.output.push(val);\\n      }\\n    },\\n    flush: function (tty) {\\n      if (tty.output && tty.output.length > 0) {\\n        out(UTF8ArrayToString(tty.output, 0));\\n        tty.output = [];\\n      }\\n    }\\n  },\\n  default_tty1_ops: {\\n    put_char: function (tty, val) {\\n      if (val === null || val === 10) {\\n        err(UTF8ArrayToString(tty.output, 0));\\n        tty.output = [];\\n      } else {\\n        if (val != 0) tty.output.push(val);\\n      }\\n    },\\n    flush: function (tty) {\\n      if (tty.output && tty.output.length > 0) {\\n        err(UTF8ArrayToString(tty.output, 0));\\n        tty.output = [];\\n      }\\n    }\\n  }\\n};\\nvar MEMFS = {\\n  ops_table: null,\\n  mount: function (mount) {\\n    return MEMFS.createNode(null, \\\"/\\\", 16384 | 511, 0);\\n  },\\n  createNode: function (parent, name, mode, dev) {\\n    if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    if (!MEMFS.ops_table) {\\n      MEMFS.ops_table = {\\n        dir: {\\n          node: {\\n            getattr: MEMFS.node_ops.getattr,\\n            setattr: MEMFS.node_ops.setattr,\\n            lookup: MEMFS.node_ops.lookup,\\n            mknod: MEMFS.node_ops.mknod,\\n            rename: MEMFS.node_ops.rename,\\n            unlink: MEMFS.node_ops.unlink,\\n            rmdir: MEMFS.node_ops.rmdir,\\n            readdir: MEMFS.node_ops.readdir,\\n            symlink: MEMFS.node_ops.symlink\\n          },\\n          stream: {\\n            llseek: MEMFS.stream_ops.llseek\\n          }\\n        },\\n        file: {\\n          node: {\\n            getattr: MEMFS.node_ops.getattr,\\n            setattr: MEMFS.node_ops.setattr\\n          },\\n          stream: {\\n            llseek: MEMFS.stream_ops.llseek,\\n            read: MEMFS.stream_ops.read,\\n            write: MEMFS.stream_ops.write,\\n            allocate: MEMFS.stream_ops.allocate,\\n            mmap: MEMFS.stream_ops.mmap,\\n            msync: MEMFS.stream_ops.msync\\n          }\\n        },\\n        link: {\\n          node: {\\n            getattr: MEMFS.node_ops.getattr,\\n            setattr: MEMFS.node_ops.setattr,\\n            readlink: MEMFS.node_ops.readlink\\n          },\\n          stream: {}\\n        },\\n        chrdev: {\\n          node: {\\n            getattr: MEMFS.node_ops.getattr,\\n            setattr: MEMFS.node_ops.setattr\\n          },\\n          stream: FS.chrdev_stream_ops\\n        }\\n      };\\n    }\\n    var node = FS.createNode(parent, name, mode, dev);\\n    if (FS.isDir(node.mode)) {\\n      node.node_ops = MEMFS.ops_table.dir.node;\\n      node.stream_ops = MEMFS.ops_table.dir.stream;\\n      node.contents = {};\\n    } else if (FS.isFile(node.mode)) {\\n      node.node_ops = MEMFS.ops_table.file.node;\\n      node.stream_ops = MEMFS.ops_table.file.stream;\\n      node.usedBytes = 0;\\n      node.contents = null;\\n    } else if (FS.isLink(node.mode)) {\\n      node.node_ops = MEMFS.ops_table.link.node;\\n      node.stream_ops = MEMFS.ops_table.link.stream;\\n    } else if (FS.isChrdev(node.mode)) {\\n      node.node_ops = MEMFS.ops_table.chrdev.node;\\n      node.stream_ops = MEMFS.ops_table.chrdev.stream;\\n    }\\n    node.timestamp = Date.now();\\n    if (parent) {\\n      parent.contents[name] = node;\\n    }\\n    return node;\\n  },\\n  getFileDataAsRegularArray: function (node) {\\n    if (node.contents && node.contents.subarray) {\\n      var arr = [];\\n      for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\\n      return arr;\\n    }\\n    return node.contents;\\n  },\\n  getFileDataAsTypedArray: function (node) {\\n    if (!node.contents) return new Uint8Array(0);\\n    if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\\n    return new Uint8Array(node.contents);\\n  },\\n  expandFileStorage: function (node, newCapacity) {\\n    var prevCapacity = node.contents ? node.contents.length : 0;\\n    if (prevCapacity >= newCapacity) return;\\n    var CAPACITY_DOUBLING_MAX = 1024 * 1024;\\n    newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\\n    if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\\n    var oldContents = node.contents;\\n    node.contents = new Uint8Array(newCapacity);\\n    if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\\n    return;\\n  },\\n  resizeFileStorage: function (node, newSize) {\\n    if (node.usedBytes == newSize) return;\\n    if (newSize == 0) {\\n      node.contents = null;\\n      node.usedBytes = 0;\\n      return;\\n    }\\n    if (!node.contents || node.contents.subarray) {\\n      var oldContents = node.contents;\\n      node.contents = new Uint8Array(newSize);\\n      if (oldContents) {\\n        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\\n      }\\n      node.usedBytes = newSize;\\n      return;\\n    }\\n    if (!node.contents) node.contents = [];\\n    if (node.contents.length > newSize) node.contents.length = newSize;else while (node.contents.length < newSize) node.contents.push(0);\\n    node.usedBytes = newSize;\\n  },\\n  node_ops: {\\n    getattr: function (node) {\\n      var attr = {};\\n      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\\n      attr.ino = node.id;\\n      attr.mode = node.mode;\\n      attr.nlink = 1;\\n      attr.uid = 0;\\n      attr.gid = 0;\\n      attr.rdev = node.rdev;\\n      if (FS.isDir(node.mode)) {\\n        attr.size = 4096;\\n      } else if (FS.isFile(node.mode)) {\\n        attr.size = node.usedBytes;\\n      } else if (FS.isLink(node.mode)) {\\n        attr.size = node.link.length;\\n      } else {\\n        attr.size = 0;\\n      }\\n      attr.atime = new Date(node.timestamp);\\n      attr.mtime = new Date(node.timestamp);\\n      attr.ctime = new Date(node.timestamp);\\n      attr.blksize = 4096;\\n      attr.blocks = Math.ceil(attr.size / attr.blksize);\\n      return attr;\\n    },\\n    setattr: function (node, attr) {\\n      if (attr.mode !== undefined) {\\n        node.mode = attr.mode;\\n      }\\n      if (attr.timestamp !== undefined) {\\n        node.timestamp = attr.timestamp;\\n      }\\n      if (attr.size !== undefined) {\\n        MEMFS.resizeFileStorage(node, attr.size);\\n      }\\n    },\\n    lookup: function (parent, name) {\\n      throw FS.genericErrors[44];\\n    },\\n    mknod: function (parent, name, mode, dev) {\\n      return MEMFS.createNode(parent, name, mode, dev);\\n    },\\n    rename: function (old_node, new_dir, new_name) {\\n      if (FS.isDir(old_node.mode)) {\\n        var new_node;\\n        try {\\n          new_node = FS.lookupNode(new_dir, new_name);\\n        } catch (e) {}\\n        if (new_node) {\\n          for (var i in new_node.contents) {\\n            throw new FS.ErrnoError(55);\\n          }\\n        }\\n      }\\n      delete old_node.parent.contents[old_node.name];\\n      old_node.name = new_name;\\n      new_dir.contents[new_name] = old_node;\\n      old_node.parent = new_dir;\\n    },\\n    unlink: function (parent, name) {\\n      delete parent.contents[name];\\n    },\\n    rmdir: function (parent, name) {\\n      var node = FS.lookupNode(parent, name);\\n      for (var i in node.contents) {\\n        throw new FS.ErrnoError(55);\\n      }\\n      delete parent.contents[name];\\n    },\\n    readdir: function (node) {\\n      var entries = [\\\".\\\", \\\"..\\\"];\\n      for (var key in node.contents) {\\n        if (!node.contents.hasOwnProperty(key)) {\\n          continue;\\n        }\\n        entries.push(key);\\n      }\\n      return entries;\\n    },\\n    symlink: function (parent, newname, oldpath) {\\n      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\\n      node.link = oldpath;\\n      return node;\\n    },\\n    readlink: function (node) {\\n      if (!FS.isLink(node.mode)) {\\n        throw new FS.ErrnoError(28);\\n      }\\n      return node.link;\\n    }\\n  },\\n  stream_ops: {\\n    read: function (stream, buffer, offset, length, position) {\\n      var contents = stream.node.contents;\\n      if (position >= stream.node.usedBytes) return 0;\\n      var size = Math.min(stream.node.usedBytes - position, length);\\n      if (size > 8 && contents.subarray) {\\n        buffer.set(contents.subarray(position, position + size), offset);\\n      } else {\\n        for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\\n      }\\n      return size;\\n    },\\n    write: function (stream, buffer, offset, length, position, canOwn) {\\n      if (buffer.buffer === HEAP8.buffer) {\\n        canOwn = false;\\n      }\\n      if (!length) return 0;\\n      var node = stream.node;\\n      node.timestamp = Date.now();\\n      if (buffer.subarray && (!node.contents || node.contents.subarray)) {\\n        if (canOwn) {\\n          node.contents = buffer.subarray(offset, offset + length);\\n          node.usedBytes = length;\\n          return length;\\n        } else if (node.usedBytes === 0 && position === 0) {\\n          node.contents = buffer.slice(offset, offset + length);\\n          node.usedBytes = length;\\n          return length;\\n        } else if (position + length <= node.usedBytes) {\\n          node.contents.set(buffer.subarray(offset, offset + length), position);\\n          return length;\\n        }\\n      }\\n      MEMFS.expandFileStorage(node, position + length);\\n      if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position);else {\\n        for (var i = 0; i < length; i++) {\\n          node.contents[position + i] = buffer[offset + i];\\n        }\\n      }\\n      node.usedBytes = Math.max(node.usedBytes, position + length);\\n      return length;\\n    },\\n    llseek: function (stream, offset, whence) {\\n      var position = offset;\\n      if (whence === 1) {\\n        position += stream.position;\\n      } else if (whence === 2) {\\n        if (FS.isFile(stream.node.mode)) {\\n          position += stream.node.usedBytes;\\n        }\\n      }\\n      if (position < 0) {\\n        throw new FS.ErrnoError(28);\\n      }\\n      return position;\\n    },\\n    allocate: function (stream, offset, length) {\\n      MEMFS.expandFileStorage(stream.node, offset + length);\\n      stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\\n    },\\n    mmap: function (stream, buffer, offset, length, position, prot, flags) {\\n      if (!FS.isFile(stream.node.mode)) {\\n        throw new FS.ErrnoError(43);\\n      }\\n      var ptr;\\n      var allocated;\\n      var contents = stream.node.contents;\\n      if (!(flags & 2) && contents.buffer === buffer.buffer) {\\n        allocated = false;\\n        ptr = contents.byteOffset;\\n      } else {\\n        if (position > 0 || position + length < contents.length) {\\n          if (contents.subarray) {\\n            contents = contents.subarray(position, position + length);\\n          } else {\\n            contents = Array.prototype.slice.call(contents, position, position + length);\\n          }\\n        }\\n        allocated = true;\\n        var fromHeap = buffer.buffer == HEAP8.buffer;\\n        ptr = _malloc(length);\\n        if (!ptr) {\\n          throw new FS.ErrnoError(48);\\n        }\\n        (fromHeap ? HEAP8 : buffer).set(contents, ptr);\\n      }\\n      return {\\n        ptr: ptr,\\n        allocated: allocated\\n      };\\n    },\\n    msync: function (stream, buffer, offset, length, mmapFlags) {\\n      if (!FS.isFile(stream.node.mode)) {\\n        throw new FS.ErrnoError(43);\\n      }\\n      if (mmapFlags & 2) {\\n        return 0;\\n      }\\n      var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\\n      return 0;\\n    }\\n  }\\n};\\nvar FS = {\\n  root: null,\\n  mounts: [],\\n  devices: {},\\n  streams: [],\\n  nextInode: 1,\\n  nameTable: null,\\n  currentPath: \\\"/\\\",\\n  initialized: false,\\n  ignorePermissions: true,\\n  trackingDelegate: {},\\n  tracking: {\\n    openFlags: {\\n      READ: 1,\\n      WRITE: 2\\n    }\\n  },\\n  ErrnoError: null,\\n  genericErrors: {},\\n  filesystems: null,\\n  syncFSRequests: 0,\\n  handleFSError: function (e) {\\n    if (!(e instanceof FS.ErrnoError)) throw e + \\\" : \\\" + stackTrace();\\n    return setErrNo(e.errno);\\n  },\\n  lookupPath: function (path, opts) {\\n    path = PATH_FS.resolve(FS.cwd(), path);\\n    opts = opts || {};\\n    if (!path) return {\\n      path: \\\"\\\",\\n      node: null\\n    };\\n    var defaults = {\\n      follow_mount: true,\\n      recurse_count: 0\\n    };\\n    for (var key in defaults) {\\n      if (opts[key] === undefined) {\\n        opts[key] = defaults[key];\\n      }\\n    }\\n    if (opts.recurse_count > 8) {\\n      throw new FS.ErrnoError(32);\\n    }\\n    var parts = PATH.normalizeArray(path.split(\\\"/\\\").filter(function (p) {\\n      return !!p;\\n    }), false);\\n    var current = FS.root;\\n    var current_path = \\\"/\\\";\\n    for (var i = 0; i < parts.length; i++) {\\n      var islast = i === parts.length - 1;\\n      if (islast && opts.parent) {\\n        break;\\n      }\\n      current = FS.lookupNode(current, parts[i]);\\n      current_path = PATH.join2(current_path, parts[i]);\\n      if (FS.isMountpoint(current)) {\\n        if (!islast || islast && opts.follow_mount) {\\n          current = current.mounted.root;\\n        }\\n      }\\n      if (!islast || opts.follow) {\\n        var count = 0;\\n        while (FS.isLink(current.mode)) {\\n          var link = FS.readlink(current_path);\\n          current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\\n          var lookup = FS.lookupPath(current_path, {\\n            recurse_count: opts.recurse_count\\n          });\\n          current = lookup.node;\\n          if (count++ > 40) {\\n            throw new FS.ErrnoError(32);\\n          }\\n        }\\n      }\\n    }\\n    return {\\n      path: current_path,\\n      node: current\\n    };\\n  },\\n  getPath: function (node) {\\n    var path;\\n    while (true) {\\n      if (FS.isRoot(node)) {\\n        var mount = node.mount.mountpoint;\\n        if (!path) return mount;\\n        return mount[mount.length - 1] !== \\\"/\\\" ? mount + \\\"/\\\" + path : mount + path;\\n      }\\n      path = path ? node.name + \\\"/\\\" + path : node.name;\\n      node = node.parent;\\n    }\\n  },\\n  hashName: function (parentid, name) {\\n    var hash = 0;\\n    for (var i = 0; i < name.length; i++) {\\n      hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\\n    }\\n    return (parentid + hash >>> 0) % FS.nameTable.length;\\n  },\\n  hashAddNode: function (node) {\\n    var hash = FS.hashName(node.parent.id, node.name);\\n    node.name_next = FS.nameTable[hash];\\n    FS.nameTable[hash] = node;\\n  },\\n  hashRemoveNode: function (node) {\\n    var hash = FS.hashName(node.parent.id, node.name);\\n    if (FS.nameTable[hash] === node) {\\n      FS.nameTable[hash] = node.name_next;\\n    } else {\\n      var current = FS.nameTable[hash];\\n      while (current) {\\n        if (current.name_next === node) {\\n          current.name_next = node.name_next;\\n          break;\\n        }\\n        current = current.name_next;\\n      }\\n    }\\n  },\\n  lookupNode: function (parent, name) {\\n    var errCode = FS.mayLookup(parent);\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode, parent);\\n    }\\n    var hash = FS.hashName(parent.id, name);\\n    for (var node = FS.nameTable[hash]; node; node = node.name_next) {\\n      var nodeName = node.name;\\n      if (node.parent.id === parent.id && nodeName === name) {\\n        return node;\\n      }\\n    }\\n    return FS.lookup(parent, name);\\n  },\\n  createNode: function (parent, name, mode, rdev) {\\n    var node = new FS.FSNode(parent, name, mode, rdev);\\n    FS.hashAddNode(node);\\n    return node;\\n  },\\n  destroyNode: function (node) {\\n    FS.hashRemoveNode(node);\\n  },\\n  isRoot: function (node) {\\n    return node === node.parent;\\n  },\\n  isMountpoint: function (node) {\\n    return !!node.mounted;\\n  },\\n  isFile: function (mode) {\\n    return (mode & 61440) === 32768;\\n  },\\n  isDir: function (mode) {\\n    return (mode & 61440) === 16384;\\n  },\\n  isLink: function (mode) {\\n    return (mode & 61440) === 40960;\\n  },\\n  isChrdev: function (mode) {\\n    return (mode & 61440) === 8192;\\n  },\\n  isBlkdev: function (mode) {\\n    return (mode & 61440) === 24576;\\n  },\\n  isFIFO: function (mode) {\\n    return (mode & 61440) === 4096;\\n  },\\n  isSocket: function (mode) {\\n    return (mode & 49152) === 49152;\\n  },\\n  flagModes: {\\n    \\\"r\\\": 0,\\n    \\\"rs\\\": 1052672,\\n    \\\"r+\\\": 2,\\n    \\\"w\\\": 577,\\n    \\\"wx\\\": 705,\\n    \\\"xw\\\": 705,\\n    \\\"w+\\\": 578,\\n    \\\"wx+\\\": 706,\\n    \\\"xw+\\\": 706,\\n    \\\"a\\\": 1089,\\n    \\\"ax\\\": 1217,\\n    \\\"xa\\\": 1217,\\n    \\\"a+\\\": 1090,\\n    \\\"ax+\\\": 1218,\\n    \\\"xa+\\\": 1218\\n  },\\n  modeStringToFlags: function (str) {\\n    var flags = FS.flagModes[str];\\n    if (typeof flags === \\\"undefined\\\") {\\n      throw new Error(\\\"Unknown file open mode: \\\" + str);\\n    }\\n    return flags;\\n  },\\n  flagsToPermissionString: function (flag) {\\n    var perms = [\\\"r\\\", \\\"w\\\", \\\"rw\\\"][flag & 3];\\n    if (flag & 512) {\\n      perms += \\\"w\\\";\\n    }\\n    return perms;\\n  },\\n  nodePermissions: function (node, perms) {\\n    if (FS.ignorePermissions) {\\n      return 0;\\n    }\\n    if (perms.indexOf(\\\"r\\\") !== -1 && !(node.mode & 292)) {\\n      return 2;\\n    } else if (perms.indexOf(\\\"w\\\") !== -1 && !(node.mode & 146)) {\\n      return 2;\\n    } else if (perms.indexOf(\\\"x\\\") !== -1 && !(node.mode & 73)) {\\n      return 2;\\n    }\\n    return 0;\\n  },\\n  mayLookup: function (dir) {\\n    var errCode = FS.nodePermissions(dir, \\\"x\\\");\\n    if (errCode) return errCode;\\n    if (!dir.node_ops.lookup) return 2;\\n    return 0;\\n  },\\n  mayCreate: function (dir, name) {\\n    try {\\n      var node = FS.lookupNode(dir, name);\\n      return 20;\\n    } catch (e) {}\\n    return FS.nodePermissions(dir, \\\"wx\\\");\\n  },\\n  mayDelete: function (dir, name, isdir) {\\n    var node;\\n    try {\\n      node = FS.lookupNode(dir, name);\\n    } catch (e) {\\n      return e.errno;\\n    }\\n    var errCode = FS.nodePermissions(dir, \\\"wx\\\");\\n    if (errCode) {\\n      return errCode;\\n    }\\n    if (isdir) {\\n      if (!FS.isDir(node.mode)) {\\n        return 54;\\n      }\\n      if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\\n        return 10;\\n      }\\n    } else {\\n      if (FS.isDir(node.mode)) {\\n        return 31;\\n      }\\n    }\\n    return 0;\\n  },\\n  mayOpen: function (node, flags) {\\n    if (!node) {\\n      return 44;\\n    }\\n    if (FS.isLink(node.mode)) {\\n      return 32;\\n    } else if (FS.isDir(node.mode)) {\\n      if (FS.flagsToPermissionString(flags) !== \\\"r\\\" || flags & 512) {\\n        return 31;\\n      }\\n    }\\n    return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\\n  },\\n  MAX_OPEN_FDS: 4096,\\n  nextfd: function (fd_start, fd_end) {\\n    fd_start = fd_start || 0;\\n    fd_end = fd_end || FS.MAX_OPEN_FDS;\\n    for (var fd = fd_start; fd <= fd_end; fd++) {\\n      if (!FS.streams[fd]) {\\n        return fd;\\n      }\\n    }\\n    throw new FS.ErrnoError(33);\\n  },\\n  getStream: function (fd) {\\n    return FS.streams[fd];\\n  },\\n  createStream: function (stream, fd_start, fd_end) {\\n    if (!FS.FSStream) {\\n      FS.FSStream = function () {};\\n      FS.FSStream.prototype = {\\n        object: {\\n          get: function () {\\n            return this.node;\\n          },\\n          set: function (val) {\\n            this.node = val;\\n          }\\n        },\\n        isRead: {\\n          get: function () {\\n            return (this.flags & 2097155) !== 1;\\n          }\\n        },\\n        isWrite: {\\n          get: function () {\\n            return (this.flags & 2097155) !== 0;\\n          }\\n        },\\n        isAppend: {\\n          get: function () {\\n            return this.flags & 1024;\\n          }\\n        }\\n      };\\n    }\\n    var newStream = new FS.FSStream();\\n    for (var p in stream) {\\n      newStream[p] = stream[p];\\n    }\\n    stream = newStream;\\n    var fd = FS.nextfd(fd_start, fd_end);\\n    stream.fd = fd;\\n    FS.streams[fd] = stream;\\n    return stream;\\n  },\\n  closeStream: function (fd) {\\n    FS.streams[fd] = null;\\n  },\\n  chrdev_stream_ops: {\\n    open: function (stream) {\\n      var device = FS.getDevice(stream.node.rdev);\\n      stream.stream_ops = device.stream_ops;\\n      if (stream.stream_ops.open) {\\n        stream.stream_ops.open(stream);\\n      }\\n    },\\n    llseek: function () {\\n      throw new FS.ErrnoError(70);\\n    }\\n  },\\n  major: function (dev) {\\n    return dev >> 8;\\n  },\\n  minor: function (dev) {\\n    return dev & 255;\\n  },\\n  makedev: function (ma, mi) {\\n    return ma << 8 | mi;\\n  },\\n  registerDevice: function (dev, ops) {\\n    FS.devices[dev] = {\\n      stream_ops: ops\\n    };\\n  },\\n  getDevice: function (dev) {\\n    return FS.devices[dev];\\n  },\\n  getMounts: function (mount) {\\n    var mounts = [];\\n    var check = [mount];\\n    while (check.length) {\\n      var m = check.pop();\\n      mounts.push(m);\\n      check.push.apply(check, m.mounts);\\n    }\\n    return mounts;\\n  },\\n  syncfs: function (populate, callback) {\\n    if (typeof populate === \\\"function\\\") {\\n      callback = populate;\\n      populate = false;\\n    }\\n    FS.syncFSRequests++;\\n    if (FS.syncFSRequests > 1) {\\n      err(\\\"warning: \\\" + FS.syncFSRequests + \\\" FS.syncfs operations in flight at once, probably just doing extra work\\\");\\n    }\\n    var mounts = FS.getMounts(FS.root.mount);\\n    var completed = 0;\\n    function doCallback(errCode) {\\n      FS.syncFSRequests--;\\n      return callback(errCode);\\n    }\\n    function done(errCode) {\\n      if (errCode) {\\n        if (!done.errored) {\\n          done.errored = true;\\n          return doCallback(errCode);\\n        }\\n        return;\\n      }\\n      if (++completed >= mounts.length) {\\n        doCallback(null);\\n      }\\n    }\\n    mounts.forEach(function (mount) {\\n      if (!mount.type.syncfs) {\\n        return done(null);\\n      }\\n      mount.type.syncfs(mount, populate, done);\\n    });\\n  },\\n  mount: function (type, opts, mountpoint) {\\n    var root = mountpoint === \\\"/\\\";\\n    var pseudo = !mountpoint;\\n    var node;\\n    if (root && FS.root) {\\n      throw new FS.ErrnoError(10);\\n    } else if (!root && !pseudo) {\\n      var lookup = FS.lookupPath(mountpoint, {\\n        follow_mount: false\\n      });\\n      mountpoint = lookup.path;\\n      node = lookup.node;\\n      if (FS.isMountpoint(node)) {\\n        throw new FS.ErrnoError(10);\\n      }\\n      if (!FS.isDir(node.mode)) {\\n        throw new FS.ErrnoError(54);\\n      }\\n    }\\n    var mount = {\\n      type: type,\\n      opts: opts,\\n      mountpoint: mountpoint,\\n      mounts: []\\n    };\\n    var mountRoot = type.mount(mount);\\n    mountRoot.mount = mount;\\n    mount.root = mountRoot;\\n    if (root) {\\n      FS.root = mountRoot;\\n    } else if (node) {\\n      node.mounted = mount;\\n      if (node.mount) {\\n        node.mount.mounts.push(mount);\\n      }\\n    }\\n    return mountRoot;\\n  },\\n  unmount: function (mountpoint) {\\n    var lookup = FS.lookupPath(mountpoint, {\\n      follow_mount: false\\n    });\\n    if (!FS.isMountpoint(lookup.node)) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    var node = lookup.node;\\n    var mount = node.mounted;\\n    var mounts = FS.getMounts(mount);\\n    Object.keys(FS.nameTable).forEach(function (hash) {\\n      var current = FS.nameTable[hash];\\n      while (current) {\\n        var next = current.name_next;\\n        if (mounts.indexOf(current.mount) !== -1) {\\n          FS.destroyNode(current);\\n        }\\n        current = next;\\n      }\\n    });\\n    node.mounted = null;\\n    var idx = node.mount.mounts.indexOf(mount);\\n    node.mount.mounts.splice(idx, 1);\\n  },\\n  lookup: function (parent, name) {\\n    return parent.node_ops.lookup(parent, name);\\n  },\\n  mknod: function (path, mode, dev) {\\n    var lookup = FS.lookupPath(path, {\\n      parent: true\\n    });\\n    var parent = lookup.node;\\n    var name = PATH.basename(path);\\n    if (!name || name === \\\".\\\" || name === \\\"..\\\") {\\n      throw new FS.ErrnoError(28);\\n    }\\n    var errCode = FS.mayCreate(parent, name);\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n    if (!parent.node_ops.mknod) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    return parent.node_ops.mknod(parent, name, mode, dev);\\n  },\\n  create: function (path, mode) {\\n    mode = mode !== undefined ? mode : 438;\\n    mode &= 4095;\\n    mode |= 32768;\\n    return FS.mknod(path, mode, 0);\\n  },\\n  mkdir: function (path, mode) {\\n    mode = mode !== undefined ? mode : 511;\\n    mode &= 511 | 512;\\n    mode |= 16384;\\n    return FS.mknod(path, mode, 0);\\n  },\\n  mkdirTree: function (path, mode) {\\n    var dirs = path.split(\\\"/\\\");\\n    var d = \\\"\\\";\\n    for (var i = 0; i < dirs.length; ++i) {\\n      if (!dirs[i]) continue;\\n      d += \\\"/\\\" + dirs[i];\\n      try {\\n        FS.mkdir(d, mode);\\n      } catch (e) {\\n        if (e.errno != 20) throw e;\\n      }\\n    }\\n  },\\n  mkdev: function (path, mode, dev) {\\n    if (typeof dev === \\\"undefined\\\") {\\n      dev = mode;\\n      mode = 438;\\n    }\\n    mode |= 8192;\\n    return FS.mknod(path, mode, dev);\\n  },\\n  symlink: function (oldpath, newpath) {\\n    if (!PATH_FS.resolve(oldpath)) {\\n      throw new FS.ErrnoError(44);\\n    }\\n    var lookup = FS.lookupPath(newpath, {\\n      parent: true\\n    });\\n    var parent = lookup.node;\\n    if (!parent) {\\n      throw new FS.ErrnoError(44);\\n    }\\n    var newname = PATH.basename(newpath);\\n    var errCode = FS.mayCreate(parent, newname);\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n    if (!parent.node_ops.symlink) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    return parent.node_ops.symlink(parent, newname, oldpath);\\n  },\\n  rename: function (old_path, new_path) {\\n    var old_dirname = PATH.dirname(old_path);\\n    var new_dirname = PATH.dirname(new_path);\\n    var old_name = PATH.basename(old_path);\\n    var new_name = PATH.basename(new_path);\\n    var lookup, old_dir, new_dir;\\n    try {\\n      lookup = FS.lookupPath(old_path, {\\n        parent: true\\n      });\\n      old_dir = lookup.node;\\n      lookup = FS.lookupPath(new_path, {\\n        parent: true\\n      });\\n      new_dir = lookup.node;\\n    } catch (e) {\\n      throw new FS.ErrnoError(10);\\n    }\\n    if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\\n    if (old_dir.mount !== new_dir.mount) {\\n      throw new FS.ErrnoError(75);\\n    }\\n    var old_node = FS.lookupNode(old_dir, old_name);\\n    var relative = PATH_FS.relative(old_path, new_dirname);\\n    if (relative.charAt(0) !== \\\".\\\") {\\n      throw new FS.ErrnoError(28);\\n    }\\n    relative = PATH_FS.relative(new_path, old_dirname);\\n    if (relative.charAt(0) !== \\\".\\\") {\\n      throw new FS.ErrnoError(55);\\n    }\\n    var new_node;\\n    try {\\n      new_node = FS.lookupNode(new_dir, new_name);\\n    } catch (e) {}\\n    if (old_node === new_node) {\\n      return;\\n    }\\n    var isdir = FS.isDir(old_node.mode);\\n    var errCode = FS.mayDelete(old_dir, old_name, isdir);\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n    errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n    if (!old_dir.node_ops.rename) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\\n      throw new FS.ErrnoError(10);\\n    }\\n    if (new_dir !== old_dir) {\\n      errCode = FS.nodePermissions(old_dir, \\\"w\\\");\\n      if (errCode) {\\n        throw new FS.ErrnoError(errCode);\\n      }\\n    }\\n    try {\\n      if (FS.trackingDelegate[\\\"willMovePath\\\"]) {\\n        FS.trackingDelegate[\\\"willMovePath\\\"](old_path, new_path);\\n      }\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['willMovePath']('\\\" + old_path + \\\"', '\\\" + new_path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n    FS.hashRemoveNode(old_node);\\n    try {\\n      old_dir.node_ops.rename(old_node, new_dir, new_name);\\n    } catch (e) {\\n      throw e;\\n    } finally {\\n      FS.hashAddNode(old_node);\\n    }\\n    try {\\n      if (FS.trackingDelegate[\\\"onMovePath\\\"]) FS.trackingDelegate[\\\"onMovePath\\\"](old_path, new_path);\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onMovePath']('\\\" + old_path + \\\"', '\\\" + new_path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n  },\\n  rmdir: function (path) {\\n    var lookup = FS.lookupPath(path, {\\n      parent: true\\n    });\\n    var parent = lookup.node;\\n    var name = PATH.basename(path);\\n    var node = FS.lookupNode(parent, name);\\n    var errCode = FS.mayDelete(parent, name, true);\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n    if (!parent.node_ops.rmdir) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    if (FS.isMountpoint(node)) {\\n      throw new FS.ErrnoError(10);\\n    }\\n    try {\\n      if (FS.trackingDelegate[\\\"willDeletePath\\\"]) {\\n        FS.trackingDelegate[\\\"willDeletePath\\\"](path);\\n      }\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['willDeletePath']('\\\" + path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n    parent.node_ops.rmdir(parent, name);\\n    FS.destroyNode(node);\\n    try {\\n      if (FS.trackingDelegate[\\\"onDeletePath\\\"]) FS.trackingDelegate[\\\"onDeletePath\\\"](path);\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onDeletePath']('\\\" + path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n  },\\n  readdir: function (path) {\\n    var lookup = FS.lookupPath(path, {\\n      follow: true\\n    });\\n    var node = lookup.node;\\n    if (!node.node_ops.readdir) {\\n      throw new FS.ErrnoError(54);\\n    }\\n    return node.node_ops.readdir(node);\\n  },\\n  unlink: function (path) {\\n    var lookup = FS.lookupPath(path, {\\n      parent: true\\n    });\\n    var parent = lookup.node;\\n    var name = PATH.basename(path);\\n    var node = FS.lookupNode(parent, name);\\n    var errCode = FS.mayDelete(parent, name, false);\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n    if (!parent.node_ops.unlink) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    if (FS.isMountpoint(node)) {\\n      throw new FS.ErrnoError(10);\\n    }\\n    try {\\n      if (FS.trackingDelegate[\\\"willDeletePath\\\"]) {\\n        FS.trackingDelegate[\\\"willDeletePath\\\"](path);\\n      }\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['willDeletePath']('\\\" + path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n    parent.node_ops.unlink(parent, name);\\n    FS.destroyNode(node);\\n    try {\\n      if (FS.trackingDelegate[\\\"onDeletePath\\\"]) FS.trackingDelegate[\\\"onDeletePath\\\"](path);\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onDeletePath']('\\\" + path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n  },\\n  readlink: function (path) {\\n    var lookup = FS.lookupPath(path);\\n    var link = lookup.node;\\n    if (!link) {\\n      throw new FS.ErrnoError(44);\\n    }\\n    if (!link.node_ops.readlink) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\\n  },\\n  stat: function (path, dontFollow) {\\n    var lookup = FS.lookupPath(path, {\\n      follow: !dontFollow\\n    });\\n    var node = lookup.node;\\n    if (!node) {\\n      throw new FS.ErrnoError(44);\\n    }\\n    if (!node.node_ops.getattr) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    return node.node_ops.getattr(node);\\n  },\\n  lstat: function (path) {\\n    return FS.stat(path, true);\\n  },\\n  chmod: function (path, mode, dontFollow) {\\n    var node;\\n    if (typeof path === \\\"string\\\") {\\n      var lookup = FS.lookupPath(path, {\\n        follow: !dontFollow\\n      });\\n      node = lookup.node;\\n    } else {\\n      node = path;\\n    }\\n    if (!node.node_ops.setattr) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    node.node_ops.setattr(node, {\\n      mode: mode & 4095 | node.mode & ~4095,\\n      timestamp: Date.now()\\n    });\\n  },\\n  lchmod: function (path, mode) {\\n    FS.chmod(path, mode, true);\\n  },\\n  fchmod: function (fd, mode) {\\n    var stream = FS.getStream(fd);\\n    if (!stream) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    FS.chmod(stream.node, mode);\\n  },\\n  chown: function (path, uid, gid, dontFollow) {\\n    var node;\\n    if (typeof path === \\\"string\\\") {\\n      var lookup = FS.lookupPath(path, {\\n        follow: !dontFollow\\n      });\\n      node = lookup.node;\\n    } else {\\n      node = path;\\n    }\\n    if (!node.node_ops.setattr) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    node.node_ops.setattr(node, {\\n      timestamp: Date.now()\\n    });\\n  },\\n  lchown: function (path, uid, gid) {\\n    FS.chown(path, uid, gid, true);\\n  },\\n  fchown: function (fd, uid, gid) {\\n    var stream = FS.getStream(fd);\\n    if (!stream) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    FS.chown(stream.node, uid, gid);\\n  },\\n  truncate: function (path, len) {\\n    if (len < 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    var node;\\n    if (typeof path === \\\"string\\\") {\\n      var lookup = FS.lookupPath(path, {\\n        follow: true\\n      });\\n      node = lookup.node;\\n    } else {\\n      node = path;\\n    }\\n    if (!node.node_ops.setattr) {\\n      throw new FS.ErrnoError(63);\\n    }\\n    if (FS.isDir(node.mode)) {\\n      throw new FS.ErrnoError(31);\\n    }\\n    if (!FS.isFile(node.mode)) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    var errCode = FS.nodePermissions(node, \\\"w\\\");\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n    node.node_ops.setattr(node, {\\n      size: len,\\n      timestamp: Date.now()\\n    });\\n  },\\n  ftruncate: function (fd, len) {\\n    var stream = FS.getStream(fd);\\n    if (!stream) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    if ((stream.flags & 2097155) === 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    FS.truncate(stream.node, len);\\n  },\\n  utime: function (path, atime, mtime) {\\n    var lookup = FS.lookupPath(path, {\\n      follow: true\\n    });\\n    var node = lookup.node;\\n    node.node_ops.setattr(node, {\\n      timestamp: Math.max(atime, mtime)\\n    });\\n  },\\n  open: function (path, flags, mode, fd_start, fd_end) {\\n    if (path === \\\"\\\") {\\n      throw new FS.ErrnoError(44);\\n    }\\n    flags = typeof flags === \\\"string\\\" ? FS.modeStringToFlags(flags) : flags;\\n    mode = typeof mode === \\\"undefined\\\" ? 438 : mode;\\n    if (flags & 64) {\\n      mode = mode & 4095 | 32768;\\n    } else {\\n      mode = 0;\\n    }\\n    var node;\\n    if (typeof path === \\\"object\\\") {\\n      node = path;\\n    } else {\\n      path = PATH.normalize(path);\\n      try {\\n        var lookup = FS.lookupPath(path, {\\n          follow: !(flags & 131072)\\n        });\\n        node = lookup.node;\\n      } catch (e) {}\\n    }\\n    var created = false;\\n    if (flags & 64) {\\n      if (node) {\\n        if (flags & 128) {\\n          throw new FS.ErrnoError(20);\\n        }\\n      } else {\\n        node = FS.mknod(path, mode, 0);\\n        created = true;\\n      }\\n    }\\n    if (!node) {\\n      throw new FS.ErrnoError(44);\\n    }\\n    if (FS.isChrdev(node.mode)) {\\n      flags &= ~512;\\n    }\\n    if (flags & 65536 && !FS.isDir(node.mode)) {\\n      throw new FS.ErrnoError(54);\\n    }\\n    if (!created) {\\n      var errCode = FS.mayOpen(node, flags);\\n      if (errCode) {\\n        throw new FS.ErrnoError(errCode);\\n      }\\n    }\\n    if (flags & 512) {\\n      FS.truncate(node, 0);\\n    }\\n    flags &= ~(128 | 512 | 131072);\\n    var stream = FS.createStream({\\n      node: node,\\n      path: FS.getPath(node),\\n      flags: flags,\\n      seekable: true,\\n      position: 0,\\n      stream_ops: node.stream_ops,\\n      ungotten: [],\\n      error: false\\n    }, fd_start, fd_end);\\n    if (stream.stream_ops.open) {\\n      stream.stream_ops.open(stream);\\n    }\\n    if (Module[\\\"logReadFiles\\\"] && !(flags & 1)) {\\n      if (!FS.readFiles) FS.readFiles = {};\\n      if (!(path in FS.readFiles)) {\\n        FS.readFiles[path] = 1;\\n        err(\\\"FS.trackingDelegate error on read file: \\\" + path);\\n      }\\n    }\\n    try {\\n      if (FS.trackingDelegate[\\\"onOpenFile\\\"]) {\\n        var trackingFlags = 0;\\n        if ((flags & 2097155) !== 1) {\\n          trackingFlags |= FS.tracking.openFlags.READ;\\n        }\\n        if ((flags & 2097155) !== 0) {\\n          trackingFlags |= FS.tracking.openFlags.WRITE;\\n        }\\n        FS.trackingDelegate[\\\"onOpenFile\\\"](path, trackingFlags);\\n      }\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onOpenFile']('\\\" + path + \\\"', flags) threw an exception: \\\" + e.message);\\n    }\\n    return stream;\\n  },\\n  close: function (stream) {\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    if (stream.getdents) stream.getdents = null;\\n    try {\\n      if (stream.stream_ops.close) {\\n        stream.stream_ops.close(stream);\\n      }\\n    } catch (e) {\\n      throw e;\\n    } finally {\\n      FS.closeStream(stream.fd);\\n    }\\n    stream.fd = null;\\n  },\\n  isClosed: function (stream) {\\n    return stream.fd === null;\\n  },\\n  llseek: function (stream, offset, whence) {\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    if (!stream.seekable || !stream.stream_ops.llseek) {\\n      throw new FS.ErrnoError(70);\\n    }\\n    if (whence != 0 && whence != 1 && whence != 2) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    stream.position = stream.stream_ops.llseek(stream, offset, whence);\\n    stream.ungotten = [];\\n    return stream.position;\\n  },\\n  read: function (stream, buffer, offset, length, position) {\\n    if (length < 0 || position < 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    if ((stream.flags & 2097155) === 1) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    if (FS.isDir(stream.node.mode)) {\\n      throw new FS.ErrnoError(31);\\n    }\\n    if (!stream.stream_ops.read) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    var seeking = typeof position !== \\\"undefined\\\";\\n    if (!seeking) {\\n      position = stream.position;\\n    } else if (!stream.seekable) {\\n      throw new FS.ErrnoError(70);\\n    }\\n    var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\\n    if (!seeking) stream.position += bytesRead;\\n    return bytesRead;\\n  },\\n  write: function (stream, buffer, offset, length, position, canOwn) {\\n    if (length < 0 || position < 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    if ((stream.flags & 2097155) === 0) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    if (FS.isDir(stream.node.mode)) {\\n      throw new FS.ErrnoError(31);\\n    }\\n    if (!stream.stream_ops.write) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    if (stream.seekable && stream.flags & 1024) {\\n      FS.llseek(stream, 0, 2);\\n    }\\n    var seeking = typeof position !== \\\"undefined\\\";\\n    if (!seeking) {\\n      position = stream.position;\\n    } else if (!stream.seekable) {\\n      throw new FS.ErrnoError(70);\\n    }\\n    var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\\n    if (!seeking) stream.position += bytesWritten;\\n    try {\\n      if (stream.path && FS.trackingDelegate[\\\"onWriteToFile\\\"]) FS.trackingDelegate[\\\"onWriteToFile\\\"](stream.path);\\n    } catch (e) {\\n      err(\\\"FS.trackingDelegate['onWriteToFile']('\\\" + stream.path + \\\"') threw an exception: \\\" + e.message);\\n    }\\n    return bytesWritten;\\n  },\\n  allocate: function (stream, offset, length) {\\n    if (FS.isClosed(stream)) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    if (offset < 0 || length <= 0) {\\n      throw new FS.ErrnoError(28);\\n    }\\n    if ((stream.flags & 2097155) === 0) {\\n      throw new FS.ErrnoError(8);\\n    }\\n    if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\\n      throw new FS.ErrnoError(43);\\n    }\\n    if (!stream.stream_ops.allocate) {\\n      throw new FS.ErrnoError(138);\\n    }\\n    stream.stream_ops.allocate(stream, offset, length);\\n  },\\n  mmap: function (stream, buffer, offset, length, position, prot, flags) {\\n    if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\\n      throw new FS.ErrnoError(2);\\n    }\\n    if ((stream.flags & 2097155) === 1) {\\n      throw new FS.ErrnoError(2);\\n    }\\n    if (!stream.stream_ops.mmap) {\\n      throw new FS.ErrnoError(43);\\n    }\\n    return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);\\n  },\\n  msync: function (stream, buffer, offset, length, mmapFlags) {\\n    if (!stream || !stream.stream_ops.msync) {\\n      return 0;\\n    }\\n    return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\\n  },\\n  munmap: function (stream) {\\n    return 0;\\n  },\\n  ioctl: function (stream, cmd, arg) {\\n    if (!stream.stream_ops.ioctl) {\\n      throw new FS.ErrnoError(59);\\n    }\\n    return stream.stream_ops.ioctl(stream, cmd, arg);\\n  },\\n  readFile: function (path, opts) {\\n    opts = opts || {};\\n    opts.flags = opts.flags || \\\"r\\\";\\n    opts.encoding = opts.encoding || \\\"binary\\\";\\n    if (opts.encoding !== \\\"utf8\\\" && opts.encoding !== \\\"binary\\\") {\\n      throw new Error('Invalid encoding type \\\"' + opts.encoding + '\\\"');\\n    }\\n    var ret;\\n    var stream = FS.open(path, opts.flags);\\n    var stat = FS.stat(path);\\n    var length = stat.size;\\n    var buf = new Uint8Array(length);\\n    FS.read(stream, buf, 0, length, 0);\\n    if (opts.encoding === \\\"utf8\\\") {\\n      ret = UTF8ArrayToString(buf, 0);\\n    } else if (opts.encoding === \\\"binary\\\") {\\n      ret = buf;\\n    }\\n    FS.close(stream);\\n    return ret;\\n  },\\n  writeFile: function (path, data, opts) {\\n    opts = opts || {};\\n    opts.flags = opts.flags || \\\"w\\\";\\n    var stream = FS.open(path, opts.flags, opts.mode);\\n    if (typeof data === \\\"string\\\") {\\n      var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\\n      var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\\n      FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\\n    } else if (ArrayBuffer.isView(data)) {\\n      FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\\n    } else {\\n      throw new Error(\\\"Unsupported data type\\\");\\n    }\\n    FS.close(stream);\\n  },\\n  cwd: function () {\\n    return FS.currentPath;\\n  },\\n  chdir: function (path) {\\n    var lookup = FS.lookupPath(path, {\\n      follow: true\\n    });\\n    if (lookup.node === null) {\\n      throw new FS.ErrnoError(44);\\n    }\\n    if (!FS.isDir(lookup.node.mode)) {\\n      throw new FS.ErrnoError(54);\\n    }\\n    var errCode = FS.nodePermissions(lookup.node, \\\"x\\\");\\n    if (errCode) {\\n      throw new FS.ErrnoError(errCode);\\n    }\\n    FS.currentPath = lookup.path;\\n  },\\n  createDefaultDirectories: function () {\\n    FS.mkdir(\\\"/tmp\\\");\\n    FS.mkdir(\\\"/home\\\");\\n    FS.mkdir(\\\"/home/web_user\\\");\\n  },\\n  createDefaultDevices: function () {\\n    FS.mkdir(\\\"/dev\\\");\\n    FS.registerDevice(FS.makedev(1, 3), {\\n      read: function () {\\n        return 0;\\n      },\\n      write: function (stream, buffer, offset, length, pos) {\\n        return length;\\n      }\\n    });\\n    FS.mkdev(\\\"/dev/null\\\", FS.makedev(1, 3));\\n    TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\\n    TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\\n    FS.mkdev(\\\"/dev/tty\\\", FS.makedev(5, 0));\\n    FS.mkdev(\\\"/dev/tty1\\\", FS.makedev(6, 0));\\n    var random_device;\\n    if (typeof crypto === \\\"object\\\" && typeof crypto[\\\"getRandomValues\\\"] === \\\"function\\\") {\\n      var randomBuffer = new Uint8Array(1);\\n      random_device = function () {\\n        crypto.getRandomValues(randomBuffer);\\n        return randomBuffer[0];\\n      };\\n    } else if (ENVIRONMENT_IS_NODE) {\\n      try {\\n        var crypto_module = require(\\\"crypto\\\");\\n        random_device = function () {\\n          return crypto_module[\\\"randomBytes\\\"](1)[0];\\n        };\\n      } catch (e) {}\\n    } else {}\\n    if (!random_device) {\\n      random_device = function () {\\n        abort(\\\"random_device\\\");\\n      };\\n    }\\n    FS.createDevice(\\\"/dev\\\", \\\"random\\\", random_device);\\n    FS.createDevice(\\\"/dev\\\", \\\"urandom\\\", random_device);\\n    FS.mkdir(\\\"/dev/shm\\\");\\n    FS.mkdir(\\\"/dev/shm/tmp\\\");\\n  },\\n  createSpecialDirectories: function () {\\n    FS.mkdir(\\\"/proc\\\");\\n    FS.mkdir(\\\"/proc/self\\\");\\n    FS.mkdir(\\\"/proc/self/fd\\\");\\n    FS.mount({\\n      mount: function () {\\n        var node = FS.createNode(\\\"/proc/self\\\", \\\"fd\\\", 16384 | 511, 73);\\n        node.node_ops = {\\n          lookup: function (parent, name) {\\n            var fd = +name;\\n            var stream = FS.getStream(fd);\\n            if (!stream) throw new FS.ErrnoError(8);\\n            var ret = {\\n              parent: null,\\n              mount: {\\n                mountpoint: \\\"fake\\\"\\n              },\\n              node_ops: {\\n                readlink: function () {\\n                  return stream.path;\\n                }\\n              }\\n            };\\n            ret.parent = ret;\\n            return ret;\\n          }\\n        };\\n        return node;\\n      }\\n    }, {}, \\\"/proc/self/fd\\\");\\n  },\\n  createStandardStreams: function () {\\n    if (Module[\\\"stdin\\\"]) {\\n      FS.createDevice(\\\"/dev\\\", \\\"stdin\\\", Module[\\\"stdin\\\"]);\\n    } else {\\n      FS.symlink(\\\"/dev/tty\\\", \\\"/dev/stdin\\\");\\n    }\\n    if (Module[\\\"stdout\\\"]) {\\n      FS.createDevice(\\\"/dev\\\", \\\"stdout\\\", null, Module[\\\"stdout\\\"]);\\n    } else {\\n      FS.symlink(\\\"/dev/tty\\\", \\\"/dev/stdout\\\");\\n    }\\n    if (Module[\\\"stderr\\\"]) {\\n      FS.createDevice(\\\"/dev\\\", \\\"stderr\\\", null, Module[\\\"stderr\\\"]);\\n    } else {\\n      FS.symlink(\\\"/dev/tty1\\\", \\\"/dev/stderr\\\");\\n    }\\n    var stdin = FS.open(\\\"/dev/stdin\\\", \\\"r\\\");\\n    var stdout = FS.open(\\\"/dev/stdout\\\", \\\"w\\\");\\n    var stderr = FS.open(\\\"/dev/stderr\\\", \\\"w\\\");\\n  },\\n  ensureErrnoError: function () {\\n    if (FS.ErrnoError) return;\\n    FS.ErrnoError = function ErrnoError(errno, node) {\\n      this.node = node;\\n      this.setErrno = function (errno) {\\n        this.errno = errno;\\n      };\\n      this.setErrno(errno);\\n      this.message = \\\"FS error\\\";\\n    };\\n    FS.ErrnoError.prototype = new Error();\\n    FS.ErrnoError.prototype.constructor = FS.ErrnoError;\\n    [44].forEach(function (code) {\\n      FS.genericErrors[code] = new FS.ErrnoError(code);\\n      FS.genericErrors[code].stack = \\\"<generic error, no stack>\\\";\\n    });\\n  },\\n  staticInit: function () {\\n    FS.ensureErrnoError();\\n    FS.nameTable = new Array(4096);\\n    FS.mount(MEMFS, {}, \\\"/\\\");\\n    FS.createDefaultDirectories();\\n    FS.createDefaultDevices();\\n    FS.createSpecialDirectories();\\n    FS.filesystems = {\\n      \\\"MEMFS\\\": MEMFS\\n    };\\n  },\\n  init: function (input, output, error) {\\n    FS.init.initialized = true;\\n    FS.ensureErrnoError();\\n    Module[\\\"stdin\\\"] = input || Module[\\\"stdin\\\"];\\n    Module[\\\"stdout\\\"] = output || Module[\\\"stdout\\\"];\\n    Module[\\\"stderr\\\"] = error || Module[\\\"stderr\\\"];\\n    FS.createStandardStreams();\\n  },\\n  quit: function () {\\n    FS.init.initialized = false;\\n    var fflush = Module[\\\"_fflush\\\"];\\n    if (fflush) fflush(0);\\n    for (var i = 0; i < FS.streams.length; i++) {\\n      var stream = FS.streams[i];\\n      if (!stream) {\\n        continue;\\n      }\\n      FS.close(stream);\\n    }\\n  },\\n  getMode: function (canRead, canWrite) {\\n    var mode = 0;\\n    if (canRead) mode |= 292 | 73;\\n    if (canWrite) mode |= 146;\\n    return mode;\\n  },\\n  joinPath: function (parts, forceRelative) {\\n    var path = PATH.join.apply(null, parts);\\n    if (forceRelative && path[0] == \\\"/\\\") path = path.substr(1);\\n    return path;\\n  },\\n  absolutePath: function (relative, base) {\\n    return PATH_FS.resolve(base, relative);\\n  },\\n  standardizePath: function (path) {\\n    return PATH.normalize(path);\\n  },\\n  findObject: function (path, dontResolveLastLink) {\\n    var ret = FS.analyzePath(path, dontResolveLastLink);\\n    if (ret.exists) {\\n      return ret.object;\\n    } else {\\n      setErrNo(ret.error);\\n      return null;\\n    }\\n  },\\n  analyzePath: function (path, dontResolveLastLink) {\\n    try {\\n      var lookup = FS.lookupPath(path, {\\n        follow: !dontResolveLastLink\\n      });\\n      path = lookup.path;\\n    } catch (e) {}\\n    var ret = {\\n      isRoot: false,\\n      exists: false,\\n      error: 0,\\n      name: null,\\n      path: null,\\n      object: null,\\n      parentExists: false,\\n      parentPath: null,\\n      parentObject: null\\n    };\\n    try {\\n      var lookup = FS.lookupPath(path, {\\n        parent: true\\n      });\\n      ret.parentExists = true;\\n      ret.parentPath = lookup.path;\\n      ret.parentObject = lookup.node;\\n      ret.name = PATH.basename(path);\\n      lookup = FS.lookupPath(path, {\\n        follow: !dontResolveLastLink\\n      });\\n      ret.exists = true;\\n      ret.path = lookup.path;\\n      ret.object = lookup.node;\\n      ret.name = lookup.node.name;\\n      ret.isRoot = lookup.path === \\\"/\\\";\\n    } catch (e) {\\n      ret.error = e.errno;\\n    }\\n    return ret;\\n  },\\n  createFolder: function (parent, name, canRead, canWrite) {\\n    var path = PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name);\\n    var mode = FS.getMode(canRead, canWrite);\\n    return FS.mkdir(path, mode);\\n  },\\n  createPath: function (parent, path, canRead, canWrite) {\\n    parent = typeof parent === \\\"string\\\" ? parent : FS.getPath(parent);\\n    var parts = path.split(\\\"/\\\").reverse();\\n    while (parts.length) {\\n      var part = parts.pop();\\n      if (!part) continue;\\n      var current = PATH.join2(parent, part);\\n      try {\\n        FS.mkdir(current);\\n      } catch (e) {}\\n      parent = current;\\n    }\\n    return current;\\n  },\\n  createFile: function (parent, name, properties, canRead, canWrite) {\\n    var path = PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name);\\n    var mode = FS.getMode(canRead, canWrite);\\n    return FS.create(path, mode);\\n  },\\n  createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {\\n    var path = name ? PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name) : parent;\\n    var mode = FS.getMode(canRead, canWrite);\\n    var node = FS.create(path, mode);\\n    if (data) {\\n      if (typeof data === \\\"string\\\") {\\n        var arr = new Array(data.length);\\n        for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\\n        data = arr;\\n      }\\n      FS.chmod(node, mode | 146);\\n      var stream = FS.open(node, \\\"w\\\");\\n      FS.write(stream, data, 0, data.length, 0, canOwn);\\n      FS.close(stream);\\n      FS.chmod(node, mode);\\n    }\\n    return node;\\n  },\\n  createDevice: function (parent, name, input, output) {\\n    var path = PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name);\\n    var mode = FS.getMode(!!input, !!output);\\n    if (!FS.createDevice.major) FS.createDevice.major = 64;\\n    var dev = FS.makedev(FS.createDevice.major++, 0);\\n    FS.registerDevice(dev, {\\n      open: function (stream) {\\n        stream.seekable = false;\\n      },\\n      close: function (stream) {\\n        if (output && output.buffer && output.buffer.length) {\\n          output(10);\\n        }\\n      },\\n      read: function (stream, buffer, offset, length, pos) {\\n        var bytesRead = 0;\\n        for (var i = 0; i < length; i++) {\\n          var result;\\n          try {\\n            result = input();\\n          } catch (e) {\\n            throw new FS.ErrnoError(29);\\n          }\\n          if (result === undefined && bytesRead === 0) {\\n            throw new FS.ErrnoError(6);\\n          }\\n          if (result === null || result === undefined) break;\\n          bytesRead++;\\n          buffer[offset + i] = result;\\n        }\\n        if (bytesRead) {\\n          stream.node.timestamp = Date.now();\\n        }\\n        return bytesRead;\\n      },\\n      write: function (stream, buffer, offset, length, pos) {\\n        for (var i = 0; i < length; i++) {\\n          try {\\n            output(buffer[offset + i]);\\n          } catch (e) {\\n            throw new FS.ErrnoError(29);\\n          }\\n        }\\n        if (length) {\\n          stream.node.timestamp = Date.now();\\n        }\\n        return i;\\n      }\\n    });\\n    return FS.mkdev(path, mode, dev);\\n  },\\n  createLink: function (parent, name, target, canRead, canWrite) {\\n    var path = PATH.join2(typeof parent === \\\"string\\\" ? parent : FS.getPath(parent), name);\\n    return FS.symlink(target, path);\\n  },\\n  forceLoadFile: function (obj) {\\n    if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\\n    var success = true;\\n    if (typeof XMLHttpRequest !== \\\"undefined\\\") {\\n      throw new Error(\\\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\\\");\\n    } else if (read_) {\\n      try {\\n        obj.contents = intArrayFromString(read_(obj.url), true);\\n        obj.usedBytes = obj.contents.length;\\n      } catch (e) {\\n        success = false;\\n      }\\n    } else {\\n      throw new Error(\\\"Cannot load without read() or XMLHttpRequest.\\\");\\n    }\\n    if (!success) setErrNo(29);\\n    return success;\\n  },\\n  createLazyFile: function (parent, name, url, canRead, canWrite) {\\n    function LazyUint8Array() {\\n      this.lengthKnown = false;\\n      this.chunks = [];\\n    }\\n    LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\\n      if (idx > this.length - 1 || idx < 0) {\\n        return undefined;\\n      }\\n      var chunkOffset = idx % this.chunkSize;\\n      var chunkNum = idx / this.chunkSize | 0;\\n      return this.getter(chunkNum)[chunkOffset];\\n    };\\n    LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\\n      this.getter = getter;\\n    };\\n    LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\\n      var xhr = new XMLHttpRequest();\\n      xhr.open(\\\"HEAD\\\", url, false);\\n      xhr.send(null);\\n      if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\\\"Couldn't load \\\" + url + \\\". Status: \\\" + xhr.status);\\n      var datalength = Number(xhr.getResponseHeader(\\\"Content-length\\\"));\\n      var header;\\n      var hasByteServing = (header = xhr.getResponseHeader(\\\"Accept-Ranges\\\")) && header === \\\"bytes\\\";\\n      var usesGzip = (header = xhr.getResponseHeader(\\\"Content-Encoding\\\")) && header === \\\"gzip\\\";\\n      var chunkSize = 1024 * 1024;\\n      if (!hasByteServing) chunkSize = datalength;\\n      var doXHR = function (from, to) {\\n        if (from > to) throw new Error(\\\"invalid range (\\\" + from + \\\", \\\" + to + \\\") or no bytes requested!\\\");\\n        if (to > datalength - 1) throw new Error(\\\"only \\\" + datalength + \\\" bytes available! programmer error!\\\");\\n        var xhr = new XMLHttpRequest();\\n        xhr.open(\\\"GET\\\", url, false);\\n        if (datalength !== chunkSize) xhr.setRequestHeader(\\\"Range\\\", \\\"bytes=\\\" + from + \\\"-\\\" + to);\\n        if (typeof Uint8Array != \\\"undefined\\\") xhr.responseType = \\\"arraybuffer\\\";\\n        if (xhr.overrideMimeType) {\\n          xhr.overrideMimeType(\\\"text/plain; charset=x-user-defined\\\");\\n        }\\n        xhr.send(null);\\n        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\\\"Couldn't load \\\" + url + \\\". Status: \\\" + xhr.status);\\n        if (xhr.response !== undefined) {\\n          return new Uint8Array(xhr.response || []);\\n        } else {\\n          return intArrayFromString(xhr.responseText || \\\"\\\", true);\\n        }\\n      };\\n      var lazyArray = this;\\n      lazyArray.setDataGetter(function (chunkNum) {\\n        var start = chunkNum * chunkSize;\\n        var end = (chunkNum + 1) * chunkSize - 1;\\n        end = Math.min(end, datalength - 1);\\n        if (typeof lazyArray.chunks[chunkNum] === \\\"undefined\\\") {\\n          lazyArray.chunks[chunkNum] = doXHR(start, end);\\n        }\\n        if (typeof lazyArray.chunks[chunkNum] === \\\"undefined\\\") throw new Error(\\\"doXHR failed!\\\");\\n        return lazyArray.chunks[chunkNum];\\n      });\\n      if (usesGzip || !datalength) {\\n        chunkSize = datalength = 1;\\n        datalength = this.getter(0).length;\\n        chunkSize = datalength;\\n        out(\\\"LazyFiles on gzip forces download of the whole file when length is accessed\\\");\\n      }\\n      this._length = datalength;\\n      this._chunkSize = chunkSize;\\n      this.lengthKnown = true;\\n    };\\n    if (typeof XMLHttpRequest !== \\\"undefined\\\") {\\n      if (!ENVIRONMENT_IS_WORKER) throw \\\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\\\";\\n      var lazyArray = new LazyUint8Array();\\n      Object.defineProperties(lazyArray, {\\n        length: {\\n          get: function () {\\n            if (!this.lengthKnown) {\\n              this.cacheLength();\\n            }\\n            return this._length;\\n          }\\n        },\\n        chunkSize: {\\n          get: function () {\\n            if (!this.lengthKnown) {\\n              this.cacheLength();\\n            }\\n            return this._chunkSize;\\n          }\\n        }\\n      });\\n      var properties = {\\n        isDevice: false,\\n        contents: lazyArray\\n      };\\n    } else {\\n      var properties = {\\n        isDevice: false,\\n        url: url\\n      };\\n    }\\n    var node = FS.createFile(parent, name, properties, canRead, canWrite);\\n    if (properties.contents) {\\n      node.contents = properties.contents;\\n    } else if (properties.url) {\\n      node.contents = null;\\n      node.url = properties.url;\\n    }\\n    Object.defineProperties(node, {\\n      usedBytes: {\\n        get: function () {\\n          return this.contents.length;\\n        }\\n      }\\n    });\\n    var stream_ops = {};\\n    var keys = Object.keys(node.stream_ops);\\n    keys.forEach(function (key) {\\n      var fn = node.stream_ops[key];\\n      stream_ops[key] = function forceLoadLazyFile() {\\n        if (!FS.forceLoadFile(node)) {\\n          throw new FS.ErrnoError(29);\\n        }\\n        return fn.apply(null, arguments);\\n      };\\n    });\\n    stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\\n      if (!FS.forceLoadFile(node)) {\\n        throw new FS.ErrnoError(29);\\n      }\\n      var contents = stream.node.contents;\\n      if (position >= contents.length) return 0;\\n      var size = Math.min(contents.length - position, length);\\n      if (contents.slice) {\\n        for (var i = 0; i < size; i++) {\\n          buffer[offset + i] = contents[position + i];\\n        }\\n      } else {\\n        for (var i = 0; i < size; i++) {\\n          buffer[offset + i] = contents.get(position + i);\\n        }\\n      }\\n      return size;\\n    };\\n    node.stream_ops = stream_ops;\\n    return node;\\n  },\\n  createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\\n    Browser.init();\\n    var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\\n    var dep = getUniqueRunDependency(\\\"cp \\\" + fullname);\\n    function processData(byteArray) {\\n      function finish(byteArray) {\\n        if (preFinish) preFinish();\\n        if (!dontCreateFile) {\\n          FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\\n        }\\n        if (onload) onload();\\n        removeRunDependency(dep);\\n      }\\n      var handled = false;\\n      Module[\\\"preloadPlugins\\\"].forEach(function (plugin) {\\n        if (handled) return;\\n        if (plugin[\\\"canHandle\\\"](fullname)) {\\n          plugin[\\\"handle\\\"](byteArray, fullname, finish, function () {\\n            if (onerror) onerror();\\n            removeRunDependency(dep);\\n          });\\n          handled = true;\\n        }\\n      });\\n      if (!handled) finish(byteArray);\\n    }\\n    addRunDependency(dep);\\n    if (typeof url == \\\"string\\\") {\\n      Browser.asyncLoad(url, function (byteArray) {\\n        processData(byteArray);\\n      }, onerror);\\n    } else {\\n      processData(url);\\n    }\\n  },\\n  indexedDB: function () {\\n    return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\\n  },\\n  DB_NAME: function () {\\n    return \\\"EM_FS_\\\" + window.location.pathname;\\n  },\\n  DB_VERSION: 20,\\n  DB_STORE_NAME: \\\"FILE_DATA\\\",\\n  saveFilesToDB: function (paths, onload, onerror) {\\n    onload = onload || function () {};\\n    onerror = onerror || function () {};\\n    var indexedDB = FS.indexedDB();\\n    try {\\n      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\\n    } catch (e) {\\n      return onerror(e);\\n    }\\n    openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\\n      out(\\\"creating db\\\");\\n      var db = openRequest.result;\\n      db.createObjectStore(FS.DB_STORE_NAME);\\n    };\\n    openRequest.onsuccess = function openRequest_onsuccess() {\\n      var db = openRequest.result;\\n      var transaction = db.transaction([FS.DB_STORE_NAME], \\\"readwrite\\\");\\n      var files = transaction.objectStore(FS.DB_STORE_NAME);\\n      var ok = 0,\\n        fail = 0,\\n        total = paths.length;\\n      function finish() {\\n        if (fail == 0) onload();else onerror();\\n      }\\n      paths.forEach(function (path) {\\n        var putRequest = files.put(FS.analyzePath(path).object.contents, path);\\n        putRequest.onsuccess = function putRequest_onsuccess() {\\n          ok++;\\n          if (ok + fail == total) finish();\\n        };\\n        putRequest.onerror = function putRequest_onerror() {\\n          fail++;\\n          if (ok + fail == total) finish();\\n        };\\n      });\\n      transaction.onerror = onerror;\\n    };\\n    openRequest.onerror = onerror;\\n  },\\n  loadFilesFromDB: function (paths, onload, onerror) {\\n    onload = onload || function () {};\\n    onerror = onerror || function () {};\\n    var indexedDB = FS.indexedDB();\\n    try {\\n      var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\\n    } catch (e) {\\n      return onerror(e);\\n    }\\n    openRequest.onupgradeneeded = onerror;\\n    openRequest.onsuccess = function openRequest_onsuccess() {\\n      var db = openRequest.result;\\n      try {\\n        var transaction = db.transaction([FS.DB_STORE_NAME], \\\"readonly\\\");\\n      } catch (e) {\\n        onerror(e);\\n        return;\\n      }\\n      var files = transaction.objectStore(FS.DB_STORE_NAME);\\n      var ok = 0,\\n        fail = 0,\\n        total = paths.length;\\n      function finish() {\\n        if (fail == 0) onload();else onerror();\\n      }\\n      paths.forEach(function (path) {\\n        var getRequest = files.get(path);\\n        getRequest.onsuccess = function getRequest_onsuccess() {\\n          if (FS.analyzePath(path).exists) {\\n            FS.unlink(path);\\n          }\\n          FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\\n          ok++;\\n          if (ok + fail == total) finish();\\n        };\\n        getRequest.onerror = function getRequest_onerror() {\\n          fail++;\\n          if (ok + fail == total) finish();\\n        };\\n      });\\n      transaction.onerror = onerror;\\n    };\\n    openRequest.onerror = onerror;\\n  }\\n};\\nvar SYSCALLS = {\\n  mappings: {},\\n  DEFAULT_POLLMASK: 5,\\n  umask: 511,\\n  calculateAt: function (dirfd, path) {\\n    if (path[0] !== \\\"/\\\") {\\n      var dir;\\n      if (dirfd === -100) {\\n        dir = FS.cwd();\\n      } else {\\n        var dirstream = FS.getStream(dirfd);\\n        if (!dirstream) throw new FS.ErrnoError(8);\\n        dir = dirstream.path;\\n      }\\n      path = PATH.join2(dir, path);\\n    }\\n    return path;\\n  },\\n  doStat: function (func, path, buf) {\\n    try {\\n      var stat = func(path);\\n    } catch (e) {\\n      if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\\n        return -54;\\n      }\\n      throw e;\\n    }\\n    HEAP32[buf >> 2] = stat.dev;\\n    HEAP32[buf + 4 >> 2] = 0;\\n    HEAP32[buf + 8 >> 2] = stat.ino;\\n    HEAP32[buf + 12 >> 2] = stat.mode;\\n    HEAP32[buf + 16 >> 2] = stat.nlink;\\n    HEAP32[buf + 20 >> 2] = stat.uid;\\n    HEAP32[buf + 24 >> 2] = stat.gid;\\n    HEAP32[buf + 28 >> 2] = stat.rdev;\\n    HEAP32[buf + 32 >> 2] = 0;\\n    tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\\n    HEAP32[buf + 48 >> 2] = 4096;\\n    HEAP32[buf + 52 >> 2] = stat.blocks;\\n    HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;\\n    HEAP32[buf + 60 >> 2] = 0;\\n    HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;\\n    HEAP32[buf + 68 >> 2] = 0;\\n    HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;\\n    HEAP32[buf + 76 >> 2] = 0;\\n    tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];\\n    return 0;\\n  },\\n  doMsync: function (addr, stream, len, flags, offset) {\\n    var buffer = HEAPU8.slice(addr, addr + len);\\n    FS.msync(stream, buffer, offset, len, flags);\\n  },\\n  doMkdir: function (path, mode) {\\n    path = PATH.normalize(path);\\n    if (path[path.length - 1] === \\\"/\\\") path = path.substr(0, path.length - 1);\\n    FS.mkdir(path, mode, 0);\\n    return 0;\\n  },\\n  doMknod: function (path, mode, dev) {\\n    switch (mode & 61440) {\\n      case 32768:\\n      case 8192:\\n      case 24576:\\n      case 4096:\\n      case 49152:\\n        break;\\n      default:\\n        return -28;\\n    }\\n    FS.mknod(path, mode, dev);\\n    return 0;\\n  },\\n  doReadlink: function (path, buf, bufsize) {\\n    if (bufsize <= 0) return -28;\\n    var ret = FS.readlink(path);\\n    var len = Math.min(bufsize, lengthBytesUTF8(ret));\\n    var endChar = HEAP8[buf + len];\\n    stringToUTF8(ret, buf, bufsize + 1);\\n    HEAP8[buf + len] = endChar;\\n    return len;\\n  },\\n  doAccess: function (path, amode) {\\n    if (amode & ~7) {\\n      return -28;\\n    }\\n    var node;\\n    var lookup = FS.lookupPath(path, {\\n      follow: true\\n    });\\n    node = lookup.node;\\n    if (!node) {\\n      return -44;\\n    }\\n    var perms = \\\"\\\";\\n    if (amode & 4) perms += \\\"r\\\";\\n    if (amode & 2) perms += \\\"w\\\";\\n    if (amode & 1) perms += \\\"x\\\";\\n    if (perms && FS.nodePermissions(node, perms)) {\\n      return -2;\\n    }\\n    return 0;\\n  },\\n  doDup: function (path, flags, suggestFD) {\\n    var suggest = FS.getStream(suggestFD);\\n    if (suggest) FS.close(suggest);\\n    return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\\n  },\\n  doReadv: function (stream, iov, iovcnt, offset) {\\n    var ret = 0;\\n    for (var i = 0; i < iovcnt; i++) {\\n      var ptr = HEAP32[iov + i * 8 >> 2];\\n      var len = HEAP32[iov + (i * 8 + 4) >> 2];\\n      var curr = FS.read(stream, HEAP8, ptr, len, offset);\\n      if (curr < 0) return -1;\\n      ret += curr;\\n      if (curr < len) break;\\n    }\\n    return ret;\\n  },\\n  doWritev: function (stream, iov, iovcnt, offset) {\\n    var ret = 0;\\n    for (var i = 0; i < iovcnt; i++) {\\n      var ptr = HEAP32[iov + i * 8 >> 2];\\n      var len = HEAP32[iov + (i * 8 + 4) >> 2];\\n      var curr = FS.write(stream, HEAP8, ptr, len, offset);\\n      if (curr < 0) return -1;\\n      ret += curr;\\n    }\\n    return ret;\\n  },\\n  varargs: undefined,\\n  get: function () {\\n    SYSCALLS.varargs += 4;\\n    var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\\n    return ret;\\n  },\\n  getStr: function (ptr) {\\n    var ret = UTF8ToString(ptr);\\n    return ret;\\n  },\\n  getStreamFromFD: function (fd) {\\n    var stream = FS.getStream(fd);\\n    if (!stream) throw new FS.ErrnoError(8);\\n    return stream;\\n  },\\n  get64: function (low, high) {\\n    return low;\\n  }\\n};\\nfunction ___sys_fcntl64(fd, cmd, varargs) {\\n  SYSCALLS.varargs = varargs;\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    switch (cmd) {\\n      case 0:\\n        {\\n          var arg = SYSCALLS.get();\\n          if (arg < 0) {\\n            return -28;\\n          }\\n          var newStream;\\n          newStream = FS.open(stream.path, stream.flags, 0, arg);\\n          return newStream.fd;\\n        }\\n      case 1:\\n      case 2:\\n        return 0;\\n      case 3:\\n        return stream.flags;\\n      case 4:\\n        {\\n          var arg = SYSCALLS.get();\\n          stream.flags |= arg;\\n          return 0;\\n        }\\n      case 12:\\n        {\\n          var arg = SYSCALLS.get();\\n          var offset = 0;\\n          HEAP16[arg + offset >> 1] = 2;\\n          return 0;\\n        }\\n      case 13:\\n      case 14:\\n        return 0;\\n      case 16:\\n      case 8:\\n        return -28;\\n      case 9:\\n        setErrNo(28);\\n        return -1;\\n      default:\\n        {\\n          return -28;\\n        }\\n    }\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return -e.errno;\\n  }\\n}\\nfunction ___sys_ioctl(fd, op, varargs) {\\n  SYSCALLS.varargs = varargs;\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    switch (op) {\\n      case 21509:\\n      case 21505:\\n        {\\n          if (!stream.tty) return -59;\\n          return 0;\\n        }\\n      case 21510:\\n      case 21511:\\n      case 21512:\\n      case 21506:\\n      case 21507:\\n      case 21508:\\n        {\\n          if (!stream.tty) return -59;\\n          return 0;\\n        }\\n      case 21519:\\n        {\\n          if (!stream.tty) return -59;\\n          var argp = SYSCALLS.get();\\n          HEAP32[argp >> 2] = 0;\\n          return 0;\\n        }\\n      case 21520:\\n        {\\n          if (!stream.tty) return -59;\\n          return -28;\\n        }\\n      case 21531:\\n        {\\n          var argp = SYSCALLS.get();\\n          return FS.ioctl(stream, op, argp);\\n        }\\n      case 21523:\\n        {\\n          if (!stream.tty) return -59;\\n          return 0;\\n        }\\n      case 21524:\\n        {\\n          if (!stream.tty) return -59;\\n          return 0;\\n        }\\n      default:\\n        abort(\\\"bad ioctl syscall \\\" + op);\\n    }\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return -e.errno;\\n  }\\n}\\nfunction syscallMunmap(addr, len) {\\n  if ((addr | 0) === -1 || len === 0) {\\n    return -28;\\n  }\\n  var info = SYSCALLS.mappings[addr];\\n  if (!info) return 0;\\n  if (len === info.len) {\\n    var stream = FS.getStream(info.fd);\\n    if (info.prot & 2) {\\n      SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);\\n    }\\n    FS.munmap(stream);\\n    SYSCALLS.mappings[addr] = null;\\n    if (info.allocated) {\\n      _free(info.malloc);\\n    }\\n  }\\n  return 0;\\n}\\nfunction ___sys_munmap(addr, len) {\\n  try {\\n    return syscallMunmap(addr, len);\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return -e.errno;\\n  }\\n}\\nfunction ___sys_open(path, flags, varargs) {\\n  SYSCALLS.varargs = varargs;\\n  try {\\n    var pathname = SYSCALLS.getStr(path);\\n    var mode = SYSCALLS.get();\\n    var stream = FS.open(pathname, flags, mode);\\n    return stream.fd;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return -e.errno;\\n  }\\n}\\nfunction _abort() {\\n  abort();\\n}\\nvar setjmpId = 0;\\nfunction _saveSetjmp(env, label, table, size) {\\n  env = env | 0;\\n  label = label | 0;\\n  table = table | 0;\\n  size = size | 0;\\n  var i = 0;\\n  setjmpId = setjmpId + 1 | 0;\\n  HEAP32[env >> 2] = setjmpId;\\n  while ((i | 0) < (size | 0)) {\\n    if ((HEAP32[table + (i << 3) >> 2] | 0) == 0) {\\n      HEAP32[table + (i << 3) >> 2] = setjmpId;\\n      HEAP32[table + ((i << 3) + 4) >> 2] = label;\\n      HEAP32[table + ((i << 3) + 8) >> 2] = 0;\\n      setTempRet0(size | 0);\\n      return table | 0;\\n    }\\n    i = i + 1 | 0;\\n  }\\n  size = size * 2 | 0;\\n  table = _realloc(table | 0, 8 * (size + 1 | 0) | 0) | 0;\\n  table = _saveSetjmp(env | 0, label | 0, table | 0, size | 0) | 0;\\n  setTempRet0(size | 0);\\n  return table | 0;\\n}\\nfunction _testSetjmp(id, table, size) {\\n  id = id | 0;\\n  table = table | 0;\\n  size = size | 0;\\n  var i = 0,\\n    curr = 0;\\n  while ((i | 0) < (size | 0)) {\\n    curr = HEAP32[table + (i << 3) >> 2] | 0;\\n    if ((curr | 0) == 0) break;\\n    if ((curr | 0) == (id | 0)) {\\n      return HEAP32[table + ((i << 3) + 4) >> 2] | 0;\\n    }\\n    i = i + 1 | 0;\\n  }\\n  return 0;\\n}\\nfunction _longjmp(env, value) {\\n  _setThrew(env, value || 1);\\n  throw \\\"longjmp\\\";\\n}\\nfunction _emscripten_longjmp(env, value) {\\n  _longjmp(env, value);\\n}\\nfunction _emscripten_memcpy_big(dest, src, num) {\\n  HEAPU8.copyWithin(dest, src, src + num);\\n}\\nfunction _emscripten_get_heap_size() {\\n  return HEAPU8.length;\\n}\\nfunction emscripten_realloc_buffer(size) {\\n  try {\\n    wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\\n    updateGlobalBufferAndViews(wasmMemory.buffer);\\n    return 1;\\n  } catch (e) {}\\n}\\nfunction _emscripten_resize_heap(requestedSize) {\\n  requestedSize = requestedSize >>> 0;\\n  var oldSize = _emscripten_get_heap_size();\\n  var PAGE_MULTIPLE = 65536;\\n  var maxHeapSize = 2147483648;\\n  if (requestedSize > maxHeapSize) {\\n    return false;\\n  }\\n  var minHeapSize = 16777216;\\n  for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\\n    var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\\n    overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\\n    var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));\\n    var replacement = emscripten_realloc_buffer(newSize);\\n    if (replacement) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\nvar ENV = {};\\nfunction __getExecutableName() {\\n  return thisProgram || \\\"./this.program\\\";\\n}\\nfunction getEnvStrings() {\\n  if (!getEnvStrings.strings) {\\n    var env = {\\n      \\\"USER\\\": \\\"web_user\\\",\\n      \\\"LOGNAME\\\": \\\"web_user\\\",\\n      \\\"PATH\\\": \\\"/\\\",\\n      \\\"PWD\\\": \\\"/\\\",\\n      \\\"HOME\\\": \\\"/home/web_user\\\",\\n      \\\"LANG\\\": (typeof navigator === \\\"object\\\" && navigator.languages && navigator.languages[0] || \\\"C\\\").replace(\\\"-\\\", \\\"_\\\") + \\\".UTF-8\\\",\\n      \\\"_\\\": __getExecutableName()\\n    };\\n    for (var x in ENV) {\\n      env[x] = ENV[x];\\n    }\\n    var strings = [];\\n    for (var x in env) {\\n      strings.push(x + \\\"=\\\" + env[x]);\\n    }\\n    getEnvStrings.strings = strings;\\n  }\\n  return getEnvStrings.strings;\\n}\\nfunction _environ_get(__environ, environ_buf) {\\n  var bufSize = 0;\\n  getEnvStrings().forEach(function (string, i) {\\n    var ptr = environ_buf + bufSize;\\n    HEAP32[__environ + i * 4 >> 2] = ptr;\\n    writeAsciiToMemory(string, ptr);\\n    bufSize += string.length + 1;\\n  });\\n  return 0;\\n}\\nfunction _environ_sizes_get(penviron_count, penviron_buf_size) {\\n  var strings = getEnvStrings();\\n  HEAP32[penviron_count >> 2] = strings.length;\\n  var bufSize = 0;\\n  strings.forEach(function (string) {\\n    bufSize += string.length + 1;\\n  });\\n  HEAP32[penviron_buf_size >> 2] = bufSize;\\n  return 0;\\n}\\nfunction _fd_close(fd) {\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    FS.close(stream);\\n    return 0;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return e.errno;\\n  }\\n}\\nfunction _fd_read(fd, iov, iovcnt, pnum) {\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    var num = SYSCALLS.doReadv(stream, iov, iovcnt);\\n    HEAP32[pnum >> 2] = num;\\n    return 0;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return e.errno;\\n  }\\n}\\nfunction _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    var HIGH_OFFSET = 4294967296;\\n    var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);\\n    var DOUBLE_LIMIT = 9007199254740992;\\n    if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {\\n      return -61;\\n    }\\n    FS.llseek(stream, offset, whence);\\n    tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\\n    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\\n    return 0;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return e.errno;\\n  }\\n}\\nfunction _fd_write(fd, iov, iovcnt, pnum) {\\n  try {\\n    var stream = SYSCALLS.getStreamFromFD(fd);\\n    var num = SYSCALLS.doWritev(stream, iov, iovcnt);\\n    HEAP32[pnum >> 2] = num;\\n    return 0;\\n  } catch (e) {\\n    if (typeof FS === \\\"undefined\\\" || !(e instanceof FS.ErrnoError)) abort(e);\\n    return e.errno;\\n  }\\n}\\nfunction _getTempRet0() {\\n  return getTempRet0() | 0;\\n}\\nfunction _round(d) {\\n  d = +d;\\n  return d >= +0 ? +Math_floor(d + +.5) : +Math_ceil(d - +.5);\\n}\\nfunction _setTempRet0($i) {\\n  setTempRet0($i | 0);\\n}\\nfunction __isLeapYear(year) {\\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\\n}\\nfunction __arraySum(array, index) {\\n  var sum = 0;\\n  for (var i = 0; i <= index; sum += array[i++]) {}\\n  return sum;\\n}\\nvar __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\nvar __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\nfunction __addDays(date, days) {\\n  var newDate = new Date(date.getTime());\\n  while (days > 0) {\\n    var leap = __isLeapYear(newDate.getFullYear());\\n    var currentMonth = newDate.getMonth();\\n    var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\\n    if (days > daysInCurrentMonth - newDate.getDate()) {\\n      days -= daysInCurrentMonth - newDate.getDate() + 1;\\n      newDate.setDate(1);\\n      if (currentMonth < 11) {\\n        newDate.setMonth(currentMonth + 1);\\n      } else {\\n        newDate.setMonth(0);\\n        newDate.setFullYear(newDate.getFullYear() + 1);\\n      }\\n    } else {\\n      newDate.setDate(newDate.getDate() + days);\\n      return newDate;\\n    }\\n  }\\n  return newDate;\\n}\\nfunction _strftime(s, maxsize, format, tm) {\\n  var tm_zone = HEAP32[tm + 40 >> 2];\\n  var date = {\\n    tm_sec: HEAP32[tm >> 2],\\n    tm_min: HEAP32[tm + 4 >> 2],\\n    tm_hour: HEAP32[tm + 8 >> 2],\\n    tm_mday: HEAP32[tm + 12 >> 2],\\n    tm_mon: HEAP32[tm + 16 >> 2],\\n    tm_year: HEAP32[tm + 20 >> 2],\\n    tm_wday: HEAP32[tm + 24 >> 2],\\n    tm_yday: HEAP32[tm + 28 >> 2],\\n    tm_isdst: HEAP32[tm + 32 >> 2],\\n    tm_gmtoff: HEAP32[tm + 36 >> 2],\\n    tm_zone: tm_zone ? UTF8ToString(tm_zone) : \\\"\\\"\\n  };\\n  var pattern = UTF8ToString(format);\\n  var EXPANSION_RULES_1 = {\\n    \\\"%c\\\": \\\"%a %b %d %H:%M:%S %Y\\\",\\n    \\\"%D\\\": \\\"%m/%d/%y\\\",\\n    \\\"%F\\\": \\\"%Y-%m-%d\\\",\\n    \\\"%h\\\": \\\"%b\\\",\\n    \\\"%r\\\": \\\"%I:%M:%S %p\\\",\\n    \\\"%R\\\": \\\"%H:%M\\\",\\n    \\\"%T\\\": \\\"%H:%M:%S\\\",\\n    \\\"%x\\\": \\\"%m/%d/%y\\\",\\n    \\\"%X\\\": \\\"%H:%M:%S\\\",\\n    \\\"%Ec\\\": \\\"%c\\\",\\n    \\\"%EC\\\": \\\"%C\\\",\\n    \\\"%Ex\\\": \\\"%m/%d/%y\\\",\\n    \\\"%EX\\\": \\\"%H:%M:%S\\\",\\n    \\\"%Ey\\\": \\\"%y\\\",\\n    \\\"%EY\\\": \\\"%Y\\\",\\n    \\\"%Od\\\": \\\"%d\\\",\\n    \\\"%Oe\\\": \\\"%e\\\",\\n    \\\"%OH\\\": \\\"%H\\\",\\n    \\\"%OI\\\": \\\"%I\\\",\\n    \\\"%Om\\\": \\\"%m\\\",\\n    \\\"%OM\\\": \\\"%M\\\",\\n    \\\"%OS\\\": \\\"%S\\\",\\n    \\\"%Ou\\\": \\\"%u\\\",\\n    \\\"%OU\\\": \\\"%U\\\",\\n    \\\"%OV\\\": \\\"%V\\\",\\n    \\\"%Ow\\\": \\\"%w\\\",\\n    \\\"%OW\\\": \\\"%W\\\",\\n    \\\"%Oy\\\": \\\"%y\\\"\\n  };\\n  for (var rule in EXPANSION_RULES_1) {\\n    pattern = pattern.replace(new RegExp(rule, \\\"g\\\"), EXPANSION_RULES_1[rule]);\\n  }\\n  var WEEKDAYS = [\\\"Sunday\\\", \\\"Monday\\\", \\\"Tuesday\\\", \\\"Wednesday\\\", \\\"Thursday\\\", \\\"Friday\\\", \\\"Saturday\\\"];\\n  var MONTHS = [\\\"January\\\", \\\"February\\\", \\\"March\\\", \\\"April\\\", \\\"May\\\", \\\"June\\\", \\\"July\\\", \\\"August\\\", \\\"September\\\", \\\"October\\\", \\\"November\\\", \\\"December\\\"];\\n  function leadingSomething(value, digits, character) {\\n    var str = typeof value === \\\"number\\\" ? value.toString() : value || \\\"\\\";\\n    while (str.length < digits) {\\n      str = character[0] + str;\\n    }\\n    return str;\\n  }\\n  function leadingNulls(value, digits) {\\n    return leadingSomething(value, digits, \\\"0\\\");\\n  }\\n  function compareByDay(date1, date2) {\\n    function sgn(value) {\\n      return value < 0 ? -1 : value > 0 ? 1 : 0;\\n    }\\n    var compare;\\n    if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\\n      if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\\n        compare = sgn(date1.getDate() - date2.getDate());\\n      }\\n    }\\n    return compare;\\n  }\\n  function getFirstWeekStartDate(janFourth) {\\n    switch (janFourth.getDay()) {\\n      case 0:\\n        return new Date(janFourth.getFullYear() - 1, 11, 29);\\n      case 1:\\n        return janFourth;\\n      case 2:\\n        return new Date(janFourth.getFullYear(), 0, 3);\\n      case 3:\\n        return new Date(janFourth.getFullYear(), 0, 2);\\n      case 4:\\n        return new Date(janFourth.getFullYear(), 0, 1);\\n      case 5:\\n        return new Date(janFourth.getFullYear() - 1, 11, 31);\\n      case 6:\\n        return new Date(janFourth.getFullYear() - 1, 11, 30);\\n    }\\n  }\\n  function getWeekBasedYear(date) {\\n    var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\\n    var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\\n    var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\\n    var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\\n    var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\\n    if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\\n      if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\\n        return thisDate.getFullYear() + 1;\\n      } else {\\n        return thisDate.getFullYear();\\n      }\\n    } else {\\n      return thisDate.getFullYear() - 1;\\n    }\\n  }\\n  var EXPANSION_RULES_2 = {\\n    \\\"%a\\\": function (date) {\\n      return WEEKDAYS[date.tm_wday].substring(0, 3);\\n    },\\n    \\\"%A\\\": function (date) {\\n      return WEEKDAYS[date.tm_wday];\\n    },\\n    \\\"%b\\\": function (date) {\\n      return MONTHS[date.tm_mon].substring(0, 3);\\n    },\\n    \\\"%B\\\": function (date) {\\n      return MONTHS[date.tm_mon];\\n    },\\n    \\\"%C\\\": function (date) {\\n      var year = date.tm_year + 1900;\\n      return leadingNulls(year / 100 | 0, 2);\\n    },\\n    \\\"%d\\\": function (date) {\\n      return leadingNulls(date.tm_mday, 2);\\n    },\\n    \\\"%e\\\": function (date) {\\n      return leadingSomething(date.tm_mday, 2, \\\" \\\");\\n    },\\n    \\\"%g\\\": function (date) {\\n      return getWeekBasedYear(date).toString().substring(2);\\n    },\\n    \\\"%G\\\": function (date) {\\n      return getWeekBasedYear(date);\\n    },\\n    \\\"%H\\\": function (date) {\\n      return leadingNulls(date.tm_hour, 2);\\n    },\\n    \\\"%I\\\": function (date) {\\n      var twelveHour = date.tm_hour;\\n      if (twelveHour == 0) twelveHour = 12;else if (twelveHour > 12) twelveHour -= 12;\\n      return leadingNulls(twelveHour, 2);\\n    },\\n    \\\"%j\\\": function (date) {\\n      return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);\\n    },\\n    \\\"%m\\\": function (date) {\\n      return leadingNulls(date.tm_mon + 1, 2);\\n    },\\n    \\\"%M\\\": function (date) {\\n      return leadingNulls(date.tm_min, 2);\\n    },\\n    \\\"%n\\\": function () {\\n      return \\\"\\\\n\\\";\\n    },\\n    \\\"%p\\\": function (date) {\\n      if (date.tm_hour >= 0 && date.tm_hour < 12) {\\n        return \\\"AM\\\";\\n      } else {\\n        return \\\"PM\\\";\\n      }\\n    },\\n    \\\"%S\\\": function (date) {\\n      return leadingNulls(date.tm_sec, 2);\\n    },\\n    \\\"%t\\\": function () {\\n      return \\\"\\\\t\\\";\\n    },\\n    \\\"%u\\\": function (date) {\\n      return date.tm_wday || 7;\\n    },\\n    \\\"%U\\\": function (date) {\\n      var janFirst = new Date(date.tm_year + 1900, 0, 1);\\n      var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());\\n      var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\\n      if (compareByDay(firstSunday, endDate) < 0) {\\n        var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\\n        var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();\\n        var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\\n        return leadingNulls(Math.ceil(days / 7), 2);\\n      }\\n      return compareByDay(firstSunday, janFirst) === 0 ? \\\"01\\\" : \\\"00\\\";\\n    },\\n    \\\"%V\\\": function (date) {\\n      var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);\\n      var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);\\n      var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\\n      var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\\n      var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\\n      if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\\n        return \\\"53\\\";\\n      }\\n      if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\\n        return \\\"01\\\";\\n      }\\n      var daysDifference;\\n      if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {\\n        daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();\\n      } else {\\n        daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();\\n      }\\n      return leadingNulls(Math.ceil(daysDifference / 7), 2);\\n    },\\n    \\\"%w\\\": function (date) {\\n      return date.tm_wday;\\n    },\\n    \\\"%W\\\": function (date) {\\n      var janFirst = new Date(date.tm_year, 0, 1);\\n      var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);\\n      var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);\\n      if (compareByDay(firstMonday, endDate) < 0) {\\n        var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;\\n        var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();\\n        var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();\\n        return leadingNulls(Math.ceil(days / 7), 2);\\n      }\\n      return compareByDay(firstMonday, janFirst) === 0 ? \\\"01\\\" : \\\"00\\\";\\n    },\\n    \\\"%y\\\": function (date) {\\n      return (date.tm_year + 1900).toString().substring(2);\\n    },\\n    \\\"%Y\\\": function (date) {\\n      return date.tm_year + 1900;\\n    },\\n    \\\"%z\\\": function (date) {\\n      var off = date.tm_gmtoff;\\n      var ahead = off >= 0;\\n      off = Math.abs(off) / 60;\\n      off = off / 60 * 100 + off % 60;\\n      return (ahead ? \\\"+\\\" : \\\"-\\\") + String(\\\"0000\\\" + off).slice(-4);\\n    },\\n    \\\"%Z\\\": function (date) {\\n      return date.tm_zone;\\n    },\\n    \\\"%%\\\": function () {\\n      return \\\"%\\\";\\n    }\\n  };\\n  for (var rule in EXPANSION_RULES_2) {\\n    if (pattern.indexOf(rule) >= 0) {\\n      pattern = pattern.replace(new RegExp(rule, \\\"g\\\"), EXPANSION_RULES_2[rule](date));\\n    }\\n  }\\n  var bytes = intArrayFromString(pattern, false);\\n  if (bytes.length > maxsize) {\\n    return 0;\\n  }\\n  writeArrayToMemory(bytes, s);\\n  return bytes.length - 1;\\n}\\nfunction _strftime_l(s, maxsize, format, tm) {\\n  return _strftime(s, maxsize, format, tm);\\n}\\nvar FSNode = function (parent, name, mode, rdev) {\\n  if (!parent) {\\n    parent = this;\\n  }\\n  this.parent = parent;\\n  this.mount = parent.mount;\\n  this.mounted = null;\\n  this.id = FS.nextInode++;\\n  this.name = name;\\n  this.mode = mode;\\n  this.node_ops = {};\\n  this.stream_ops = {};\\n  this.rdev = rdev;\\n};\\nvar readMode = 292 | 73;\\nvar writeMode = 146;\\nObject.defineProperties(FSNode.prototype, {\\n  read: {\\n    get: function () {\\n      return (this.mode & readMode) === readMode;\\n    },\\n    set: function (val) {\\n      val ? this.mode |= readMode : this.mode &= ~readMode;\\n    }\\n  },\\n  write: {\\n    get: function () {\\n      return (this.mode & writeMode) === writeMode;\\n    },\\n    set: function (val) {\\n      val ? this.mode |= writeMode : this.mode &= ~writeMode;\\n    }\\n  },\\n  isFolder: {\\n    get: function () {\\n      return FS.isDir(this.mode);\\n    }\\n  },\\n  isDevice: {\\n    get: function () {\\n      return FS.isChrdev(this.mode);\\n    }\\n  }\\n});\\nFS.FSNode = FSNode;\\nFS.staticInit();\\nfunction intArrayFromString(stringy, dontAddNull, length) {\\n  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\\n  var u8array = new Array(len);\\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\\n  if (dontAddNull) u8array.length = numBytesWritten;\\n  return u8array;\\n}\\nvar asmLibraryArg = {\\n  \\\"o\\\": __ZN7VRegionC1ERK5VRect,\\n  \\\"m\\\": __ZN7VRegionD1Ev,\\n  \\\"n\\\": __ZN7VRegionpLERK5VRect,\\n  \\\"x\\\": __ZNK7VRegion12boundingRectEv,\\n  \\\"a\\\": ___assert_fail,\\n  \\\"u\\\": ___map_file,\\n  \\\"h\\\": ___sys_fcntl64,\\n  \\\"z\\\": ___sys_ioctl,\\n  \\\"t\\\": ___sys_munmap,\\n  \\\"A\\\": ___sys_open,\\n  \\\"d\\\": _abort,\\n  \\\"c\\\": _emscripten_longjmp,\\n  \\\"q\\\": _emscripten_memcpy_big,\\n  \\\"r\\\": _emscripten_resize_heap,\\n  \\\"v\\\": _environ_get,\\n  \\\"w\\\": _environ_sizes_get,\\n  \\\"g\\\": _fd_close,\\n  \\\"y\\\": _fd_read,\\n  \\\"p\\\": _fd_seek,\\n  \\\"f\\\": _fd_write,\\n  \\\"b\\\": _getTempRet0,\\n  \\\"k\\\": invoke_iii,\\n  \\\"B\\\": invoke_vi,\\n  \\\"memory\\\": wasmMemory,\\n  \\\"i\\\": _round,\\n  \\\"l\\\": _saveSetjmp,\\n  \\\"j\\\": _setTempRet0,\\n  \\\"s\\\": _strftime_l,\\n  \\\"table\\\": wasmTable,\\n  \\\"e\\\": _testSetjmp\\n};\\nvar asm = createWasm();\\nModule[\\\"asm\\\"] = asm;\\nvar ___wasm_call_ctors = Module[\\\"___wasm_call_ctors\\\"] = function () {\\n  return (___wasm_call_ctors = Module[\\\"___wasm_call_ctors\\\"] = Module[\\\"asm\\\"][\\\"C\\\"]).apply(null, arguments);\\n};\\nvar _lottie_init = Module[\\\"_lottie_init\\\"] = function () {\\n  return (_lottie_init = Module[\\\"_lottie_init\\\"] = Module[\\\"asm\\\"][\\\"D\\\"]).apply(null, arguments);\\n};\\nvar _lottie_resize = Module[\\\"_lottie_resize\\\"] = function () {\\n  return (_lottie_resize = Module[\\\"_lottie_resize\\\"] = Module[\\\"asm\\\"][\\\"E\\\"]).apply(null, arguments);\\n};\\nvar _free = Module[\\\"_free\\\"] = function () {\\n  return (_free = Module[\\\"_free\\\"] = Module[\\\"asm\\\"][\\\"F\\\"]).apply(null, arguments);\\n};\\nvar _lottie_load_from_data = Module[\\\"_lottie_load_from_data\\\"] = function () {\\n  return (_lottie_load_from_data = Module[\\\"_lottie_load_from_data\\\"] = Module[\\\"asm\\\"][\\\"G\\\"]).apply(null, arguments);\\n};\\nvar _lottie_buffer = Module[\\\"_lottie_buffer\\\"] = function () {\\n  return (_lottie_buffer = Module[\\\"_lottie_buffer\\\"] = Module[\\\"asm\\\"][\\\"H\\\"]).apply(null, arguments);\\n};\\nvar _lottie_destroy = Module[\\\"_lottie_destroy\\\"] = function () {\\n  return (_lottie_destroy = Module[\\\"_lottie_destroy\\\"] = Module[\\\"asm\\\"][\\\"I\\\"]).apply(null, arguments);\\n};\\nvar _lottie_render = Module[\\\"_lottie_render\\\"] = function () {\\n  return (_lottie_render = Module[\\\"_lottie_render\\\"] = Module[\\\"asm\\\"][\\\"J\\\"]).apply(null, arguments);\\n};\\nvar _malloc = Module[\\\"_malloc\\\"] = function () {\\n  return (_malloc = Module[\\\"_malloc\\\"] = Module[\\\"asm\\\"][\\\"K\\\"]).apply(null, arguments);\\n};\\nvar _realloc = Module[\\\"_realloc\\\"] = function () {\\n  return (_realloc = Module[\\\"_realloc\\\"] = Module[\\\"asm\\\"][\\\"L\\\"]).apply(null, arguments);\\n};\\nvar ___errno_location = Module[\\\"___errno_location\\\"] = function () {\\n  return (___errno_location = Module[\\\"___errno_location\\\"] = Module[\\\"asm\\\"][\\\"M\\\"]).apply(null, arguments);\\n};\\nvar _setThrew = Module[\\\"_setThrew\\\"] = function () {\\n  return (_setThrew = Module[\\\"_setThrew\\\"] = Module[\\\"asm\\\"][\\\"N\\\"]).apply(null, arguments);\\n};\\nvar dynCall_vi = Module[\\\"dynCall_vi\\\"] = function () {\\n  return (dynCall_vi = Module[\\\"dynCall_vi\\\"] = Module[\\\"asm\\\"][\\\"O\\\"]).apply(null, arguments);\\n};\\nvar dynCall_iii = Module[\\\"dynCall_iii\\\"] = function () {\\n  return (dynCall_iii = Module[\\\"dynCall_iii\\\"] = Module[\\\"asm\\\"][\\\"P\\\"]).apply(null, arguments);\\n};\\nvar stackSave = Module[\\\"stackSave\\\"] = function () {\\n  return (stackSave = Module[\\\"stackSave\\\"] = Module[\\\"asm\\\"][\\\"Q\\\"]).apply(null, arguments);\\n};\\nvar stackAlloc = Module[\\\"stackAlloc\\\"] = function () {\\n  return (stackAlloc = Module[\\\"stackAlloc\\\"] = Module[\\\"asm\\\"][\\\"R\\\"]).apply(null, arguments);\\n};\\nvar stackRestore = Module[\\\"stackRestore\\\"] = function () {\\n  return (stackRestore = Module[\\\"stackRestore\\\"] = Module[\\\"asm\\\"][\\\"S\\\"]).apply(null, arguments);\\n};\\nvar dynCall_v = Module[\\\"dynCall_v\\\"] = function () {\\n  return (dynCall_v = Module[\\\"dynCall_v\\\"] = Module[\\\"asm\\\"][\\\"T\\\"]).apply(null, arguments);\\n};\\nfunction invoke_iii(index, a1, a2) {\\n  var sp = stackSave();\\n  try {\\n    return dynCall_iii(index, a1, a2);\\n  } catch (e) {\\n    stackRestore(sp);\\n    if (e !== e + 0 && e !== \\\"longjmp\\\") throw e;\\n    _setThrew(1, 0);\\n  }\\n}\\nfunction invoke_vi(index, a1) {\\n  var sp = stackSave();\\n  try {\\n    dynCall_vi(index, a1);\\n  } catch (e) {\\n    stackRestore(sp);\\n    if (e !== e + 0 && e !== \\\"longjmp\\\") throw e;\\n    _setThrew(1, 0);\\n  }\\n}\\nModule[\\\"asm\\\"] = asm;\\nModule[\\\"intArrayFromString\\\"] = intArrayFromString;\\nModule[\\\"cwrap\\\"] = cwrap;\\nModule[\\\"allocate\\\"] = allocate;\\nvar calledRun;\\nfunction ExitStatus(status) {\\n  this.name = \\\"ExitStatus\\\";\\n  this.message = \\\"Program terminated with exit(\\\" + status + \\\")\\\";\\n  this.status = status;\\n}\\ndependenciesFulfilled = function runCaller() {\\n  if (!calledRun) run();\\n  if (!calledRun) dependenciesFulfilled = runCaller;\\n};\\nfunction run(args) {\\n  args = args || arguments_;\\n  if (runDependencies > 0) {\\n    return;\\n  }\\n  preRun();\\n  if (runDependencies > 0) return;\\n  function doRun() {\\n    if (calledRun) return;\\n    calledRun = true;\\n    Module[\\\"calledRun\\\"] = true;\\n    if (ABORT) return;\\n    initRuntime();\\n    preMain();\\n    if (Module[\\\"onRuntimeInitialized\\\"]) Module[\\\"onRuntimeInitialized\\\"]();\\n    postRun();\\n  }\\n  if (Module[\\\"setStatus\\\"]) {\\n    Module[\\\"setStatus\\\"](\\\"Running...\\\");\\n    setTimeout(function () {\\n      setTimeout(function () {\\n        Module[\\\"setStatus\\\"](\\\"\\\");\\n      }, 1);\\n      doRun();\\n    }, 1);\\n  } else {\\n    doRun();\\n  }\\n}\\nModule[\\\"run\\\"] = run;\\nif (Module[\\\"preInit\\\"]) {\\n  if (typeof Module[\\\"preInit\\\"] == \\\"function\\\") Module[\\\"preInit\\\"] = [Module[\\\"preInit\\\"]];\\n  while (Module[\\\"preInit\\\"].length > 0) {\\n    Module[\\\"preInit\\\"].pop()();\\n  }\\n}\\nnoExitRuntime = true;\\nrun();\"","require(\"!!/Users/alexander/dev/telegram-tt/node_modules/script-loader/addScript.js\")(require(\"!!/Users/alexander/dev/telegram-tt/node_modules/raw-loader/index.js!/Users/alexander/dev/telegram-tt/node_modules/babel-loader/lib/index.js!/Users/alexander/dev/telegram-tt/src/lib/rlottie/rlottie-wasm.js\"))","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [5802,6835], () => (__webpack_require__(55648)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + {\"5101\":\"ebd1e966cfa2340a7084\",\"5802\":\"207c1d379140a8835f7e\",\"6835\":\"a1874bcca0ac0f4788f8\"}[chunkId] + \".js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t5648: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunktelegram_t\"] = self[\"webpackChunktelegram_t\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","SUPPORTED_IMAGE_CONTENT_TYPES","window","innerHeight","Math","round","Set","SUPPORTED_VIDEO_CONTENT_TYPES","callbackState","Map","messageHandlers","callbacks","removeCallback","cb","delete","runCallbacks","_len","arguments","length","args","Array","_key","forEach","callback","addCallback","add","hasCallbacks","Boolean","size","createCallbackManager","createWorkerInterface","api","channel","sendToOrigin","data","transferables","postMessage","self","onerror","e","console","error","type","message","addEventListener","reason","handleErrors","async","onUpdate","update","promise","init","messageId","name","withCallback","callbackArgs","lastArg","isTransferable","undefined","set","push","response","arrayBuffer","get","isCanceled","onMessage","obj","ArrayBuffer","ImageBitmap","rLottieApi","onmessage","rLottieApiPromise","Promise","resolve","Module","onRuntimeInitialized","cwrap","destroy","resize","buffer","render","loadFromData","renderers","extractJson","tgsUrl","fetch","headers","startsWith","text","inflate","to","calcParams","json","isLowPriority","framesCount","maxFps","sourceFps","JSON","parse","fr","reduceFactor","msPerFrame","reducedFramesCount","ceil","key","imgSize","customColor","onInit","stringOnWasmHeap","allocate","intArrayFromString","handle","imageData","ImageData","frameIndex","onProgress","realIndex","bufferPointer","HEAPU8","subarray","arr","Uint8ClampedArray","color","i","applyColor","createImageBitmap","isRepeated","renderer","err","setTimeout","requestStates","result","requestState","MIN_PART_SIZE","Status","MP4Demuxer","constructor","url","_ref","onConfig","onChunk","stepOffset","stepMultiplier","isPolyfill","maxFrames","_defineProperty","loading","this","file","MP4Box","onError","onReady","bind","onSamples","loadMetadata","offset","requestPart","status","ready","step","duration","partSize","tick","lastSample","rap","seek","closed","flush","useRap","reminder","start","end","params","store","id","withAutoUpdate","String","random","replace","generateIdFor","isResolved","race","then","reject","Error","Object","assign","catch","finally","slice","fileStart","nextOffset","appendBuffer","byteLength","description","track","t","getTrackById","entry","mdia","minf","stbl","stsd","entries","avcC","hvcC","av1C","stream","DataStream","write","Uint8Array","info","videoTracks","codec","codedHeight","video","height","codedWidth","width","timescale","partSizeDivider","bitrate","max","calculateStep","setExtractionOptions","nbSamples","loadNextFrames","trackId","ref","samples","sample","time","cts","is_sync","number","decodedSamples","has","EncodedVideoChunk","timestamp","parseInt","releaseUsedSamples","close","stop","_data","byteOffset","_libavGetData","copyTo","destination","offscreenCanvas","VideoFrame","_constructBuffer","_constructCanvas","image","document","createElement","style","display","body","appendChild","naturalWidth","naturalHeight","videoWidth","videoHeight","DOMException","ctx","getContext","clearRect","drawImage","getImageData","format","layout","stride","displayWidth","displayHeight","visibleRect","DOMRect","dWidth","dHeight","_nonSquarePixels","_sar_num","_sar_den","_layout","numPlanes_","numPlanes","sampleWidth","horizontalSubSamplingFactor","sampleHeight","verticalSubSamplingFactor","allocationSize","options","_parseVideoFrameCopyToOptions","defaultRect","overrideRect","rect","x","y","parsedRect","_parseVisibleRect","optLayout","_computeLayoutAndAllocationSize","sourceRect","TypeError","_verifyRectSampleAlignment","minAllocationSize","computedLayouts","endOffsets","planeIndex","sampleBytes_","sampleBytes","sampleWidthBytes","computedLayout","destinationOffset","destinationStride","sourceTop","sourceHeight","sourceLeftBytes","sourceWidthBytes","planeLayout","planeSize","planeEnd","earlierPlaneIndex","xw","ww","yh","hh","destBuf","combinedLayout","ret","sourceStride","sourceOffset","rowBytes","row","clone","libavs","libavOptions","decoders","setLibAVOptions","shift","LibAV","free","libav","load","avname","avcodec_find_decoder_by_name","codecs","decoder","outCodec","indexOf","libavjs","cloneConfig","config","fields","field","VideoDecoder","_output","output","_error","state","decodeQueueSize","_p","all","_libav","_codec","_c","_pkt","_frame","configure","_free","supported","ptr","malloc","copyin_u8","parm","calloc","AVCodecParameters_extradata_s","AVCodecParameters_extradata_size_s","ff_init_decoder","AVCodecContext_time_base_s","_closeVideoDecoder","ff_free_decoder","exception","_resetVideoDecoder","decode","chunk","c","pkt","frame","decodedOutputs","ptsFull","floor","pts","ptshi","packet","dts","dtshi","durationhi","ff_decode_multi","ex","_outputVideoFrames","frames","AV_PIX_FMT_YUV420P","AV_PIX_FMT_YUVA420P","AV_PIX_FMT_YUV422P","AV_PIX_FMT_YUV444P","AV_PIX_FMT_NV12","AV_PIX_FMT_RGBA","AV_PIX_FMT_BGRA","sample_aspect_ratio","sar","raw","planes","vf","sbs","hssfs","vssfs","off","fd","j","part","reset","static","dec","misc","scalerSync","scalerAsync","origCreateImageBitmap","polyfill","noworker","global","opts","apply","resizeWidth","resizeHeight","frameData","sctx","inFrame","outFrame","sws_getContext","av_frame_alloc","rawU8","rawIdx","p","plane","sb","hssf","vssf","w","h","ff_copyin_frame","sws_scale_frame","ff_copyout_frame","av_frame_free_js","sws_freeContext","idx","UnsupportedException","super","demuxer","onDestroy","isLoaded","workerIndex","workersTotal","onFrame","hasWebCodecs","globalThis","vdec","evc","rendering","LibAVWebCodecs","nosimd","loadLibAV","decodedFrames","seconds","bitmap","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","m","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","keys","every","splice","r","getPrototypeOf","value","mode","__esModule","ns","create","def","current","getOwnPropertyNames","d","definition","o","defineProperty","enumerable","f","chunkId","reduce","promises","u","miniCssF","g","Function","prop","prototype","hasOwnProperty","Symbol","toStringTag","scriptUrl","importScripts","location","currentScript","src","scripts","getElementsByTagName","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","moreModules","runtime","pop"],"sourceRoot":""}