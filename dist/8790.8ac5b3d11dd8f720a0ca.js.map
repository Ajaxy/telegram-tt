{"version":3,"file":"8790.8ac5b3d11dd8f720a0ca.js","mappings":"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","sources":["webpack://telegram-t/./node_modules/music-metadata/lib/aiff/AiffToken.js","webpack://telegram-t/./node_modules/music-metadata/lib/iff/index.js","webpack://telegram-t/./node_modules/music-metadata/lib/aiff/AiffParser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nexport const compressionTypes = {\n    NONE: 'not compressed\tPCM\tApple Computer',\n    sowt: 'PCM (byte swapped)',\n    fl32: '32-bit floating point IEEE 32-bit float',\n    fl64: '64-bit floating point IEEE 64-bit float\tApple Computer',\n    alaw: 'ALaw 2:1\t8-bit ITU-T G.711 A-law',\n    ulaw: 'µLaw 2:1\t8-bit ITU-T G.711 µ-law\tApple Computer',\n    ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',\n    ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',\n    FL32: 'Float 32\tIEEE 32-bit float '\n};\nexport class AiffContentError extends makeUnexpectedFileContentError('AIFF') {\n}\nexport class Common {\n    constructor(header, isAifc) {\n        this.isAifc = isAifc;\n        const minimumChunkSize = isAifc ? 22 : 18;\n        if (header.chunkSize < minimumChunkSize)\n            throw new AiffContentError(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        // see: https://cycling74.com/forums/aiffs-80-bit-sample-rate-value\n        const shift = Token.UINT16_BE.get(buf, off + 8) - 16398;\n        const baseSampleRate = Token.UINT16_BE.get(buf, off + 8 + 2);\n        const res = {\n            numChannels: Token.UINT16_BE.get(buf, off),\n            numSampleFrames: Token.UINT32_BE.get(buf, off + 2),\n            sampleSize: Token.UINT16_BE.get(buf, off + 6),\n            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift\n        };\n        if (this.isAifc) {\n            res.compressionType = FourCcToken.get(buf, off + 18);\n            if (this.len > 22) {\n                const strLen = Token.UINT8.get(buf, off + 22);\n                if (strLen > 0) {\n                    const padding = (strLen + 1) % 2;\n                    if (23 + strLen + padding === this.len) {\n                        res.compressionName = new Token.StringType(strLen, 'latin1').get(buf, off + 23);\n                    }\n                    else {\n                        throw new AiffContentError('Illegal pstring length');\n                    }\n                }\n                else {\n                    res.compressionName = undefined;\n                }\n            }\n        }\n        else {\n            res.compressionName = 'PCM';\n        }\n        return res;\n    }\n}\n//# sourceMappingURL=AiffToken.js.map","import * as Token from 'token-types';\nimport { FourCcToken } from '../common/FourCC.js';\n/**\n * Common AIFF chunk header\n */\nexport const Header = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Chunk type ID\n            chunkID: FourCcToken.get(buf, off),\n            // Chunk size\n            chunkSize: Number(BigInt(Token.UINT32_BE.get(buf, off + 4)))\n        };\n    }\n};\n//# sourceMappingURL=index.js.map","import * as Token from 'token-types';\nimport initDebug from 'debug';\nimport * as strtok3 from 'strtok3';\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport * as AiffToken from './AiffToken.js';\nimport { AiffContentError, compressionTypes } from './AiffToken.js';\nimport * as iff from '../iff/index.js';\nconst debug = initDebug('music-metadata:parser:aiff');\n/**\n * AIFF - Audio Interchange File Format\n *\n * Ref:\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\n */\nexport class AIFFParser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.isCompressed = null;\n    }\n    async parse() {\n        const header = await this.tokenizer.readToken(iff.Header);\n        if (header.chunkID !== 'FORM')\n            throw new AiffContentError('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\n        const type = await this.tokenizer.readToken(FourCcToken);\n        switch (type) {\n            case 'AIFF':\n                this.metadata.setFormat('container', type);\n                this.isCompressed = false;\n                break;\n            case 'AIFC':\n                this.metadata.setFormat('container', 'AIFF-C');\n                this.isCompressed = true;\n                break;\n            default:\n                throw new AiffContentError(`Unsupported AIFF type: ${type}`);\n        }\n        this.metadata.setFormat('lossless', !this.isCompressed);\n        try {\n            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\n                debug(`Reading AIFF chunk at offset=${this.tokenizer.position}`);\n                const chunkHeader = await this.tokenizer.readToken(iff.Header);\n                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\n                const bytesRead = await this.readData(chunkHeader);\n                await this.tokenizer.ignore(nextChunk - bytesRead);\n            }\n        }\n        catch (err) {\n            if (err instanceof strtok3.EndOfStreamError) {\n                debug(\"End-of-stream\");\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    async readData(header) {\n        switch (header.chunkID) {\n            case 'COMM': { // The Common Chunk\n                if (this.isCompressed === null) {\n                    throw new AiffContentError('Failed to parse AIFF.COMM chunk when compression type is unknown');\n                }\n                const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\n                this.metadata.setFormat('bitsPerSample', common.sampleSize);\n                this.metadata.setFormat('sampleRate', common.sampleRate);\n                this.metadata.setFormat('numberOfChannels', common.numChannels);\n                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\n                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\n                if (common.compressionName || common.compressionType) {\n                    this.metadata.setFormat('codec', common.compressionName ?? compressionTypes[common.compressionType]);\n                }\n                return header.chunkSize;\n            }\n            case 'ID3 ': { // ID3-meta-data\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser().parse(this.metadata, rst, this.options);\n                return header.chunkSize;\n            }\n            case 'SSND': // Sound Data Chunk\n                if (this.metadata.format.duration) {\n                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\n                }\n                return 0;\n            case 'NAME': // Sample name chunk\n            case 'AUTH': // Author chunk\n            case '(c) ': // Copyright chunk\n            case 'ANNO': // Annotation chunk\n                return this.readTextChunk(header);\n            default:\n                debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);\n                return 0;\n        }\n    }\n    async readTextChunk(header) {\n        const value = await this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));\n        const values = value.split('\\0').map(v => v.trim()).filter(v => v?.length);\n        await Promise.all(values.map(v => this.metadata.addTag('AIFF', header.chunkID, v)));\n        return header.chunkSize;\n    }\n}\n//# sourceMappingURL=AiffParser.js.map"],"names":["compressionTypes","NONE","sowt","fl32","fl64","alaw","ulaw","ULAW","ALAW","FL32","AiffContentError","Common","constructor","header","isAifc","this","minimumChunkSize","chunkSize","len","get","buf","off","shift","baseSampleRate","res","numChannels","numSampleFrames","sampleSize","sampleRate","Math","abs","compressionType","strLen","compressionName","undefined","Header","chunkID","Number","BigInt","debug","AIFFParser","BasicParser","super","arguments","isCompressed","parse","tokenizer","readToken","type","metadata","setFormat","fileInfo","size","position","chunkHeader","nextChunk","round","bytesRead","readData","ignore","err","common","id3_data","rst","ID3v2Parser","options","format","duration","readTextChunk","values","split","map","v","trim","filter","length","Promise","all","addTag"],"sourceRoot":""}