{"version":3,"file":"2465.fb5f46e6c944f27124e8.js","mappings":"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","sources":["webpack://telegram-t/./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js","webpack://telegram-t/./node_modules/music-metadata/lib/flac/FlacParser.js","webpack://telegram-t/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js","webpack://telegram-t/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nexport class VorbisParser {\n    constructor(metadata, options) {\n        this.pageSegments = [];\n        this.metadata = metadata;\n        this.options = options;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisParser.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.calculateDuration(header);\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisParser.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n            this.metadata.setFormat('duration', header.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param header\n     * @param pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n//# sourceMappingURL=VorbisParser.js.map","import * as Token from 'token-types';\nexport class VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = new TextDecoder('utf-8').decode(this.data.subarray(this.offset, this.offset + len));\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.slice(0, idx).toUpperCase(),\n            value: v.slice(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n//# sourceMappingURL=VorbisDecoder.js.map","import { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\nimport initDebug from 'debug';\nimport * as util from '../common/Util.js';\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { VorbisParser } from '../ogg/vorbis/VorbisParser.js';\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:FLAC');\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\n}\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nconst BlockType = {\n    STREAMINFO: 0, // STREAMINFO\n    PADDING: 1, // PADDING\n    APPLICATION: 2, // APPLICATION\n    SEEKTABLE: 3, // SEEKTABLE\n    VORBIS_COMMENT: 4, // VORBIS_COMMENT\n    CUESHEET: 5, // CUESHEET\n    PICTURE: 6 // PICTURE\n};\nexport class FlacParser extends AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.vorbisParser = new VorbisParser(this.metadata, this.options);\n        this.padding = 0;\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new FlacContentError('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    async parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case BlockType.STREAMINFO:\n                return this.parseBlockStreamInfo(blockHeader.length);\n            case BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case BlockType.APPLICATION:\n                break;\n            case BlockType.SEEKTABLE:\n                break;\n            case BlockType.VORBIS_COMMENT:\n                return this.parseComment(blockHeader.length);\n            case BlockType.CUESHEET:\n                break;\n            case BlockType.PICTURE:\n                await this.parsePicture(blockHeader.length);\n                return;\n            default:\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async parseBlockStreamInfo(dataLen) {\n        if (dataLen !== BlockStreamInfo.len)\n            throw new FlacContentError('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(dataLen) {\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\n        const decoder = new VorbisDecoder(data, 0);\n        decoder.readStringUtf8(); // vendor (skip)\n        const commentListLength = decoder.readInt32();\n        const tags = new Array(commentListLength);\n        for (let i = 0; i < commentListLength; i++) {\n            tags[i] = decoder.parseUserComment();\n        }\n        await Promise.all(tags.map(tag => this.vorbisParser.addTag(tag.key, tag.value)));\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        const picture = await this.tokenizer.readToken(new VorbisPictureToken(dataLen));\n        this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n}\nconst BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: util.getBit(buf, off, 7),\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\n            length: UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nconst BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\n        };\n    }\n};\n//# sourceMappingURL=FlacParser.js.map","import * as Token from 'token-types';\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nexport class VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexport const CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: Token.UINT8.get(buf, off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexport const IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n//# sourceMappingURL=Vorbis.js.map","import { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { ID3v2Header } from './ID3v2Token.js';\nimport { ID3v2Parser } from './ID3v2Parser.js';\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\nimport { BasicParser } from '../common/BasicParser.js';\nconst debug = initDebug('music-metadata:parser:ID3');\n/**\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\n */\nexport class AbstractID3Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.id3parser = new ID3v2Parser();\n    }\n    static async startsWithID3v2Header(tokenizer) {\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\n    }\n    async parse() {\n        try {\n            await this.parseID3v2();\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"End-of-stream\");\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    finalize() {\n        return;\n    }\n    async parseID3v2() {\n        await this.tryReadId3v2Headers();\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\n        await this.postId3v2Parse();\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\n            this.finalize();\n        }\n        else {\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\n            await id3v1parser.parse();\n            this.finalize();\n        }\n    }\n    async tryReadId3v2Headers() {\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\n        if (id3Header.fileIdentifier === 'ID3') {\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\n            return this.tryReadId3v2Headers();\n        }\n    }\n}\n//# sourceMappingURL=AbstractID3Parser.js.map"],"names":["debug","VorbisContentError","VorbisParser","constructor","metadata","options","this","pageSegments","parsePage","header","pageData","headerType","firstPage","parseFirstPage","continued","length","push","lastPage","fullPage","mergeUint8Arrays","parseFullPage","calculateDuration","arrays","totalSize","reduce","acc","e","merged","Uint8Array","forEach","array","i","_arrays","offset","slice","set","flush","parseUserComment","tag","addTag","key","value","len","id","skipCovers","fromBase64","format","sampleRate","absoluteGranulePosition","setFormat","commonHeader","get","vorbis","packetType","idHeader","bitrateNominal","channelMode","byteLength","parseUserCommentList","strLen","userCommentListLength","VorbisDecoder","data","readInt32","readStringUtf8","TextDecoder","decode","subarray","offset0","v","idx","indexOf","toUpperCase","FlacContentError","FlacParser","super","arguments","vorbisParser","padding","postId3v2Parse","tokenizer","readToken","toString","blockHeader","BlockHeader","parseDataBlock","lastBlock","fileInfo","size","duration","dataSize","position","type","parseBlockStreamInfo","parseComment","parsePicture","addWarning","ignore","then","dataLen","BlockStreamInfo","streamInfo","channels","bitsPerSample","totalSamples","Uint8ArrayType","decoder","commentListLength","tags","Array","Promise","all","map","picture","buf","off","UINT24_BE","minimumBlockSize","UINT16_BE","maximumBlockSize","minimumFrameSize","maximumFrameSize","fileMD5","VorbisPictureToken","base64str","fromBuffer","from","atob","c","charCodeAt","buffer","mimeLen","descLen","description","width","height","colour_depth","indexed_color","picDataLen","CommonHeader","IdentificationHeader","uint8Array","version","bitrateMax","bitrateMin","AbstractID3Parser","id3parser","startsWithID3v2Header","peekToken","fileIdentifier","parse","parseID3v2","err","finalize","tryReadId3v2Headers","skipPostHeaders","hasAny","id3v1parser"],"sourceRoot":""}